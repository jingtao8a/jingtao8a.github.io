<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1.启动选项</title>
    <url>/2023/05/27/1-%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<blockquote>
<p>在MySQL安装目录下的bin目录中的各种可执行文件，不论是服务器相关的程序（比如mysqld、mysqld_safe）还是客户端相关的程序（比如mysql、mysqladmin），在启动的时候基本都可以指定启动参数。这些启动参数可以放在命令行中指定，也可以把它们放在配置文件中指定。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld --skip-networking 禁止客户端使用TCP/IP网络进行通信</span><br><span class="line">mysqld --default-storage-engine=MyISAM 指定服务端的存储引擎&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h -u -p 客户端</span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><blockquote>
<p>MySQL程序在启动时会寻找多个路径下的配置文件，这些路径有的是固定的，有的是可以在命令行指定的。根据操作系统的不同，配置文件的路径也有所不同。</p>
</blockquote>
<p><img src="/images/1_1.jpg" alt="本地图片"></p>
<ul>
<li><p>%WINDIR%是机器上的Windows目录，通常是C:\WINDOWS，可以使用echo %WINDIR%查看</p>
</li>
<li><p>BASEDIR指的是MySQL安装目录</p>
</li>
<li><p>第四个路径指的是我们在启动程序时可以通过指定default-extra-file参数来额外配置文件路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld --defaults-extra-file=C:\Users\xiaohaizi\my_extra_file.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/images/1_2.jpg" alt="本地图片"></p>
<ul>
<li>MYSQL_HOME是一个环境变量，该变量的值是我们自己设置的，我们想设置就设置，不想设置就不设置。该变量的值代表一个路径，我们可以在该路径下创建一个my.cnf配置文件，那么这个配置文件中只能放置关于启动服务器程序相关的选项（言外之意就是其他的配置文件既能存放服务器相关的选项也能存放客户端相关的选项，.mylogin.cnf除外，它只能存放客户端相关的一些选项）</li>
<li>defaults-extra-file的含义与Windows中的一样。<br><strong>在mysqld_safe调用mysqld时，会把它处理不了的这个skip-networking选项交给mysqld处理。</strong></li>
</ul>
<h3 id="配置文件的内容"><a href="#配置文件的内容" class="headerlink" title="配置文件的内容"></a>配置文件的内容</h3><p>[server]<br>(具体的启动选项…)</p>
<p>[mysqld]<br>(具体的启动选项…)</p>
<p>[mysqld_safe]<br>(具体的启动选项…)</p>
<p>[client]<br>(具体的启动选项…)</p>
<p>[mysql]<br>(具体的启动选项…)</p>
<p>[mysqladmin]<br>(具体的启动选项…)</p>
<p><img src="/images/1_3.jpg" alt="本地图片"><br>不同的启动命令读取配置文件的不同的组</p>
<h3 id="配置文件的优先级"><a href="#配置文件的优先级" class="headerlink" title="配置文件的优先级"></a>配置文件的优先级</h3><p>如果我们在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准</p>
<h3 id="同一个配置文件中多个组的优先级"><a href="#同一个配置文件中多个组的优先级" class="headerlink" title="同一个配置文件中多个组的优先级"></a>同一个配置文件中多个组的优先级</h3><p>比如mysqld命令启动服务端程序，可以访问配置文件中的[mysqld]、[server]等，那么将以最后一个出现的组中的启动选项为准</p>
<h3 id="default-file使用"><a href="#default-file使用" class="headerlink" title="default-file使用"></a>default-file使用</h3><p> 如果我们不想让MySQL到默认的路径下搜索配置文件（就是上表中列出的那些），可以在命令行指定defaults-file选项，比如这样（以UNIX系统为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld --defaults-file=/tmp/myconfig.txt</span><br></pre></td></tr></table></figure>
<p><strong>如果同一个启动选项既出现在配置文件中，又出现在命令行中，以命令行为准</strong></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>10.InnoDB统计数据是如何收集的</title>
    <url>/2023/05/27/10-InnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E7%9A%84/</url>
    <content><![CDATA[<p>InnoDB提供了两种存储统计数据的方式</p>
<ul>
<li>永久性的统计数据：<br>这些数据存储在磁盘上，服务器重启之后这些统计数据还在</li>
<li>非永久性的统计数据：<br>这种数据存储在内存中，服务器重启之后，在某些适当的场景下才会重新收集这些统计数据<blockquote>
<p>系统变量innodb_status_persistent来控制到底采用哪种方式去存储统计数据。另外，InnoDB默认是以表为单位来收集和存储统计数据的，所以可以把某些表的统计数据存储在磁盘上，把另一些表的统计数据存储在内存中。可以在创建和修改表的时候通过指定STATS_PERSISTENT属性来指明该表的统计数据存储方式</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>11.MySQL基于规则的优化</title>
    <url>/2023/05/27/11-MySQL%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="条件简化"><a href="#条件简化" class="headerlink" title="条件简化"></a>条件简化</h2><p>1.移除不必要的括号<br>2.常量传递<br>3.等值传递<br>4.表达式计算<br>5.HAVING子句和WHERE子句的合并</p>
<p>子查询的执行方式</p>
<ul>
<li>对于包含不相关的标量子查询或者行子查询的语句来说，MySQL会分别独立执行外层查询和子查询，就当作两个单表查询就行</li>
<li>对于相关的标量子查询或者行子查询，它的执行方式如下：<br><img src="/images/11_1.jpg" alt="QQ截图20230217111828.png"></li>
</ul>
<p>IN子查询优化</p>
<p>如果子查询的结果集中的记录条数很少，那么把子查询和外层查询分别看成两个单独的单表查询效率还是很高的，但是子查询的结果集太多的话会导致一下问题</p>
<ul>
<li>结果集太多，内存无法存下</li>
<li>对于外层查询来说，如果子查询的结果集太多，就意味着IN子句中的参数很多，会导致（1.无法有效的使用索引，只能对外层查询进行全表扫描 2.在对外层查询执行全表扫描时，由于IN子句中的参数太多，这会导致检测一条记录是否符合和IN子句中的参数匹配花费的时间太长）<blockquote>
<p>解决办法：不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果写入一个临时表（1.该临时表的列就是子查询结果集中的列 2.写入临时表的记录会被去重 3.一般情况下子查询结果不会大的离谱，所以会为集合中的数据建立基于内存的存储引擎的临时表，并为该表建立哈希索引，如果子查询结果很大，会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为B+树索引）</p>
</blockquote>
</li>
</ul>
<p>物化表转连接</p>
<p>松散索引扫描</p>
<p>如果IN子查询不满足转换为semi-join的条件，又不能转换为物化表或者转换为物化表的成本太大，那么它就会转换为EXISTS查询</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>12.事务</title>
    <url>/2023/05/27/12-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>1.原子性：要么全做，要么全不做<br>2.隔离性：保证其它的状态转换不会影响到本次的状态转换<br>3.一致性（符合所有现实世界的约束）：</p>
<blockquote>
<ul>
<li>数据库本身能为我们保证一部分一致性需求,比如MySQL数据库可以为表建立主键、唯一索引、外键、声明某个列为NOT NULL来拒绝NULL值的插入。又比如对某个列建立了唯一索引时，如果插入某条记录时该列的值重复了，那么MySQL就会报错并且拒绝插入，MySQL还支持CHECK语法来自定义约束,但是实际上MySQL并不会去检查CHECK子句中的约束是否成立，但是我们还是可以通过定义触发器的方式来自定义一些约束条件以保证数据库中的一致性</li>
<li>更多的一致性需求需要靠写业务代码的程序员自己保证，现实生活中复杂的一致性需求比比皆是，而由于性能问题把一致性需求交给数据库去解决这是不现实的，所以就把锅甩给了业务端程序员</li>
</ul>
</blockquote>
<p>原子性和隔离性都会对一致性产生影响，数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保证符合所有既定的约束则是一种结果</p>
<p>4.持久性：状态转换后，这个转换的结果是永久保留的</p>
<p>事务的定义：把需要保证原子性、隔离性、一致性、持久性的一个或多个数据库操作称之为一个事务</p>
<p>事务的状态转换图如下<br><img src="/images/12_1.jpg" alt="微信截图_20230218105257.png"></p>
<h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><p>当我们适用START TRANSACTION 或者BEGIN 语句开启了一个事务，或者把系统标量auto commit为OFF时，事务就不会进行自动提交，但是如果我们输入了某些语句之后就会悄悄的提交掉<br>1.定义或修改数据库对象的数据定义语言：所谓的数据库对象，指的就是数据库、表、视图、存储过程等，当我们使用CREATE、ALTER、DROP等语句去修改这些所谓的数据库对象时，就会隐式的提交前面语句所属的事务<br>2.隐式使用或修改数据库中的表：当我们使用ALTER USER、CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET PASSWORD等语句时也会隐式的提交前面语句所属于的事务<br>3.事务控制或关于锁定的语句：当我们在一个事务还没有提交或者回滚时就又使用START TRANSACTION 或者BEGIN语句开启了另一个事务，会隐式提交上一个事务<br>4.加载数据的语句：使用LOAD DATA等<br>5.关于MySQL复制的一些语句：使用START SLAVE、STOP SLAVE、RESET SLAVE、CHANGE MASTER TO等语句时也会隐式的提交前面语句所属的事务<br>6.其它的一些语句：使用ANALYZE TABLE、CACHE INDEX、CHECK TABLE、FLUSH、LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET等语句</p>
<h3 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h3><p>定义保存点的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAVEPOINT 保存点的名称</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>13.redo日志</title>
    <url>/2023/05/27/13-redo%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的redo日志刷新到磁盘的好处如下<br>1.redo日志占用的空间非常小<br>2.redo日志是顺序写入磁盘的</p>
<p>每条语句包含多个mtr，每个mtr包含一组redo log<br>一个mtr运行结束后，会将产生的一组redolog复制到log buffer中，在一些情况下它们会被刷新到磁盘里<br>1.log buffer空间不足时<br>2.事务提交时<br>3.后台线程不停地刷<br>4.正常关闭服务器<br>5.做checkpoint 时<br>6.其它情况</p>
<p>redo日志文件前4个block</p>
<ul>
<li>log file header：描述该日志文件地一些整体属性</li>
<li>checkpoint1</li>
<li>无用</li>
<li>checkpoint2</li>
</ul>
<p>Log Sequence Number（日志序列号）lsn<br>每一组由mtr生成地redo日志都有一个唯一的lsn值与其对应，lsn值越小，说明redo日志产生的越早</p>
<p>在mtr结束时，还会将执行过程中可能修改过的页面加入到buffer pool 的flush链表</p>
<p>checkpoint：<br>redo日志只是为了系统崩溃后恢复脏页用的，如果对应的脏页已经刷新到磁盘，就不需要对应的redo日志了，所以判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。</p>
<p>做一次checkpoint其实可以分为两个步骤<br>1.计算一下当前系统中可以被覆盖的redo日志对应的lsn值最大是多少（有必要的话更新checkpoint_lsn）<br>2.将checkpoint_lsn和对应的redo日志文件组偏移量以及此次checkpoint的编号写到日志文件的管理信息（目前系统做了多少次checkpoint的变量checkpoint_no，每做一次checkpoint，该变量就加1）</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>14.undo日志</title>
    <url>/2023/05/27/14-undo%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="事务id"><a href="#事务id" class="headerlink" title="事务id"></a>事务id</h2><ul>
<li>对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个事务id</li>
<li>对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个事务id</li>
</ul>
<p>聚簇索引的记录还会自动添加名为trx_id、roll_pointer的隐藏列<br>其中trx_id就是对这个聚簇索引记录做改动的语句所在的事务对应的事务id<br>roll_pointer就是一个指向记录对应的undo日志的一个指针</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>15.事务的隔离级别</title>
    <url>/2023/05/27/15-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<p>事务并发执行遇到的问题<br>1.脏写：<br>一个事务修改了另一个未提交事务修改过的数据<br>2.脏读<br>一个事务读到了另一个未提交事务修改过的数据<br>3.不可重复读<br>一个事务只能读到另一个已经提交的事务修改过的数据，并且其它事务每对该数据进行一次修改，并提交后都能查询得到最新值<br>4.幻读<br>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来</p>
<p>MySQL四种隔离级别<br><img src="/images/15_1.jpg" alt="微信截图_20230219113504.png"></p>
<p>MVCC原理（多版本并发控制）<br>版本链<br>READ COMMITTED和REPEATABLE READ生成ReadView的时机不同</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>2.系统变量</title>
    <url>/2023/05/27/2-%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="系统变量简介"><a href="#系统变量简介" class="headerlink" title="系统变量简介"></a>系统变量简介</h3><blockquote>
<p>MySQL服务器程序运行过程中会用到许多影响程序行为的变量，它们被称为MySQL系统变量，比如允许同时连入的客户端数量用系统变量max_connections表示，表的默认存储引擎用系统变量default_storage_engine表示，查询缓存的大小用系统变量query_cache_size表示，MySQL服务器程序的系统变量有好几百条，我们就不一一列举了。</p>
</blockquote>
<p>我们可以使用下列命令查看MySQL服务器程序支持的系统变量以及它们的当前值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure>
<h3 id="设置系统变量"><a href="#设置系统变量" class="headerlink" title="设置系统变量"></a>设置系统变量</h3><h4 id="通过启动选项设置"><a href="#通过启动选项设置" class="headerlink" title="通过启动选项设置"></a>通过启动选项设置</h4><p>1.通过命令行添加启动选项。<br>2.通过配置文件添加启动选项</p>
<h4 id="服务器程序运行过程中设置"><a href="#服务器程序运行过程中设置" class="headerlink" title="服务器程序运行过程中设置"></a>服务器程序运行过程中设置</h4><h5 id="设置不同作用范围的系统变量"><a href="#设置不同作用范围的系统变量" class="headerlink" title="设置不同作用范围的系统变量"></a>设置不同作用范围的系统变量</h5><blockquote>
<p>我们前面说过，多个客户端程序可以同时连接到一个服务器程序。对于同一个系统变量，我们有时想让不同的客户端有不同的值。比方说狗哥使用客户端A，他想让当前客户端对应的默认存储引擎为InnoDB，所以他可以把系统变量default_storage_engine的值设置为InnoDB；猫爷使用客户端B，他想让当前客户端对应的默认存储引擎为MyISAM，所以他可以把系统变量default_storage_engine的值设置为MyISAM。这样可以使狗哥和猫爷的的客户端拥有不同的默认存储引擎，使用时互不影响，十分方便。但是这样各个客户端都私有一份系统变量会产生这么两个问题：</p>
</blockquote>
<ul>
<li>有一些系统变量并不是针对单个客户端的，比如允许同时连接到服务器的客户端数量max_connections，查询缓存的大小query_cache_size，这些公有的系统变量让某个客户端私有显然不合适。</li>
<li>一个新连接到服务器的客户端对应的系统变量的值该怎么设置？<blockquote>
<p>为了解决这两个问题，设计MySQL的大佬提出了系统变量的作用范围的概念，具体来说作用范围分为这两种,GLOBAL（全局变量，影响服务器整体操作）和SESSION（会话变量，影响某个客户端连接的操作，别名LOCAL）通过启动选项设置的系统变量的作用范围都是GLOBAL的，也就是对所有客户端都有效的</p>
</blockquote>
</li>
</ul>
<p>在服务器程序运行期间通过客户端程序设置系统变量的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] 系统变量名 = 值;</span><br></pre></td></tr></table></figure>
<h5 id="查看不同作用范围的系统变量"><a href="#查看不同作用范围的系统变量" class="headerlink" title="查看不同作用范围的系统变量"></a>查看不同作用范围的系统变量</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure>
<p>小贴士：如果某个客户端改变了某个系统变量在<code>GLOBAL</code>作用范围的值，并不会影响该系统变量在当前已经连接的客户端作用范围为<code>SESSION</code>的值，只会影响后续连入的客户端在作用范围为<code>SESSION</code>的值。</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li><p>并不是所有系统变量都具有<code>GLOBAL</code>和<code>SESSION</code>的作用范围。</p>
<ul>
<li><p>有一些系统变量只具有<code>GLOBAL</code>作用范围，比方说<code>max_connections</code>，表示服务器程序支持同时最多有多少个客户端程序进行连接。</p>
</li>
<li><p>有一些系统变量只具有<code>SESSION</code>作用范围，比如<code>insert_id</code>，表示在对某个包含<code>AUTO_INCREMENT</code>列的表进行插入时，该列初始的值。</p>
</li>
<li><p>有一些系统变量的值既具有<code>GLOBAL</code>作用范围，也具有<code>SESSION</code>作用范围，比如我们前面用到的<code>default_storage_engine</code>，而且其实大部分的系统变量都是这样的，</p>
</li>
</ul>
</li>
<li><p>有些系统变量是只读的，并不能设置值。</p>
<p>  比方说<code>version</code>，表示当前<code>MySQL</code>的版本，我们客户端是不能设置它的值的，只能在<code>SHOW VARIABLES</code>语句里查看。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>3.状态变量</title>
    <url>/2023/05/27/3-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><blockquote>
<p>为了让我们更好的了解服务器程序的运行情况，MySQL服务器程序中维护了很多关于程序运行状态的变量，它们被称为状态变量。比方说Threads_connected表示当前有多少客户端与服务器建立了连接，Handler_update表示已经更新了多少行记录等，像这样显示服务器程序状态信息的状态变量还有好几百个，我们就不一一介绍了，等遇到了会详细说它们的作用的。</p>
</blockquote>
<p>  由于状态变量是用来显示服务器程序运行状况的，所以它们的值只能由服务器程序自己来设置，我们程序员是不能设置的。与系统变量类似，状态变量也有GLOBAL和SESSION两个作用范围的，所以查看状态变量的语句可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>4.字符集和比较规则</title>
    <url>/2023/05/27/4-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h2 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h2><blockquote>
<p>总共128个字符，包括一些不可见字符</p>
</blockquote>
<h2 id="ISO-8859-1-字符集（latin1）"><a href="#ISO-8859-1-字符集（latin1）" class="headerlink" title="ISO 8859-1 字符集（latin1）"></a>ISO 8859-1 字符集（latin1）</h2><blockquote>
<p>共收录256个字符，是在ASCII字符集的基础上又扩充了128个西欧常用字符（包括德法两国的字母），也可以使用1个字节来进行编码。</p>
</blockquote>
<h2 id="GB2312字符集"><a href="#GB2312字符集" class="headerlink" title="GB2312字符集"></a>GB2312字符集</h2><blockquote>
<p>收录了汉字以及拉丁字母，希腊字母 收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字6763个，其他文字符号682个。同时这种字符集又兼容ASCII字符集，所以在编码方式上显得有些奇怪：<br>1.如果该字符在ASCII字符集中，则采用1字节编码<br>2.否则采用2字节编码</p>
</blockquote>
<h2 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h2><blockquote>
<p>GBK字符集只是在收录字符范围上对GB2312字符集作了扩充，编码方式上兼容GB2312</p>
</blockquote>
<h2 id="utf8字符集"><a href="#utf8字符集" class="headerlink" title="utf8字符集"></a>utf8字符集</h2><blockquote>
<p>收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容ASCII字符集，采用变长编码方式，编码一个字符需要使用1～4个字节</p>
</blockquote>
<p><strong>其实准确的说，utf8只是Unicode字符集的一种编码方案，Unicode字符集可以采用utf8、utf16、utf32这几种编码方案，utf8使用1～4个字节编码一个字符，utf16使用2个或4个字节编码一个字符，utf32使用4个字节编码一个字符。更详细的Unicode和其编码方案的知识不是本书的重点，大家上网查查。MySQL中并不区分字符集和编码方案的概念，所以后边介绍的时候把utf8、utf16、utf32都当作一种字符集对待。</strong> </p>
<h2 id="MySQL中支持的字符集和排序规则"><a href="#MySQL中支持的字符集和排序规则" class="headerlink" title="MySQL中支持的字符集和排序规则"></a>MySQL中支持的字符集和排序规则</h2><h4 id="MySQL中的utf8和utf8mb4"><a href="#MySQL中的utf8和utf8mb4" class="headerlink" title="MySQL中的utf8和utf8mb4"></a>MySQL中的utf8和utf8mb4</h4><ul>
<li>utf8mb3：阉割过的utf8字符集，只使用1～3个字节表示字符。</li>
<li>utf8mb4：正宗的utf8字符集，使用1～4个字节表示字符。</li>
</ul>
<h4 id="MySQL字符集的查看"><a href="#MySQL字符集的查看" class="headerlink" title="MySQL字符集的查看"></a>MySQL字符集的查看</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure>

<h4 id="MySQL比较规则的查看"><a href="#MySQL比较规则的查看" class="headerlink" title="MySQL比较规则的查看"></a>MySQL比较规则的查看</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW COLLATION [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure>
<h4 id="各个级别的字符集和比较规则"><a href="#各个级别的字符集和比较规则" class="headerlink" title="各个级别的字符集和比较规则"></a>各个级别的字符集和比较规则</h4><ul>
<li><p>服务器级别<br>MySQL提供了两个系统变量来表示服务器级别的字符集和比较规则:<br><img src="/images/4_1.jpg" alt="QQ截图20221205152423.png"><br>服务器级别默认的字符集是utf8，默认的比较规则是utf8_general_ci<br>可以用以下命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE [匹配模式]</span><br></pre></td></tr></table></figure></li>
<li><p>数据库级别<br>我们在创建和修改数据库的时候可以指定该数据库的字符集和比较规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br><span class="line"></span><br><span class="line">ALTER DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure>
<p>如果想查看当前数据库使用的字符集和比较规则，可以查看下面两个系统变量的值（前提是使用USE语句选择当前默认数据库，如果没有默认数据库，则变量与相应的服务器级系统变量具有相同的值）：<br><img src="/images/4_2.jpg" alt="QQ截图20221205153115.png"></p>
</li>
<li><p>表级别<br>我们也可以在创建和修改表的时候指定表的字符集和比较规则，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息)</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]</span><br></pre></td></tr></table></figure>
</li>
<li><p>列级别<br>需要注意的是，对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],</span><br><span class="line">    其他列...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于某个列来说，如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集和比较规则作为该列的字符集和比较规则。<br><strong>小贴士：在转换列的字符集时需要注意，如果转换前列中存储的数据不能用转换后的字符集进行表示，就会发生错误。比方说原先列使用的字符集是utf8，列中存储了一些汉字，现在把列的字符集转换为ascii的话就会出错，因为ascii字符集并不能表示汉字字符。</strong></p>
</li>
</ul>
<h2 id="MySQL中字符集的转换"><a href="#MySQL中字符集的转换" class="headerlink" title="MySQL中字符集的转换"></a>MySQL中字符集的转换</h2><blockquote>
<p>我们知道从客户端发往服务器的请求本质上就是一个字符串，服务器向客户端返回的结果本质上也是一个字符串，而字符串其实是使用某种字符集编码的二进制数据。</p>
</blockquote>
<p><img src="/images/4_3.jpg" alt="QQ截图20221205153733.png"></p>
<p><img src="/images/4_4.jpg" alt="QQ截图20221205153848.png"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>5.InnoDB记录行格式</title>
    <url>/2023/05/27/5-InnoDB%E8%AE%B0%E5%BD%95%E8%A1%8C%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="InnoDB页简介"><a href="#InnoDB页简介" class="headerlink" title="InnoDB页简介"></a>InnoDB页简介</h1><blockquote>
<p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎。由于磁盘IO和内存IO速度差了几个量级，InnoDB采取的方式是：<strong>将数据划分为若干个页，以页作为磁盘和内存之间的交互的基本单位，InnoDB中页的大小一般为16KB</strong>。</p>
</blockquote>
<h1 id="InnoDB行格式"><a href="#InnoDB行格式" class="headerlink" title="InnoDB行格式"></a>InnoDB行格式</h1><blockquote>
<p>我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为<strong>行格式</strong>或者<strong>记录格式</strong></p>
</blockquote>
<h3 id="指定行格式的语法"><a href="#指定行格式的语法" class="headerlink" title="指定行格式的语法"></a>指定行格式的语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</span><br><span class="line">    </span><br><span class="line">ALTER TABLE 表名 ROW_FORMAT=行格式名称</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h3><p><img src="/images/5_1.jpg" alt="QQ截图20221205160357.png"></p>
<p>一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p>
<ul>
<li><p>记录的额外信息：服务器为了描述这条记录而不得不添加的一些信息，分为3类，变长字段长度列表、NULL值列表、记录头信息<br>1.变长字段长度列表：MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、各种TEXT类型，各种BLOB类型，这些变长字段占用的存储空间分为两部分（真正的数据内容和占用的字节数），对于CHAR(M）类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表<br><strong>在COMPACT行格式中，把所有的变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，按逆序排放</strong><br>2.NULL值列表：处理过程是这样的，先统计表中哪些列允许存储NULL值(主键列、被NOT NULL修饰的列都是不可以存储NULL值的)，所以在统计的时候不会把这些列算进去，接着如果有的列可以存储NULL值，那么就需要NULL值列表，将每个允许存储NULL的列对应一个二进制位（为1代表该列值为NULL，为0代表不为NULL），其次MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0<br>3.记录头信息：它是由固定的5个字节组成，不同位代表不同意思<br><img src="/images/5_2.jpg" alt="QQ截图20221205161836.png"></p>
</li>
<li><p>记录的真实数据<br>MySQL会为每个记录默认的添加一些列（也称为隐藏列），具体的列如下：<br><img src="/images/5_3.jpg" alt="QQ截图20221205162406.png"><br>InnoDB表对主键的生成策略:优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义的化，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键</p>
</li>
</ul>
<h3 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h3><p><img src="/images/5_4.jpg" alt="QQ截图20221207112201.png"></p>
<ul>
<li><p>记录的额外信息<br>1.字段长度偏移列表：与compact行格式相比，没有了变长两个字，多了偏移两个字，Redundant的行格式会把该条记录中所有（包括隐藏列）的长度信息都按照逆序存储到字段长度偏移列表。同时Redundant的行格式是按照两个相邻数值的差值来计算各个列值的长度。<br><img src="/images/5_5.jpg" alt="QQ截图20221207115628.png"></p>
</li>
<li><p>记录头信息<br><img src="/images/5_6.jpg" alt="QQ截图20221207113712.png"><br><img src="/images/5_7.jpg" alt="QQ截图20221207113735.png"></p>
</li>
</ul>
<p>对于Compact和Reduntant行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前768个字节的数据和一个指向其它页的地址，然后把剩下的数据存放到其它页中，这个过程叫做<strong>行溢出，存储超出768字节的那些页也被称为溢出页</strong></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>6.InnoDB数据页结构</title>
    <url>/2023/05/27/6-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="数据页结构图"><a href="#数据页结构图" class="headerlink" title="数据页结构图"></a>数据页结构图</h2><p><img src="/images/6_1.jpg" alt="QQ截图20221212140703.png"></p>
<blockquote>
<p>每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了</p>
</blockquote>
<blockquote>
<p>为了更好的管理在User Records中的这些记录，行格式中的记录头信息至关重要，以下为compact行格式中的记录头信息</p>
</blockquote>
<p><img src="/images/6_2.jpg" alt="QQ截图20221216113033.png"></p>
<h2 id="页目录（Page-Directory"><a href="#页目录（Page-Directory" class="headerlink" title="页目录（Page Directory)"></a>页目录（Page Directory)</h2><p>1.将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。<br>2.每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。<br>3.将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的Page Directory，也就是页目录（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页面目录就是由槽组成的。</p>
<p><img src="/images/6_3.jpg" alt="QQ截图20221216113857.png"></p>
<blockquote>
<p>对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1<del>8 条之间，剩下的分组中记录的条数范围只能在是 4</del>8 条之间。所以分组是按照下面的步骤进行的：</p>
</blockquote>
<ul>
<li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li>
<li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个</li>
<li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li>
</ul>
<p>在一个数据页中查找指定主键值的记录的过程分为两步：<br>1.通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。<br>2.通过记录的next_record属性遍历该槽所在的组中的各个记录。</p>
<h2 id="页面头部-Page-Header"><a href="#页面头部-Page-Header" class="headerlink" title="页面头部(Page Header)"></a>页面头部(Page Header)</h2><p><img src="/images/6_4.jpg" alt="QQ截图20221216114601.png"></p>
<h2 id="文件头部（File-Header"><a href="#文件头部（File-Header" class="headerlink" title="文件头部（File Header)"></a>文件头部（File Header)</h2><p><img src="/images/6_5.jpg" alt="QQ截图20221216114854.png"></p>
<ul>
<li>FIL_PAGE_TYPE 页的类型<br><img src="/images/6_6.jpg" alt="QQ截图20221216115011.png"></li>
<li>FIL_PAGE_PREV和FIL_PAGE_NEXT<br>InnoDB都是以页为单位存放数据的，有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），InnoDB可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。</li>
</ul>
<h2 id="FILE-TAILER"><a href="#FILE-TAILER" class="headerlink" title="FILE TAILER"></a>FILE TAILER</h2><p>InnoDB会把数据存储到磁盘上，操作数据时，需要以页为单位将数据移动到内存中，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办?</p>
<ul>
<li>前4个字节代表页的校验和<blockquote>
<p>这个部分是和File Header中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前面，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trialer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</p>
</blockquote>
</li>
<li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）<blockquote>
<p>这个部分也是为了校验页的完整性的，只不过我们目前还没说LSN是个什么意思，所以大家可以先不用管这个属性。这个File Trailer与File Header类似，都是所有类型的页通用的。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>7.B+树索引</title>
    <url>/2023/05/27/7-B-%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="在没有索引的请况下："><a href="#在没有索引的请况下：" class="headerlink" title="在没有索引的请况下："></a>在没有索引的请况下：</h1><h3 id="在一个页中查找"><a href="#在一个页中查找" class="headerlink" title="在一个页中查找"></a>在一个页中查找</h3><ul>
<li>以主键为搜索条件<br>可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li>
<li>以其它列为搜索条件<br>这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。</li>
</ul>
<p>###在很多个页中查找</p>
<blockquote>
<p>分为两个步骤：<br>1.定位到记录所在的页<br>2.从所在的页内中查找相应的记录</p>
</blockquote>
<p>由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚介绍过的查找方式去查找指定的记录,当然这种方法是非常耗时的</p>
<h1 id="索引查找"><a href="#索引查找" class="headerlink" title="索引查找"></a>索引查找</h1><p>一个简单的索引方案</p>
<ul>
<li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</li>
<li>给所有页建立一个目录项，每个页对应一个目录项，每个目录项包括下面两个部分（页的用户记录中最小的主键值，我们用key来表示。页号，我们用page_no表示。）</li>
</ul>
<p>InnoDB中的索引方案</p>
<ul>
<li>InnoDB是使用页来作为管理存储空间的基本单位，也就是最多能保证16KB的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li>
<li>我们时常会对记录进行增删，假设我们把页28中的记录都删除了，页28也就没有存在的必要了，那意味着目录项2也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这种牵一发而动全身的设计不是什么好主意～</li>
</ul>
<p>所以InnoDB复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。<br>InnoDB就是通过记录头信息中的record_type来进行区分一条普通的记录是普通用户记录还是目录项记录</p>
<p>当为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下面这个图来描述它：<br><img src="/images/7_1.jpg" alt="QQ截图20221216141803.png"><br>一般情况下，我们用到的B+树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的Page Directory（页目录），所以在页面内也可以通过二分法实现快速定位记录</p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>我们上面介绍的B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p>
<p>1.使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li>页内的记录是按照主键的大小顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li>
</ul>
<p>2.B+树的叶子节点存储的是完整的用户记录。</p>
<ul>
<li>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</li>
</ul>
<p>具有以上两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种索引不需要通过使用INDEX语句去创建。</p>
<h3 id="二级索引（辅助索引）"><a href="#二级索引（辅助索引）" class="headerlink" title="二级索引（辅助索引）"></a>二级索引（辅助索引）</h3><p>上面介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。如果想以别的列作为搜索条件，可以多建立几棵B+树<br>在查找数据的过程中，查找完二级索引后只能获得主键值，仍然需要到聚簇索引中再查一遍，这个过程称为回表</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>我们页可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，联合索引的本质上也是一个二级索引。</p>
<h1 id="B-树索引注意事项"><a href="#B-树索引注意事项" class="headerlink" title="B+树索引注意事项"></a>B+树索引注意事项</h1><h3 id="根页面万年不动窝"><a href="#根页面万年不动窝" class="headerlink" title="根页面万年不动窝"></a>根页面万年不动窝</h3><ul>
<li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个根节点中</li>
<li>当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新的分配页，然后再对这个新页进行页分裂的操作，根节点升级为存储目录项记录的页。</li>
</ul>
<h3 id="内节点中目录项记录的唯一性"><a href="#内节点中目录项记录的唯一性" class="headerlink" title="内节点中目录项记录的唯一性"></a>内节点中目录项记录的唯一性</h3><h3 id="一个页面最少存储2条记录"><a href="#一个页面最少存储2条记录" class="headerlink" title="一个页面最少存储2条记录"></a>一个页面最少存储2条记录</h3><h1 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h1><p>将索引和数据分开存储</p>
<ul>
<li>将表中的记录按照记录的插入顺序单独村粗在一个文件中，称之为数据文件。可以通过行号快速访问到一条记录</li>
<li>会将索引信息另外存储到一个称为索引文件的另一个文件中。MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值 + 行号 的组合。先通过索引找到行号，再通过行号去找到对应的记录</li>
<li>如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和InnoDB中的索引差不多，不过在叶子节点处存储的是相应的列 + 行号。这些索引也全部都是二级索引。</li>
</ul>
<h1 id="MySQL中创建和删除索引的语句"><a href="#MySQL中创建和删除索引的语句" class="headerlink" title="MySQL中创建和删除索引的语句"></a>MySQL中创建和删除索引的语句</h1><p>我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TALBE 表名 (</span><br><span class="line">    各种列的信息 ··· , </span><br><span class="line">    [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);</span><br><span class="line">ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>8.单表访问方法</title>
    <url>/2023/05/27/8-%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>const:<br>1.直接利用主键值在聚簇索引中定位对应的用户记录<br>2.根据唯一二级索引列来定位一条记录</p>
</blockquote>
<blockquote>
<p>ref:<br>1.对某个普通的二级索引列与常数进行等值比较<br>2.无论是普通二级索引还是唯一二级索引，索引列值为NULL<br>3.对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较</p>
</blockquote>
<blockquote>
<p>ref_of_null:<br>1.当我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把列的值为NULL的记录也找出来</p>
</blockquote>
<blockquote>
<p>range:<br>1.利用索引进行范围匹配</p>
</blockquote>
<blockquote>
<p>index:<br>1.直接遍历二级索引记录</p>
</blockquote>
<blockquote>
<p>all:<br>1.全表扫描</p>
</blockquote>
<p>优化</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>9.连接的原理</title>
    <url>/2023/05/27/9-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="连接过程简介"><a href="#连接过程简介" class="headerlink" title="连接过程简介"></a>连接过程简介</h3><ul>
<li>涉及单表的条件</li>
<li>涉及两表的条件</li>
</ul>
<p>1.嵌套循环连接<br>2.使用索引加快连接速度<br>3.基于块的嵌套循环连接</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL是怎样运行的</tag>
      </tags>
  </entry>
  <entry>
    <title>ALEX-An-Updatable-Adaptive-Learned-Index</title>
    <url>/2023/10/01/ALEX-An-Updatable-Adaptive-Learned-Index/</url>
    <content><![CDATA[<p>ALEX：An Updatable Adaptive Learned Index</p>
<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>在DBMS中代替传统的索引结构，类似于B树、B+树之类的变种</p>
<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>ALEX索引需要实现点查找、范围查询、插入、删除和批量载入<br>ALEX的目标是<br>1.比B+树写数据更快<br>2.比B+树和learned index读数据要更快<br>3.索引大小要比B+树和learned Index要小</p>
<h2 id="难点与分析过程："><a href="#难点与分析过程：" class="headerlink" title="难点与分析过程："></a>难点与分析过程：</h2><ul>
<li>写数据时：B+树插入到数据节点时需要进行大量的移位操作，对于一个dense Array 它的插入时间复杂度为O(n)</li>
<li>写数据时：B+树插入到数据节点时，根据节点是否已满的条件来将数据节点分裂，分裂到根节点会导致树高的增加</li>
<li>读数据时：B+树遍历到数据节点后，使用二分查找确定带查找的key的position，它的时间复杂度为O（log2n)</li>
<li>读数据时：最初的Learned Index是先将数据排序好之后，再在该数据上创建模型，这样用最后的数据节点来预测key的位置时会有较大出错的概率，并且还需要存储Error Bound</li>
</ul>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><ul>
<li><strong>写数据时</strong>：ALEX使用一个gap array（间隙数组），这样在插入过程中需要更少的移位操作，它的时间复杂度近似于O（log2n）</li>
<li><strong>写数据时</strong>：插入已满数据节点时，使用一个intra-node cost model模型来决定将数据节点扩展（如果没有）或者是分裂<br>Intra-node cost model根据每个数据节点存储的两个信息（1.<strong>平均每次操作指数搜索的迭代次数</strong> 2.<strong>平均每次插入时的移位操作次数</strong>）计算经验成本，再和数据节点的预期成本（节点创建时预期的成本）比较<br>如果经验成本与预期成本没有较大的偏离（超过50%）则执行节点扩展（不会超过节点最大大小限制），否则执行节点分裂</li>
<li><strong>读数据时</strong>：ALEX使用指数查找，先用数据节点的线性模型预测一个position，再判断该position上的key是否大于或者小于待查找的key，以此判断指数查找的方向</li>
</ul>
<p><img src="/../images/ALEX-An-Updatable-Adaptive-Learned-Index/1.png" alt="img"><br>指数查找的时间复杂度分析如下<br><img src="/../images/ALEX-An-Updatable-Adaptive-Learned-Index/2.png" alt="img"><br>并且使用指数查找算法后，也不需要在数据节点模型中存储error bound。</p>
<ul>
<li><strong>读数据时</strong>：ALEX在创建数据节点时使用基于模型的插入，先训练好模型之后，再将模型尽量插入预测的位置，这样可以大大减少预测错误的概率</li>
</ul>
<p><strong>ALEX的节点：</strong><br><strong>Internal node：</strong><br>线性模型（slope intercept）、point array<br><strong>Leaf node：</strong><br>线性模型（slope intercept）、gap array 、bitmap</p>
<p><strong>查找：</strong><br><img src="/../images/ALEX-An-Updatable-Adaptive-Learned-Index/3.png" alt="img"></p>
<p><strong>插入：</strong><br><strong>未满节点:</strong> 按照查找逻辑找到应该插入的数据节点，有必要的情况下用指数查找来找到正确的位置。<br><strong>已满节点：</strong> 已满节点的定义（有一个上下限密度dl du）<br>节点扩展机制：<br><img src="/../images/ALEX-An-Updatable-Adaptive-Learned-Index/4.png" alt="img"><br>节点分裂机制：<br>a.有冗余指针指向数据节点，可以用它分别指向另外两个数据节点<br><img src="/../images/ALEX-An-Updatable-Adaptive-Learned-Index/5.png" alt="img"></p>
<p>b.如果父节点满了，像B+树那样进行拆分，分类一直可以传播到根节点<br><img src="/../images/ALEX-An-Updatable-Adaptive-Learned-Index/6.png" alt="img"></p>
<p><strong>删除：</strong><br>简单删除key和payload，如果Data Node由于删除而达到密度下限dl，那么我们将收缩Data Node避免低空间利用率（思考：是否可以引入合并操作）</p>
<p><strong>更新：</strong><br>Delete和Insert操作结合</p>
<p><strong>界外插入：</strong><br>首先，当ALEX检测到现有key空间之外的插入时，将扩展root节点；如果此扩展将导致根节点超过最大节点大小，ALEX则会创建一个新的root节点，并为新root节点的每个其他指针槽创建一个新的数据节点。<br><img src="/../images/ALEX-An-Updatable-Adaptive-Learned-Index/7.png" alt="img"><br>其次，ALEX最右边的数据节点通过记录节点中的最大键的值和插入超过该最大值的计数器来检测插入行为。如果多次插入都超过该最大值，这意味着这是一个只追加行为，因此数据节点向右扩展，扩展的空间用来更多类似于追加的插入</p>
<p><strong>批量加载</strong><br>RMI成本是通过TraverseToLeaf和intra-node cost model来计算的<br><img src="/../images/ALEX-An-Updatable-Adaptive-Learned-Index/8.png" alt="img"><br><img src="/../images/ALEX-An-Updatable-Adaptive-Learned-Index/9.png" alt="img"><br>每个node为internal node或者leaf node由fanout tree决定，<br>决定每一个node的类型时都独自创建一棵fanout tree</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>数据集选取：<br>使用某个数据集的8字节的key运行所有的实验，并随机生成固定大小的payload。<br>我们在4个数据集上评估了ALEX，其特征和CDF如下所示<br>经度数据集由Open Street Maps中世界各地的经度组成<br>Longlat数据集由复合键组成（k&#x3D;180*floor(longitude)+latitude, 经纬度也是来自Open Street Maps)<br>Lognormal数据集的值是根据对数正态分布N（0，4）生成的，并乘上10^9，再四舍五入到最接近的整数。<br>YCSB数据集表示根据YCSB基准生成的用户ID的值，这些值均匀分布在整个64位域中，并使用80字节的有效载荷<br><img src="/../images/ALEX-An-Updatable-Adaptive-Learned-Index/10.png" alt="img"><br>工作负载：我们评估ALEX的主要指标是平均吞吐量（指定时间内完成的插入或读取量），评估了5个工作负载的吞吐量<br>（1）只读工作负载 （2）具有95%的读取和5%插入的读取繁重的工作负载（3）具有50%的读取和50%的插入的写繁重的工作负载（4）具有95%读取和5%插入的读取的短范围查询的工作负载（5）只写工作负载<br><img src="/../images/ALEX-An-Updatable-Adaptive-Learned-Index/11.png" alt="img"><br>ALEX和learned Index；B+ Tree；模型增强B+ Tree；ART对比</p>
<ul>
<li>在只读工作负载上，ALEX比B+树、learned index、模型增强B+树和ART在吞吐量上高4.1x、2.2x、2.9x、3.0x和在索引大小上小800x、15x、160x、8000x</li>
<li>在读写工作负载上，ALEX比B+树、模型增强B+树和ART在吞吐量上高4.0x、2.7x、2.7x，<br>在索引大小上小2000x、475x、36000x</li>
</ul>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>ASLM:Adaptive Single Layer Model for Learned Index</title>
    <url>/2024/09/28/ASLM-Adaptive-Single-Layer-Model-for-Learned-Index/</url>
    <content><![CDATA[<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>读写场景</p>
<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>Learned Index<br><br>(1)RMI 采用的分区策略没有考虑数据之间的相似性<br><br>(2)RMI 不支持更新</p>
<p><img src="/../images/ASLM-Adaptive-Single-Layer-Model-for-Learned-Index/1.png" alt="img"></p>
<h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><h5 id="Method1"><a href="#Method1" class="headerlink" title="Method1:"></a>Method1:</h5><p><img src="/../images/ASLM-Adaptive-Single-Layer-Model-for-Learned-Index/2.png" alt="img"><br>SLM:这是一个简单的模型，只有一层，这一层包含K个子模型</p>
<h5 id="Method2："><a href="#Method2：" class="headerlink" title="Method2："></a>Method2：</h5><p><img src="/../images/ASLM-Adaptive-Single-Layer-Model-for-Learned-Index/3.png" alt="img"><br>数据点之间三角形面积可替换为欧式距离，用来表示两个数据点之间的相似度</p>
<h4 id="数据插入："><a href="#数据插入：" class="headerlink" title="数据插入："></a>数据插入：</h4><p><img src="/../images/ASLM-Adaptive-Single-Layer-Model-for-Learned-Index/4.png" alt="img"></p>
<p><img src="/../images/ASLM-Adaptive-Single-Layer-Model-for-Learned-Index/5.png" alt="img"></p>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p><img src="/../images/ASLM-Adaptive-Single-Layer-Model-for-Learned-Index/6.png" alt="img"></p>
<p><img src="/../images/ASLM-Adaptive-Single-Layer-Model-for-Learned-Index/7.png" alt="img"></p>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>Bounding-the-Last-Mile-Efficient-Learned-String-Indexing</title>
    <url>/2023/10/10/Bounding-the-Last-Mile-Efficient-Learned-String-Indexing/</url>
    <content><![CDATA[<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>ReadOnly<br>对字符串的学习索引最重要的问题是 last-mile-search,并且这种搜索在字符串场景中特别昂贵。</p>
<p>两个原因</p>
<blockquote>
<ol>
<li>由于难以建模真实世界的数据（许多真实世界的数据集具有很长的共同前缀以及每个字节相对较低的鉴别内容，CDF似乎是循序渐近的，这样传统的学习模型很难准确捕获和预测），这些场景的平均模型误差往往很高</li>
<li>最后一英里的搜索是很慢的，每次比较是昂贵的，字符串的大尺寸减少了适合在缓存中的键的数量</li>
</ol>
</blockquote>
<p>这项研究的基础： Bounded Error（这样就可以使用二分查找代替指数搜索）</p>
<h2 id="SPLING-STRINGS"><a href="#SPLING-STRINGS" class="headerlink" title="SPLING STRINGS"></a>SPLING STRINGS</h2><p>问题描述：对于字符串而言，需要满足两种操作</p>
<ol>
<li>确定性查找，找到完全匹配的字符</li>
<li>模糊匹配，找到第一个满足匹配条件的元素（下届）</li>
</ol>
<h3 id="RADIX-STRING-SPLINE"><a href="#RADIX-STRING-SPLINE" class="headerlink" title="RADIX STRING SPLINE"></a>RADIX STRING SPLINE</h3><p>RSS是一棵树，每个节点包含三个部分：<br><img src="/../imgaes/../images/Bounding-the-Last-Mile-Efficient-Learned-String-Indexing/2.png" alt="img"></p>
<ul>
<li>bounds: 可操作的数据下标范围</li>
<li>重定向map(指针):包含并指向了一些key，这些key因为不满足当前节点的error bound，因而被分配到了其他节点</li>
<li>一个使用K个byte作为前缀，错误范围为E的RadixSpline模型</li>
</ul>
<h4 id="如何构建？"><a href="#如何构建？" class="headerlink" title="如何构建？"></a>如何构建？</h4><ol>
<li>首先，对数据集中所有字符串构建一个RadixSpline(使用前k个字节)。然后，遍历所有唯一的k字节前缀，并检查估计的位置是否在前缀的第一次出现和最后一次出现时都在规定的误差范围内。</li>
<li>对于每个测试失败的前缀，我们将其添加到重定向表中，并在有问题前缀的所有字符串中构建一个新的RSS，从字节k开始而不是0</li>
<li>这个过程递归地继续进行，直到每个key都得到满足为止。</li>
</ol>
<h4 id="如何查询"><a href="#如何查询" class="headerlink" title="如何查询"></a>如何查询</h4><p><img src="/../images/Bounding-the-Last-Mile-Efficient-Learned-String-Indexing/1.png" alt="img"><br>首先提取字符串的前k个字节，然后对重定向器进行二分查找，如果找到重定向新的RSS节点，就重新开始对下一个k字节进行操作；如果没有找到，那么就在当前节点使用适当的字符串前缀查找并返回结果。</p>
<h2 id="HASH-CORRECTOR"><a href="#HASH-CORRECTOR" class="headerlink" title="HASH CORRECTOR"></a>HASH CORRECTOR</h2><p>待更新</p>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data</title>
    <url>/2024/10/27/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/</url>
    <content><![CDATA[<blockquote>
<p>关键词：learned index，locally skewed data，multi-agent reinfocement learning</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>（1）学习索引利用机器学习模型去拟合局部区域内的数据分布具有挑战性<br>现存的工作（比如ALEX，PGM, FITing-tree采用贪心构建策略来拟合整体数据分布）无法很好地适应局部数据的偏斜分布</p>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image.png" alt="img"></p>
<p>（2）频繁插入数据而进行的重新构建或者重训练对查询延迟有显著影响</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>（1）提出了一个名为Chameleon的一维学习型索引，分为non-leaf node（使用linear model）和leaf node（使用EBH（Error Bounded Hashing） model）<br>（2）提出了一个测量local skewness的指标，提出MARL（Multi Agent Reinforcement Learning）方法用来构建索引结构和定位局部倾斜的区域<br>（3）提出一个轻量级锁（名为interval lock）和一个基于此的无锁重训练机制，</p>
<p>（1）、（2）解决了问题1，（3）解决了问题2</p>
<h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/imagecopy.png" alt="img"></p>
<h2 id="OVERVIEW-OF-CHAMELEON"><a href="#OVERVIEW-OF-CHAMELEON" class="headerlink" title="OVERVIEW OF CHAMELEON"></a>OVERVIEW OF CHAMELEON</h2><p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image2.png" alt="img"></p>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image3.png" alt="img"></p>
<h3 id="Inner-node"><a href="#Inner-node" class="headerlink" title="Inner node"></a>Inner node</h3><p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image4.png" alt="img"></p>
<h3 id="Leaf-node"><a href="#Leaf-node" class="headerlink" title="Leaf node"></a>Leaf node</h3><p>因为输入的微小变化可以导致相应的哈希值的显著变化，使得哈希函数能够分散密集数据，从而有效降低索引树的高度<br><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image5.png" alt="img"></p>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>解决局部倾斜问题的关键在于如何测量和识别这种偏斜，以及在数据更新时可能导致局部偏斜区域的变化</p>
<h3 id="提出了一个测量local-skewness的指标"><a href="#提出了一个测量local-skewness的指标" class="headerlink" title="提出了一个测量local skewness的指标"></a>提出了一个测量local skewness的指标</h3><p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image6.png" alt="img"></p>
<h3 id="提出MARL（Multi-Agent-Reinforcement-Learning）方法"><a href="#提出MARL（Multi-Agent-Reinforcement-Learning）方法" class="headerlink" title="提出MARL（Multi Agent Reinforcement Learning）方法"></a>提出MARL（Multi Agent Reinforcement Learning）方法</h3><p>提出MARL（Multi Agent Reinforcement Learning）方法用来构建索引结构和定位局部倾斜的区域</p>
<ul>
<li>首先提取数据集的分布信息（即D的PDF，|D|和D的lsn），输入DARE，输出为一个矩阵，用于确定前h-1层的分支因子，用来构建前h层的索引，最后提取第h层每个节点的数据分布信息将其输入TSMDP，输入每个节点的分支因子（可能为1）</li>
<li>当数据更新导致局部数据分布发生变化时，重训练线程会定位局部倾斜的区域并调用TSMDP来调整局部结构，而不会阻塞查询（使用interval lock）</li>
</ul>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image7.png" alt="img"></p>
<h2 id="CHAMELEON-INDEX-CONSTRUCTION"><a href="#CHAMELEON-INDEX-CONSTRUCTION" class="headerlink" title="CHAMELEON INDEX CONSTRUCTION"></a>CHAMELEON INDEX CONSTRUCTION</h2><h3 id="Resolving-local-skewness"><a href="#Resolving-local-skewness" class="headerlink" title="Resolving local skewness"></a>Resolving local skewness</h3><p>为了有效解决局部偏斜问题，我们根据定理1自适应地调整每个叶子节点 $ N_{ij}.c $ 的容量，以确保每个节点满足所需的 $ \tau $ 值。</p>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image8.png" alt="img"></p>
<h3 id="Locating-the-Locally-Skewed-Regions"><a href="#Locating-the-Locally-Skewed-Regions" class="headerlink" title="Locating the Locally Skewed Regions"></a>Locating the Locally Skewed Regions</h3><p>在索引构建过程中，每个内部节点都会影响其所有子节点。现有的基于马尔可夫决策过程（MDP）的强化学习算法侧重于顺序决策问题，无法直接应用于我们的基于树的决策过程。为了解决这一问题，我们提出了一个树结构马尔可夫决策过程（TSMDP），基于深度 Q 网络（DQN）的思想。以与节点 $ N_{ij} $ 对应的数据集特征作为输入，TSMDP 输出节点 $ N_{ij} $ 的扇出 $ N_{ij}.f $。接下来，我们定义 TSMDP 过程，并介绍训练过程。</p>
<h4 id="TSMDP公式定义"><a href="#TSMDP公式定义" class="headerlink" title="TSMDP公式定义"></a>TSMDP公式定义</h4><p>State：状态s是节点划分之前的信息，包括PDF，key的数量，lsn（其中PDF由大小为bt的桶表示）</p>
<p>Action：动作a是指分配给当前状态对应节点的fanout，动作空间是一个离散值的预定义值</p>
<p>Transition：给定s和a，如果a &#x3D; 1，则TSMDP到达一个终止状态，并构建一个叶子节点。由于基于树的索引结构的特点，当前状态s可能会导致多个下一个状态{s1，s2}</p>
<p>Reward function：评估在给定s和a下构建的索引的查询成本和内存成本<br> $ r &#x3D; -w_t \cdot R_t - w_m \cdot R_m $。其中，$ w_t $ 和 $ w_m $ 表示查询时间奖励和内存奖励的权重系数。我们用 $ R_t $ 表示遍历树和在叶节点内进行二次搜索的成本，用 $ R_m $ 表示执行动作后节点的内存使用量。根据应用需求，还可以将查询分布等其他因素加入到奖励函数中</p>
<h4 id="TSMDP训练过程"><a href="#TSMDP训练过程" class="headerlink" title="TSMDP训练过程"></a>TSMDP训练过程</h4><p>学习算法：带经验回放（experience replay）的DQN<br>智能体的经验，包括状态、动作、奖励和下一状态 $(s_t, a_t, r_t, s_{t+1})$ ，在每个时间步 $ t $ 进行存储。在每一步中，使用<em><strong>Boltzmann</strong></em> 探索策略来选择动作。我们实现了两个网络：一个为参数为 $ \theta $ 的策略网络 $ Q_T $ ，另一个为参数为 $ \theta^{-} $ 的目标网络 $ \hat{Q}_T $ ，这种设置使 TSMDP 比使用单一网络更稳定。</p>
<p>给定一批转换 $(s, a, r, s’)$ 后，通过最小化<strong>平均绝对误差</strong>（Mean Absolute Error，MAE）损失来使用梯度下降更新策略网络的参数 $ \theta $ 。具体而言，损失函数为：<br><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image9.png" alt="img"></p>
<p>其中，$ \gamma \in (0, 1) $ 表示折扣因子，决定了未来奖励的重要性，$ a’_z $ 表示由 $ s’_z $ 所采取的最优动作。$ w_z $ 是 $ s’_z $ 的权重，即 $ s’_z $ 中键数量与 $ s $ 中键数量的比值。<br>请注意，目标网络的参数 $ \theta^- $ 仅在每隔 $ K $ 个步骤（系统参数）时与策略网络的参数 $ \theta $ 同步，而在其他时间保持不变。</p>
<h4 id="只使用TSMDP的缺点"><a href="#只使用TSMDP的缺点" class="headerlink" title="只使用TSMDP的缺点"></a>只使用TSMDP的缺点</h4><p>1.索引构建时间很长，因为需要递归调用TSMDP模型为每个节点做出决策</p>
<p>2.高训练开销。在训练过程中，每个经验都包含了每个节点及其所有子节点的概率密度函数 (PDF)。逐一使用 $ Qˆ_T $ 计算子节点的 $ Qˆ_T(s’, a’) $ 的过程非常耗时。同时，离散动作空间的使用限制了我们在更大动作空间中的探索能力。</p>
<p>3.当应用需求发生变化时（例如，奖励函数优先考虑查询时间而非索引大小，或反之），TSMDP需要重新训练</p>
<h3 id="Enhancing-TSMDP-with-DARE"><a href="#Enhancing-TSMDP-with-DARE" class="headerlink" title="Enhancing TSMDP with DARE"></a>Enhancing TSMDP with DARE</h3><blockquote>
<p>为了解决限制 (1)，Chameleon 只需调用 DARE 一次来构建索引的上层 $ h $ 层，仅对下层进行局部 TSMDP 调用以进行微调。</p>
</blockquote>
<blockquote>
<p>为了解决限制（2），DARE 使用单步决策的强化学习模型，该模型具有较低的训练开销，使我们可以在一个大且连续的动作空间中探索，以找到最佳动作。</p>
</blockquote>
<blockquote>
<p>为了解决限制 (3)，我们提出了一个动态奖励函数，使其能够适应系统动态约束，而无需重新训练强化学习代理。</p>
</blockquote>
<p>具体来说，给定一个数据集 $ D $，其最大和最小键分别为 $ M_k $ 和 $ m_k $，DARE 首先提取全局数据分布特征。基于这些特征，它输出一个固定大小的参数矩阵 $ M(h - 2, L) $ 和根节点的分支因子 $ p_0 $（根节点的分支因子作为一个单独的输出参数，因为它在索引中具有唯一性）。这里，$ h $ 表示层数，矩阵 $ M $ 的每一行代表第 $ i $ 层中各个非根内节点的参数 $ p_{i,0}, p_{i,1}, …, p_{i,L-1} $</p>
<p>在获得 $ M $ 和 $ p_0 $ 后，我们首先计算节点 $ N_{ij} $ 在 $ M $ 中的位置 $ x $ 的映射，其中 $ x &#x3D; \frac{\frac{(N_{ij}.lk + N_{ij}.uk)}{2} - m_k}{M_k - m_k}{(L-1)} $。接下来，计算矩阵 $ M $ 中包含 $ x $ 的区间 $[p_{i,l}, p_{i,l+1}]$，其中 $ l &#x3D; \lfloor x \rfloor $。然后，我们采用分段线性插值函数将离散参数转换为连续值，公式为：</p>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image10.png" alt="img"></p>
<p>在构建了上层 $ h $ 级索引后，基于 DARE 构建的索引，TSMDP 精细化下层，决定是否继续分裂。在这里，索引构建完成。</p>
<p>如图 6 所示，假设 $ h &#x3D; 3 $，$ L &#x3D; 4 $，最小键 $ m_k &#x3D; 0 $ 和最大键 $ M_k &#x3D; 3 $。在步骤 (1) 中，提取数据集特征并作为 DARE 的状态。在步骤 (2) 中，DARE 输出根节点的分支因子 $ p_0 $ 和一个 $ 1 \times 4 $ 的参数矩阵 $ M $。由于 $ p_0 &#x3D; 3 $，根节点有三个子节点，其中 $ N_{10}.lk &#x3D; 0 $ 和 $ N_{10}.uk &#x3D; 1 $。因此，计算 $ x &#x3D; \frac{\frac{(0+1)}{2} - 0}{3-0}\cdot 3 &#x3D; 0.5 $，并得到 $ l &#x3D; \lfloor x \rfloor &#x3D; 0 $。最后，得到 $ N_{10}.f &#x3D; (0.5 - 0) \cdot 1.3 + (1 - 0.5) \cdot 5.1 &#x3D; 3.2 \approx 3 $。</p>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image11.png" alt="img"></p>
<h4 id="DARE公式定义"><a href="#DARE公式定义" class="headerlink" title="DARE公式定义"></a>DARE公式定义</h4><p>Experience: 由于DARE处理的是单步强化学习问题,经验仅包含state，action，reward</p>
<p>State: 我们还使用概率密度函数（PDF，表示为大小为 bD 的向量）、|D| 和局部偏斜度（lsn）来表示状态 sD。因此，状态空间的大小为 bD + 2。</p>
<p>Reward：为了适应不断变化的应用需求，我们提出了一种动态奖励函数（Dynamic Reward Function，DRF），表示为 $ r_D $ &#x3D; $\sum_{i&#x3D;1}^{n} w_i \cdot \text{cost}_i $。</p>
<p>假设一个深度Q网络（DQN）已经训练好，可以将高维状态空间和动作空间映射到低维成本空间。给定系数权重 $ w_i $（根据一些特定要求，使得 $ \sum_{i&#x3D;1}^{n} w_i &#x3D; 1 $）和不同应用特定指标的成本 $ \text{cost}_1, \text{cost}_2, \ldots, \text{cost}_n $，DRF 可以预测奖励 $ r_D $。当这些权重发生变化时，Q函数仍然有效。</p>
<p>action： 动作$ a_D $ 代表一组参数，用于确定上层 $ h - 1 $ 级节点的扇出（fanout）。根节点的更大扇出有助于提高学习索引的查询性能。大多数现有的一维学习索引的根节点扇出设置在 20 到 220 之间，例如 ALEX。因此，根节点的扇出在范围 [20, 220] 内进行搜索。对于内节点，根据现有的研究，扇出范围设置为 [20, 210]，。对于 DARE 的 $ (h - 2) \cdot L $ 参数矩阵，每行向量的大小 $ L $ 设置为 256。<br><br>为了提供稳定的动作选择策略，DARE 利用遗传算法（Genetic Algorithm，GA）作为行为者，并使用深度Q网络（DQN）作为评论者。在这种方法中，GA 将动作视为基因，将 $ Q_D(s_D, a_D) $ 作为给定状态的适应度函数。通过数值变异和交叉的方式迭代提高适应度，GA 逐渐识别出最接近最大值的动作，从而确定最优策略。算法 1 概述了使用 GA 输出最优参数的过程。</p>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image12.png" alt="img"></p>
<ul>
<li>种群。由于矩阵 $ M $ 中的值是有限的浮点值，我们可以直观地将每个值视为一个染色体。每个个体有 $ 1 + (h - 2) \cdot L $ 个染色体。</li>
<li>变异（第 3-4 行）可以分为两种类型。第一种类型是添加一组随机的扇出，以生成种群中全新的基因型。第二种类型允许 GA 更好地利用现有的高质量基因，随机选择某些染色体将其传递给后代。后者涉及在同一染色体内进行数值交叉。</li>
<li>交叉（第 5 行）也可以分为两种类型。前者是多点交叉，其中一个配置包含 $ 1 + (h - 2) \cdot L $ 个染色体，而 DARE随机选择某些染色体将其传递给后代。后者涉及在同一染色体内执行数值交叉。</li>
<li>适应度（第 6 行）。GA 算法提供根节点参数 $ p_0 $ 和其他内节点的参数矩阵 $ M $。基于这些参数，通过 Q 网络预测索引的查询成本和内存成本。随后，基于动态奖励函数（DRF）计算的预测值被用作适应度值。</li>
<li>选择（第 7-8 行）过程涉及保留一部分适应度最高的基因</li>
</ul>
<h3 id="Training-Chameleon"><a href="#Training-Chameleon" class="headerlink" title="Training Chameleon"></a>Training Chameleon</h3><p>算法 2 总结了整个 Chameleon 的训练过程。<br>首先，我们初始化 </p>
<p>TSMDP 策略网络 $ Q_T $、<br>目标网络 $ \hat{Q}_T $、 </p>
<p>DARE 策略网络 $ Q_D $、<br>探索概率 $ e_r $ 和探索终止概率（第 1-2 行）。</p>
<p>$ e_r $ 决定在选择 $ a_D $ 时探索与利用之间的倾向。我们使用大量真实和合成数据集作为训练集。随后，在每个回合中，我们从训练集中随机选择一个数据集 $ D $ 并提取其特征作为 $ s_D $（第 3-6 行）。我们随机生成 DRF 的权重 $ w $（第 7 行），并根据算法 1 获取 $ s_D $ 和 $ w $ 的最佳参数 $ a_{\text{best}} $（第 8 行）。参数 $ a_{\text{random}} $ 是随机生成的（第 9 行）。为了在探索和利用之间取得平衡，DARE 根据 $ e_r $ 选择一组参数 $ a_D $（第 10 行），其中 $ e_r $ 在训练过程中逐渐从 1 降至 0。通过 $ a_D $ 和 $ Q_T $ 实例化 Chameleon-Index（第 11-12 行）。然后，我们训练 TSMDP $ Q_T $ 和 DARE $ Q_D $（第 13-14 行）。最后，我们减少 $ e_r $ 并重复上述过程，直到达到 $ \epsilon $（第 15 行）。损失函数为：</p>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image13.png" alt="img"></p>
<p>其中 $ \theta_D $ 代表 $ Q_D $ 的参数。</p>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image14.png" alt="img"></p>
<h2 id="ONLINE-RETRAINING-FOR-UPDATE"><a href="#ONLINE-RETRAINING-FOR-UPDATE" class="headerlink" title="ONLINE RETRAINING FOR UPDATE"></a>ONLINE RETRAINING FOR UPDATE</h2><p>使用后台线程重训练索引，不阻塞查询过程</p>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image15.png" alt="img"></p>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image16.png" alt="img"></p>
<p>时间复杂度分析<br><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image17.png" alt="img"></p>
<h2 id="EXPERIMENTS"><a href="#EXPERIMENTS" class="headerlink" title="EXPERIMENTS"></a>EXPERIMENTS</h2><h3 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h3><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image18.png" alt="img"></p>
<h4 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h4><p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image19.png" alt="img"></p>
<h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image20.png" alt="img"></p>
<h4 id="基线选取"><a href="#基线选取" class="headerlink" title="基线选取"></a>基线选取</h4><p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image21.png" alt="img"></p>
<h3 id="只读工作负载下的实验结果"><a href="#只读工作负载下的实验结果" class="headerlink" title="只读工作负载下的实验结果"></a>只读工作负载下的实验结果</h3><p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image22.png" alt="img"></p>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image23.png" alt="img"></p>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image24.png" alt="img"></p>
<h3 id="混合工作负载下的实验结果"><a href="#混合工作负载下的实验结果" class="headerlink" title="混合工作负载下的实验结果"></a>混合工作负载下的实验结果</h3><p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image25.png" alt="img"></p>
<p><img src="/../images/Chameleon-Towards-Update-Efficient-Learned-Indexing-for-Locally-Skewed-Data/image26.png" alt="img"></p>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>DILI-A-Distribution-Driven-Learned-Index</title>
    <url>/2023/12/28/DILI-A-Distribution-Driven-Learned-Index/</url>
    <content><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>需要有一批数据用于批量加载构建初始数据，不支持从0开始构建（一个key一个key插入），支持读写操作。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一棵树中查找一个key，包含两部分；找到包含key的leaf node，leaf node的local search<br>查找性能取决于leaf node的深度和线性回归模型的accuracy</p>
<h2 id="方法和结果"><a href="#方法和结果" class="headerlink" title="方法和结果"></a>方法和结果</h2><p>提出一种two-phase bulk loading算法，先构建一棵BU（bottom-up）-Tree，它的node布局由greedy merging 算法（考虑了leaf node的深度和线性回归模型的accuracy）决定，接着根据BU-Tree的node布局构建DILI.<br>BU-Tree中internal node的range并不是被它的child平分<br>DILI与LIPP相比，每个leaf node的keys分布更接近线性，发生冲突的概率更低<br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/1.png" alt="img"></p>
<p>Search without Optimization<br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/2.png" alt="img"></p>
<p>Building BU-Tree<br>难点：确定nh的大小和nh - 1个breakpoints<br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/3.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/4.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/5.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/6.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/7.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/8.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/9.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/10.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/11.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/12.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/13.png" alt="img"></p>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>DILI论文重点部分</title>
    <url>/2024/04/02/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h2 id="DILI：A-Distribution-driven-Learned-Index"><a href="#DILI：A-Distribution-driven-Learned-Index" class="headerlink" title="DILI：A Distribution-driven Learned Index"></a>DILI：A Distribution-driven Learned Index</h2><p>摘要：<br><br>DILI的每个节点（internal node 和 leaf node）都有一个Linear model，并且internal node的key’s range被它的child node均分，当进行key查找时，可以准确地找到对应的leaf node。在leaf node中的linear model是可以准确预测key的位置的。</p>
<p>为了构建DILI，首先构建一颗bottom-up tree,然后使用这个bottom-up tree，自顶向下构建一个DILI树。DILI在the number of leaf nodes和tree height之间有一个很好的平衡（the number of leaf nodes 和 tree height是影响key搜索时间的关键因素）。设计了灵活的插入和删除算法，并在必要时调整树形结构。</p>
<p>实验结果表明DILI比其它baseline在不同的workloads上要表现的更好。</p>
<h3 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1.INTRODUCTION"></a>1.INTRODUCTION<br></h3><p>RMI：仅支持查找<br><br>ALEX：扩展RMI，在leaf node中使用 gapped array，使用 cost model初始化RMI结构和动态更新RMI结构。存在last-mile问题<br><br>LIPP：解决last-mile问题，但是没有利用data distribution<br><br>DILI-LO：未解决last-mile问题，利用data distribution<br><br>DILI：解决last-mile问题，利用data distribution<br></p>
<p>构建DILI的目的是实现最好的搜索性能 —&gt; 搜索的开销取决于(1)leaf node的深度(2)leaf  node中的linear model预测的accuracy —&gt; 这两个factors都应该在DILI的构建中被考虑</p>
<p>因此，提出了一个two-phase bulk loading 方法<br><br><strong>Phase1</strong> -&gt; 使用greedy merging algorithm（考虑到了上面的两个factors） 构建一棵BU-tree（BU-tree的internal node’srange并不是被它的child nodes均分的，因此在BU-tree进行key搜索时，确定child node需要额外的开销）</p>
<p><strong>Phase2</strong> -&gt;  借鉴BU-tree的结构构建DILI</p>
<h4 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h4><ul>
<li>提出DILI，algorithms 和它的cost analysis</li>
<li>构建DILI的two-phase bulk loading 方法</li>
<li>对DILI的leaf node的local optimization，解决last-mile问题</li>
<li>对于DILI的insertion和deletion操作提出相应的algorithm来维持查找性能</li>
<li>在synthetic data和real data上证实DILI的性能</li>
</ul>
<h3 id="2-OVERVIEW-OF-DILI"><a href="#2-OVERVIEW-OF-DILI" class="headerlink" title="2.OVERVIEW OF DILI"></a>2.OVERVIEW OF DILI</h3><p><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/1.png" alt="img"><br>DILI的结构如Figure 1所示<br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/2.png" alt="img"><br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/3.png" alt="img"><br>DILI在没有使用local Optimization的时候SEARCH算法如下，查找key时，锁定了leaf node后需要再进行指数查找来确定position。<br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/4.png" alt="img"></p>
<h4 id="Local-Optimization-strategy"><a href="#Local-Optimization-strategy" class="headerlink" title="Local Optimization strategy"></a>Local Optimization strategy</h4><p>在leaf node中，先用线性模型预测key的position，之后直接将key放到预测的position上，如果发生冲突，就创建一个新的node，对应的entry设置为指向新node的指针</p>
<h4 id="Updates"><a href="#Updates" class="headerlink" title="Updates"></a>Updates</h4><p>当对DILI插入数据时，如果发生conflict，会创建新的Node，当创建的新Node过多并且退化了查找性能时，需要进行调整策略（在section6会详细描述）</p>
<h3 id="3-SEARCH-COST-ANALYSIS"><a href="#3-SEARCH-COST-ANALYSIS" class="headerlink" title="3.SEARCH COST ANALYSIS"></a>3.SEARCH COST ANALYSIS</h3><p>Cost Analysis:<br>未使用local optimization strategy<br>Algorithm1由两步组成(1)找到包含search key的leaf node (2)leaf node中的local search<br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/5.png" alt="img"></p>
<h3 id="4-CONSTRUCTION-OF-DILI"><a href="#4-CONSTRUCTION-OF-DILI" class="headerlink" title="4.CONSTRUCTION OF DILI"></a>4.CONSTRUCTION OF DILI</h3><h4 id="4-1Motivation-and-Overall-Idea-of-BU-Tree"><a href="#4-1Motivation-and-Overall-Idea-of-BU-Tree" class="headerlink" title="4.1Motivation and Overall Idea of BU-Tree"></a>4.1Motivation and Overall Idea of BU-Tree</h4><p>DILI的internal node的线性模型有着完美的准确性，因为internal node被它的child nodes均分。—-&gt; 现在有一个问题，如何确定DILI的fanout</p>
<p>大致思路：<br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/6.png" alt="img"><br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/7.png" alt="img"></p>
<h4 id="4-2-Building-BU-Tree"><a href="#4-2-Building-BU-Tree" class="headerlink" title="4.2 Building BU-Tree"></a>4.2 Building BU-Tree</h4><p><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/8.png" alt="img"></p>
<h5 id="4-2-1-Bottom-up-Node-and-Model-Creation"><a href="#4-2-1-Bottom-up-Node-and-Model-Creation" class="headerlink" title="4.2.1 Bottom-up Node and Model Creation"></a>4.2.1 Bottom-up Node and Model Creation</h5><p>构建第0层的leaf node<br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/9.png" alt="img"><br>已知h - 1层的internal node,构建第h层的internal node<br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/10.png" alt="img"></p>
<h5 id="4-2-2-Determining-Node-Layout-at-A-Height"><a href="#4-2-2-Determining-Node-Layout-at-A-Height" class="headerlink" title="4.2.2 Determining Node Layout at A Height"></a>4.2.2 Determining Node Layout at A Height</h5><p><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/11.png" alt="img"><br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/12.png" alt="img"></p>
<p>但是BU-Tree是从下往上创建的，即使创建了第h层的node，我们也不知道BU-Tree的高度</p>
<p><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/13.png" alt="img"><br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/14.png" alt="img"></p>
<h4 id="4-3-BU-Tree-based-Bulk-loading-for-DILI"><a href="#4-3-BU-Tree-based-Bulk-loading-for-DILI" class="headerlink" title="4.3 BU-Tree based Bulk loading for DILI"></a>4.3 BU-Tree based Bulk loading for DILI</h4><p><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/15.png" alt="img"></p>
<h4 id="4-4-Remarks"><a href="#4-4-Remarks" class="headerlink" title="4.4 Remarks"></a>4.4 Remarks</h4><p>Skip ……</p>
<h3 id="5-LOCAL-OPTIMIZATION-OF-DILI"><a href="#5-LOCAL-OPTIMIZATION-OF-DILI" class="headerlink" title="5. LOCAL OPTIMIZATION OF DILI"></a>5. LOCAL OPTIMIZATION OF DILI</h3><p><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/16.png" alt="img"><br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/17.png" alt="img"><br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/18.png" alt="img"></p>
<h3 id="6-DATA-UPDATES-IN-DILI"><a href="#6-DATA-UPDATES-IN-DILI" class="headerlink" title="6. DATA UPDATES IN DILI"></a>6. DATA UPDATES IN DILI</h3><h4 id="6-1-Insertions"><a href="#6-1-Insertions" class="headerlink" title="6.1 Insertions"></a>6.1 Insertions</h4><p><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/19.png" alt="img"><br>P exists标注的地方错误		应设置为notExist  &lt;—  False</p>
<h4 id="6-2-Deletions"><a href="#6-2-Deletions" class="headerlink" title="6.2 Deletions"></a>6.2 Deletions</h4><p><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/20.png" alt="img"></p>
<h3 id="7-EXPERIMENTAL-STUDIES"><a href="#7-EXPERIMENTAL-STUDIES" class="headerlink" title="7.EXPERIMENTAL STUDIES"></a>7.EXPERIMENTAL STUDIES</h3><h4 id="7-1-Experimental-Settings"><a href="#7-1-Experimental-Settings" class="headerlink" title="7.1 Experimental Settings"></a>7.1 Experimental Settings</h4><p>数据集：使用了SOSD benchmark中的4个真实数据集 和 1 个合成数据集</p>
<ul>
<li>FB : 200M Facebook 用户id</li>
<li>WikiTS : 200M 维基百科网站日志条目的唯一请求时间戳</li>
<li>OSM :  800M OpenStreetMap单元格的id</li>
<li>Books : 800M Amazon的books的id</li>
<li>Logn : 200M 从重尾采样的独特值 N(0， 1) 的对数正态分布</li>
</ul>
<p>比较的baselines:<br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/21.png" alt="img"></p>
<p>Table 2 总结了所有index的属性特点，更好的表现被加粗了<br><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/22.png" alt="img"></p>
<p>Evaluation Metrics : <br><br>Lookup —&gt; 平均每次query所用的时间 <br><br>Throughtput —&gt; 平均每second执行的operations的次数（query、insertion、deletion）<br></p>
<h4 id="7-2-Overall-Query-Performance"><a href="#7-2-Overall-Query-Performance" class="headerlink" title="7.2 Overall Query Performance"></a>7.2 Overall Query Performance</h4><p><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/23.png" alt="img"></p>
<p><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/24.png" alt="img"></p>
<h4 id="7-3-Performance-on-Different-Workloads"><a href="#7-3-Performance-on-Different-Workloads" class="headerlink" title="7.3 Performance on Different Workloads"></a>7.3 Performance on Different Workloads</h4><p>(1)The Read-only workload: 100M point queries <br><br>(2)The Read-Heavy workload: 50M insertions and 100M point queries <br><br>(3)The Write-Heavy workload: 100M insertions and 50M point queries <br><br>(4)The Write-only workload: 100M insertions <br></p>
<p><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/25.png" alt="img"></p>
<h4 id="7-4-Effect-of-Many-Deletions"><a href="#7-4-Effect-of-Many-Deletions" class="headerlink" title="7.4 Effect of Many Deletions"></a>7.4 Effect of Many Deletions</h4><p>(1)Read-Heavy workload : 100M lookups and 50M deletions<br>DILI achieves up to 3.6X, 2.3X, 7.0X and 2.3X higher throughput than B+ Tree,PGM,MassTree and ALEX,respectively.</p>
<p>(2)Deletion-Heavy workload : 100M deletions and 50M lookups<br>Only ALEX performs a little better than DILI on Logn dataset</p>
<p><img src="/../images/DILI%E8%AE%BA%E6%96%87%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86/26.png" alt="img"></p>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>Dabble:基于中间层的可扩展学习索引技术</title>
    <url>/2024/09/28/Dabble-%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E5%B1%82%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E5%AD%A6%E4%B9%A0%E7%B4%A2%E5%BC%95%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>读写场景</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>提出Dabble模型<br><img src="/../images/Dabble-%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E5%B1%82%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E5%AD%A6%E4%B9%A0%E7%B4%A2%E5%BC%95%E6%8A%80%E6%9C%AF/1.png" alt="img"><br>（1）用K-Means算法把数据集进行聚类，从而划分为K个数据区域，使得每个区域内的数据分布尽可能的一致<br><br>（2）在模型训练阶段，我们对K个数据区域采用前馈神经网络进行学习，并在模型的损失函数中加入数据的访问热度，从而使模型对访问频率高的数据预测率该更加精准<br><br>（3）针对数据插入问题，借鉴LSM树中的延迟更新机制，在内存中开辟一块缓存用来存放新插入的数据，当缓存溢出时一次性将数据进行插入<br><br>（4）针对索引更新问题，提出了一种基于中间层的机制，通过模型解耦的方式缓解了索引带来的消耗</p>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p>（1）在 Lognormal 人工数据集上,Dabble 模型的查询性能比 B+树提升了 69%,比学习索引提升了 13%,比 ALEX提升了 8%;内存占用比 B+树减少了 92%,神经网络模型的内存占用比学习索引减少了 99%,<br>比 ALEX 减少了 98%.同时,Dabble 模型的插入性能比 B+树提升了 250%,比 ALEX 提升了 123%; <br><br>（2）在真实数据集 Weblogs 上,Dabble 的查询性能比 B+树提升了 49%,比学习索引提升了 33%,比 ALEX 提升了 9%;内存占用比 B+树减少了 92%,神经网络模型的内存占用比学习索引减少了 99%,比 ALEX 减少了 98%.同时,Dabble 的插入性能比 B+树提升了 400%,比 ALEX 提升了 88%. </p>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>EWALI:a Data-aware Learned Index Schema for Efficient Writes</title>
    <url>/2024/09/28/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/</url>
    <content><![CDATA[<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>(1)支持读写工作负载,在重写工作负载中性能表现很好<br><br>(2)使用轻量的light-weight data-aware data partition algorithm构建模型<br><br>(3)当data distribution发生变化，EWALI会自动分裂相关叶子节点，重训练模型<br><br>(4)并采用duel buffer（双缓冲）来处理新数据，并采用延迟更新机制合并数据，提高写入性能<br></p>
<p>问题描述：<br>（1）RMI不支持写操作，插入新数据导致data distribution变化，需要重训练所有模型<br>（2）RMI构建时采用统一的数据划分策略，没有考虑划分到同一模型中数据的相似性，导致预测不准确</p>
<h3 id="难点和分析过程："><a href="#难点和分析过程：" class="headerlink" title="难点和分析过程："></a>难点和分析过程：</h3><p>（1）现在支持写操作的方法包括就地插入（gap array，需要移动数据或产生不必要的空间开销）缓冲区插入（发生写入阻塞）<br><br>（2）现存的data-partition-algorithm<br><br>K-means算法（Dabble模型）<br><br>贪心算法（ASLM）<br><br>Piece-wise linear function（PGM-iNDEX  FITing-Tree）</p>
<p>以上不同的算法有不同的计算开销和误差</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image.png" alt="img"></p>
<h4 id="Data-partition-algorithm"><a href="#Data-partition-algorithm" class="headerlink" title="Data-partition-algorithm"></a>Data-partition-algorithm</h4><p>考虑lower model error 和 time cost 以及 memory usage选择ShrinkingCone<br><br><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image%20copy.png" alt="img"><br><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image%20copy%202.png" alt="img"></p>
<h4 id="DARMI-Design"><a href="#DARMI-Design" class="headerlink" title="DARMI Design"></a>DARMI Design</h4><h5 id="Model-Training"><a href="#Model-Training" class="headerlink" title="Model Training:"></a>Model Training:</h5><p>(1)non-leaf node<br>(2)leaf node</p>
<h5 id="Model-Retraining"><a href="#Model-Retraining" class="headerlink" title="Model Retraining:"></a>Model Retraining:</h5><p>当incremental buffer与segments合并后，改变了数据分布，后台线程被唤醒进行retraining操作</p>
<h5 id="Node-Split"><a href="#Node-Split" class="headerlink" title="Node Split:"></a>Node Split:</h5><p>当一个Node管辖的data数量超过一定数量时，会产生以下影响<br>1.过多的数据会导致重训练的时候要扫描更多的key，增加训练耗时，降低写性能<br>2.过多的数据也会让线性模型更难去拟合，精准度会下降</p>
<p>(1)horizontal split<br>Disadvantages: result in lower prediction accuracy of parent model</p>
<p>(2)Vertical split<br>Disadvantages: increase the height of DARMI, result in high lookup time<br><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image%20copy%203.png" alt="img"><br>DARMI会动态地选择两种split方式<br><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image%20copy%204.png" alt="img"><br><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image%20copy%205.png" alt="img"></p>
<h5 id="Retrain-DARMI"><a href="#Retrain-DARMI" class="headerlink" title="Retrain DARMI"></a>Retrain DARMI</h5><p>当DARMI的高度达到一个阈值，查找性能退化地过于严重了，需要对root Node进行重训练，<br>将所有的old leaf node的first key用来训练root node的线性模型，DARMI又变成two-layer</p>
<h4 id="Incremental-Buffer-Design"><a href="#Incremental-Buffer-Design" class="headerlink" title="Incremental Buffer Design"></a>Incremental Buffer Design</h4><p><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image%20copy%206.png" alt="img"></p>
<h4 id="DARMI的核心操作"><a href="#DARMI的核心操作" class="headerlink" title="DARMI的核心操作"></a>DARMI的核心操作</h4><p><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image%20copy%207.png" alt="img"></p>
<p><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image%20copy%208.png" alt="img"></p>
<p><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image%20copy%209.png" alt="img"></p>
<p><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image%20copy%2010.png" alt="img"></p>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p>数据集：<br><br>真实数据集（NYCT、OSM） 合成数据集（Lognormal）<br><br>工作负载：<br><br>（1）read-only （2）write-only （3）write-read-balance (50% read 50%write)<br><br>（4）write-heavy(95% write 5% read) （5）read-heavy(95% read 5%write)<br><br>（6）short-ranges(95% range queries 5% write)<br></p>
<p><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image%20copy%2011.png" alt="img"><br><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image%20copy%2012.png" alt="img"><br><img src="/../images/EWALI-a-Data-aware-Learned-Index-Schema-for-Efficient-Writes/image%20copy%2013.png" alt="img"></p>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>FITing-Tree-A-Data-aware-Index-Structure</title>
    <url>/2023/10/03/FiTing-Tree-A-Data-aware-Index-Structure/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol>
<li>一种新的索引结构，它使用分段线性函数紧凑地捕捉数据中的趋势，并通过此减少索引的内存大小</li>
<li>这个索引结构的核心是一个参数error(查找key的预测position和实际position之间的最大距离)</li>
<li>为了实现查找性能和空间之间的trade-off，我们提出了一种cost model在给定查找延迟需求(eg 500ns)和存储预算(eg 100MB)的情况下帮助DBA选择合适的error参数</li>
</ol>
<p>与最初的提出的技术相比，有以下优点：<br>(1)绑定最坏的查找性能<br>(2)有效地支持插入<br>(3)启动分页(所有数据不必驻留在一个连续的内存区域)</p>
<p>另一个有趣的点：<br>由于FITing-Tree的内部节点是树形结构，仍然可以应用前缀和后缀截断的技术来进一步减少索引的大小</p>
<h2 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h2><h3 id="Function-Representation"><a href="#Function-Representation" class="headerlink" title="Function Representation"></a>Function Representation</h3><p>使用分段线性函数拟合数据相比于更复杂的函数的优点<br>(分段线性函数近似的计算成本要低得多)<br>(1) 初始索引构建成本低<br>(2) 插入新的key延迟低<br><img src="/../images/FiTing-Tree-A-Data-aware-Index-Structure/1.png" alt="img"><br>分段线性函数仍然存在误差error<br><img src="/../images/FiTing-Tree-A-Data-aware-Index-Structure/2.png" alt="img"><br>通过以上公式，我们可以定义一个segment(一组排序好的数据)<br>分割过程结束后，FITing-Tree将每个segment的边界和斜率存储在叶子节点中，减少了索引的总体内存占用</p>
<h3 id="FITing-Tree-Design"><a href="#FITing-Tree-Design" class="headerlink" title="FITing-Tree Design"></a>FITing-Tree Design</h3><h4 id="Clusted-Indexes"><a href="#Clusted-Indexes" class="headerlink" title="Clusted Indexes"></a>Clusted Indexes</h4><p><img src="/../images/FiTing-Tree-A-Data-aware-Index-Structure/3.png" alt="img"></p>
<h4 id="Non-clusted-Indexes"><a href="#Non-clusted-Indexes" class="headerlink" title="Non-clusted Indexes"></a>Non-clusted Indexes</h4><p><img src="/../images/FiTing-Tree-A-Data-aware-Index-Structure/4.png" alt="img"></p>
<h2 id="SEGMENTATION"><a href="#SEGMENTATION" class="headerlink" title="SEGMENTATION"></a>SEGMENTATION</h2><h3 id="Design-Choices"><a href="#Design-Choices" class="headerlink" title="Design Choices"></a>Design Choices</h3><p>下图是我们分段算法需要实现的目标，使得分段后满足最大的error<br><img src="/../images/FiTing-Tree-A-Data-aware-Index-Structure/5.png" alt="img"><br>为了高效地构建索引和支持插入，需要一个高效地one-pass linear algorithm</p>
<h3 id="Segment-Definition"><a href="#Segment-Definition" class="headerlink" title="Segment Definition"></a>Segment Definition</h3><p>当一个segment添加一个key时，违反了这个max-error，则定义这个segment已经达到最大了</p>
<blockquote>
<p>定理:最大segment所覆盖的最小位置数为max-error + 1</p>
</blockquote>
<h3 id="Segmentation-Algorithm-思考-可以不以用一个新的分段算法-或者在这个分段算法之上对这个进行改进"><a href="#Segmentation-Algorithm-思考-可以不以用一个新的分段算法-或者在这个分段算法之上对这个进行改进" class="headerlink" title="Segmentation Algorithm (思考: 可以不以用一个新的分段算法,或者在这个分段算法之上对这个进行改进)"></a>Segmentation Algorithm (思考: 可以不以用一个新的分段算法,或者在这个分段算法之上对这个进行改进)</h3><p><img src="/../images/FiTing-Tree-A-Data-aware-Index-Structure/6.png" alt="img"><br>如图5所示，说明了圆锥体的更新方式:点1时圆锥体的原点。点2更新了高斜坡和低斜坡。点3在原锥内，但是它只更新圆锥的上界（点3的小于下界之上的误差）。点4在更新锥的外部，因此将是新段的第一个点<br><img src="/../images/FiTing-Tree-A-Data-aware-Index-Structure/7.png" alt="img"></p>
<h3 id="Algorithm-Analysis"><a href="#Algorithm-Analysis" class="headerlink" title="Algorithm Analysis"></a>Algorithm Analysis</h3><p>虽然以上收缩锥体算法的运行时间复杂度为O(n),但是它不是最优的。</p>
<h2 id="INDEX-LOOKUPS"><a href="#INDEX-LOOKUPS" class="headerlink" title="INDEX LOOKUPS"></a>INDEX LOOKUPS</h2><h3 id="Point-Queries"><a href="#Point-Queries" class="headerlink" title="Point Queries"></a>Point Queries</h3><p><img src="/../images/FiTing-Tree-A-Data-aware-Index-Structure/8.png" alt="img"></p>
<h3 id="Range-Queries"><a href="#Range-Queries" class="headerlink" title="Range Queries"></a>Range Queries</h3><h2 id="INDEX-INSERTS"><a href="#INDEX-INSERTS" class="headerlink" title="INDEX INSERTS"></a>INDEX INSERTS</h2><h3 id="In-place-Insert-Strategy"><a href="#In-place-Insert-Strategy" class="headerlink" title="In-place Insert Strategy"></a>In-place Insert Strategy</h3><p>类似于页面的填充因子，我们将指定的误差分成两个部分：分割误差e和插入预算x<br>通过为每个segment保留插入预算x，可以确保插入新元素不会违反页面的错误</p>
<p>更具体地说，给定一个段，页面的总大小为|s| + 2*x(|s|为该段中的位置数,数据被放置在新页面的中间)，在页面的开始和结束处产生x个空位置。在插入过程中如果所有的空白都被填满，那么就需要重新执行分割算法</p>
<h3 id="Delta-Insert-Algorithm"><a href="#Delta-Insert-Algorithm" class="headerlink" title="Delta Insert Algorithm"></a>Delta Insert Algorithm</h3><ul>
<li>就地插入策略的成本可能很高</li>
<li>为了减小插入时页面内数据移动的开销，每个segment包含一个额外的固定大小的缓冲区，此缓冲区保持排序，以实现有效的搜索和合并操作，一旦缓冲区达到预定的大小(buff)，它与段中的数据进行合并，再次执行分割算法</li>
<li>另外，由于为每个段添加缓冲区可能违反FITing-Tree的max-error，我们透明地将缓冲区地大小合并到分割过程地错误阐述中，即分割过程中地错误阈值为(error -buff)<br><img src="/../images/FiTing-Tree-A-Data-aware-Index-Structure/9.png" alt="img"></li>
</ul>
<h2 id="COST-MODEL"><a href="#COST-MODEL" class="headerlink" title="COST MODEL"></a>COST MODEL</h2><p>由于指定的错误阈值error会影响查找和插入的性能以及索引的大小<br>提供cost model的目的就是帮助DBA在不同的工作负载下选择合适的错误阈值error</p>
<h3 id="Latency-Guarantee"><a href="#Latency-Guarantee" class="headerlink" title="Latency Guarantee"></a>Latency Guarantee</h3><p>查找延迟保证</p>
<p>由于查找需要找到相关的segment,然后搜索segment(数据+缓冲区)，并且error的值会影响创建的段的数量(即更小的error会产生更多的段),我们使用一个函数，它返回为给定数据集创建的segment数量和error值。我们使用Se来表示指定数据集在给定错误阈值e下生成的segment的数量。</p>
<p>error值为e的总估计查找延迟可以用以下表达式来建模,其中b是tree的fanout,buff是segment的最大buffer大小<br><img src="/../images/FiTing-Tree-A-Data-aware-Index-Structure/10.png" alt="img"></p>
<p>满足给定延迟要求并且存储占用最小的索引由以下表达式给出,其中E表示一组可能的错误值<br><img src="/../images/FiTing-Tree-A-Data-aware-Index-Structure/11.png" alt="img"></p>
<h3 id="Space-Budget"><a href="#Space-Budget" class="headerlink" title="Space Budget"></a>Space Budget</h3><p>空间预算<br>可以用以下函数来估计给定的错误阈值e下的只读聚类索引的大小(byte)<br><img src="/../images/FiTing-Tree-A-Data-aware-Index-Structure/12.png" alt="img"><br>因此满足给定存储预算的最小误差阈值由以下表达式给出<br><img src="/../images/FiTing-Tree-A-Data-aware-Index-Structure/13.png" alt="img"></p>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>GRE使用手册</title>
    <url>/2024/03/04/GRE%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="下载官网地址"><a href="#下载官网地址" class="headerlink" title="下载官网地址:"></a>下载官网地址:<br></h2><p><a href="https://github.com/jingtao8a/GRE">https://github.com/jingtao8a/GRE</a></p>
<h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><p>Ubuntu 20.04.6 LTS<br><br>gcc 9.4.0<br><br>cmake 3.16.3</p>
<h2 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h2><h3 id="intel-mkl-2018-4-274"><a href="#intel-mkl-2018-4-274" class="headerlink" title="intel-mkl 2018.4.274"></a>intel-mkl 2018.4.274<br></h3><p>这里安装2024的版本也可以<br><br>进入官网 <a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl-download.html">https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl-download.html</a><br></p>
<p>选择Linux 和 APT Package Manager<br><img src="/../images/GRE%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/3.png" alt="img"><br>依次输入命令<br><img src="/../images/GRE%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/1.png" alt="img"><br><img src="/../images/GRE%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/2.png" alt="img"></p>
<p>默认安装路径如下：<br><img src="/../images/GRE%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/4.png" alt="img"></p>
<p>使用mkl库需要配置环境变量：<br></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">对所有用户生效，需要重启系统</span><br><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
<p><img src="/../images/GRE%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/5.png" alt="img"></p>
<h3 id="intel-tbb-2020-3"><a href="#intel-tbb-2020-3" class="headerlink" title="intel-tbb 2020.3"></a>intel-tbb 2020.3<br></h3><p>tbb库的版本必须使用2020.3<br><br>下载地址<a href="https://github.com/oneapi-src/oneTBB/releases/tag/2020_U3">https://github.com/oneapi-src/oneTBB/releases/tag/2020_U3</a></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf oneTBB-2020_U3.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为要使用 gcc-9 进行编译，所以需要编辑成 gcc-9 形式</span></span><br><span class="line">cp build/linux.gcc.inc build/linux.gcc-9.inc </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 linux.gcc-9.inc 文件：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第15、16行原来是</span></span><br><span class="line">CPLUS ?= g++</span><br><span class="line">CONLY ?= gcc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改为</span></span><br><span class="line">CPLUS ?= g++-9</span><br><span class="line">CONLY ?= gcc-9</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后在文件夹 oneTBB-2020_U3/ 中编译</span></span><br><span class="line">cd oneTBB-2020_U3</span><br><span class="line">make compiler=gcc-9 stdver=c++17 tbb_build_prefix=my_tbb_build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译完成后，在 builld/ 文件夹下会看到编译生成的文件夹 my_tbb_build_release/</span></span><br></pre></td></tr></table></figure>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /usr/local/tbb-2020_U3</span><br><span class="line"></span><br><span class="line">sudo cp -r oneTBB-2020_U3/include /usr/local/tbb-2020_U3/include</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建立新安装tbb版本的符号链接</span></span><br><span class="line">sudo ln -s /usr/local/tbb-2020_U3/include/tbb /usr/local/include/tbb</span><br><span class="line"></span><br><span class="line">sudo cp -r oneTBB-2020_U3/build/my_tbb_build_release /usr/local/tbb-2020_U3/lib</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建立新安装tbb版本的符号链接</span></span><br><span class="line">sudo ln -s /usr/local/tbb-2020_U3/lib/libtbb.so.2 /usr/local/lib/libtbb.so</span><br><span class="line">sudo ln -s /usr/local/tbb-2020_U3/lib/libtbb.so.2 /usr/local/lib/libtbb.so2</span><br><span class="line">sudo ln -s /usr/local/tbb-2020_U3/lib/libtbbmalloc.so.2 /usr/local/lib/libtbbmalloc.so</span><br><span class="line">sudo ln -s /usr/local/tbb-2020_U3/lib/libtbbmalloc.so.2 /usr/local/lib/libtbbmalloc.so2</span><br><span class="line">sudo ln -s /usr/local/tbb-2020_U3/lib/libtbbmalloc_proxy.so.2 /usr/local/lib/libtbbmalloc_proxy.so</span><br><span class="line">sudo ln -s /usr/local/tbb-2020_U3/lib/libtbbmalloc_proxy.so.2 /usr/local/lib/libtbbmalloc_proxy.so2</span><br></pre></td></tr></table></figure>

<p>然后把 库文件的路径写入到 ~&#x2F;.bashrc：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;export LD_LIBRARY_PATH=/usr/local/tbb-2020_U3/lib:$LD_LIBRARY_PATH&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>参考链接: <a href="https://blog.csdn.net/qq_39779233/article/details/126284595">https://blog.csdn.net/qq_39779233&#x2F;article&#x2F;details&#x2F;126284595</a></p>
<h3 id="jemalloc"><a href="#jemalloc" class="headerlink" title="jemalloc"></a>jemalloc</h3><p>下载地址: <a href="https://github.com/jemalloc/jemalloc/releases">https://github.com/jemalloc/jemalloc/releases</a></p>
<h4 id="编译与安装"><a href="#编译与安装" class="headerlink" title="编译与安装"></a>编译与安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">step 1</span></span><br><span class="line">./autogen.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">step 2</span></span><br><span class="line">make</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">step 3</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>参考链接: <a href="https://blog.csdn.net/SweeNeil/article/details/94648313">https://blog.csdn.net/SweeNeil/article/details/94648313</a></p>
<h2 id="USAGE"><a href="#USAGE" class="headerlink" title="USAGE"></a>USAGE</h2><h3 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule update --init # only for the first time</span><br><span class="line">mkdir -p build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; make</span><br></pre></td></tr></table></figure>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./build/microbench \</span><br><span class="line">--keys_file=./data/dataset \  // 数据地址</span><br><span class="line">--keys_file_type=&#123;binary,text&#125; \  // 二进制 或者 文本</span><br><span class="line">--read=0.5 --insert=0.5 \ </span><br><span class="line">--operations_num=800000000 \ </span><br><span class="line">--table_size=-1 \ // 所使用的数据的size</span><br><span class="line">--init_table_ratio=0.5 \ //bulk_load所使用的数据的百分比</span><br><span class="line">--thread_num=24 \</span><br><span class="line">--index=index_name \ //测试的索引名称</span><br></pre></td></tr></table></figure>

<p>其它参数见官网:<br><a href="https://github.com/jingtao8a/GRE">https://github.com/jingtao8a/GRE</a></p>
<h3 id="如果要测试新的索引结构"><a href="#如果要测试新的索引结构" class="headerlink" title="如果要测试新的索引结构"></a>如果要测试新的索引结构</h3><h4 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h4><p>src&#x2F;competitor&#x2F;competitor.h<br>get_index函数中添加对应的index_type<br><img src="/../images/GRE%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/6.png" alt="img"></p>
<h4 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h4><p>在 src&#x2F;competitor 下放置源代码 new_index_name&#x2F;src<br>编写接口文件 src&#x2F;competitor&#x2F;new_index_name.h</p>
<p>以lipp的接口文件为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;./src/src/core/lipp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;../indexInterface.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title class_">PAYLOAD_TYPE</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LIPPInterface</span> : <span class="keyword">public</span> indexInterface&lt;KEY_TYPE, PAYLOAD_TYPE&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(Param *param = <span class="literal">nullptr</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bulk_load</span><span class="params">(std::pair &lt;KEY_TYPE, PAYLOAD_TYPE&gt; *key_value, <span class="type">size_t</span> num, Param *param = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(KEY_TYPE key, PAYLOAD_TYPE &amp;val, Param *param = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">put</span><span class="params">(KEY_TYPE key, PAYLOAD_TYPE value, Param *param = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">update</span><span class="params">(KEY_TYPE key, PAYLOAD_TYPE value, Param *param = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(KEY_TYPE key, Param *param = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">scan</span><span class="params">(KEY_TYPE key_low_bound, <span class="type">size_t</span> key_num, std::pair &lt;KEY_TYPE, PAYLOAD_TYPE&gt; *result,</span></span></span><br><span class="line"><span class="params"><span class="function">                Param *param = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">memory_consumption</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> lipp.<span class="built_in">total_size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LIPP &lt;KEY_TYPE, PAYLOAD_TYPE&gt; lipp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title class_">PAYLOAD_TYPE</span>&gt;</span><br><span class="line"><span class="type">void</span> LIPPInterface&lt;KEY_TYPE, PAYLOAD_TYPE&gt;::<span class="built_in">bulk_load</span>(std::pair &lt;KEY_TYPE, PAYLOAD_TYPE&gt; *key_value, <span class="type">size_t</span> num,</span><br><span class="line">                                                      Param *param) &#123;</span><br><span class="line">    lipp.<span class="built_in">bulk_load</span>(key_value, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title class_">PAYLOAD_TYPE</span>&gt;</span><br><span class="line"><span class="type">bool</span> LIPPInterface&lt;KEY_TYPE, PAYLOAD_TYPE&gt;::<span class="built_in">get</span>(KEY_TYPE key, PAYLOAD_TYPE &amp;val, Param *param) &#123;</span><br><span class="line">    <span class="type">bool</span> exist;</span><br><span class="line">    val = lipp.<span class="built_in">at</span>(key, <span class="literal">false</span>, exist);</span><br><span class="line">    <span class="keyword">return</span> exist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title class_">PAYLOAD_TYPE</span>&gt;</span><br><span class="line"><span class="type">bool</span> LIPPInterface&lt;KEY_TYPE, PAYLOAD_TYPE&gt;::<span class="built_in">put</span>(KEY_TYPE key, PAYLOAD_TYPE value, Param *param) &#123;</span><br><span class="line">    <span class="keyword">return</span> lipp.<span class="built_in">insert</span>(key, value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title class_">PAYLOAD_TYPE</span>&gt;</span><br><span class="line"><span class="type">bool</span> LIPPInterface&lt;KEY_TYPE, PAYLOAD_TYPE&gt;::<span class="built_in">update</span>(KEY_TYPE key, PAYLOAD_TYPE value, Param *param) &#123;</span><br><span class="line">    <span class="keyword">return</span> lipp.<span class="built_in">update</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title class_">PAYLOAD_TYPE</span>&gt;</span><br><span class="line"><span class="type">bool</span> LIPPInterface&lt;KEY_TYPE, PAYLOAD_TYPE&gt;::<span class="built_in">remove</span>(KEY_TYPE key, Param *param) &#123;</span><br><span class="line">    <span class="keyword">return</span> lipp.<span class="built_in">remove</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">KEY_TYPE</span>, <span class="keyword">class</span> <span class="title class_">PAYLOAD_TYPE</span>&gt;</span><br><span class="line"><span class="type">size_t</span> LIPPInterface&lt;KEY_TYPE, PAYLOAD_TYPE&gt;::<span class="built_in">scan</span>(KEY_TYPE key_low_bound, <span class="type">size_t</span> key_num,</span><br><span class="line">                                                   std::pair &lt;KEY_TYPE, PAYLOAD_TYPE&gt; *result,</span><br><span class="line">                                                   Param *param) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">        result = <span class="keyword">new</span> std::pair &lt;KEY_TYPE, PAYLOAD_TYPE&gt;[key_num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lipp.<span class="built_in">range_query_len</span>(result, key_low_bound, key_num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>Hist-Tree: Those Who Ignore It Are Doomed to Learn </title>
    <url>/2024/10/03/Hist-Tree-Those-Who-Ignore-It-Are-Doomed-to-Learn/</url>
    <content><![CDATA[<h2 id="背景和应用场景："><a href="#背景和应用场景：" class="headerlink" title="背景和应用场景："></a>背景和应用场景：</h2><p>在之前的研究中，学习型索引的性能超过过了传统索引，这被归功于是利用数据分布这一特性。但是这篇文章认为，在比较试验中之学习型索引之所以能表现良好，是因为利用了一些隐含条件（例如，bulk-loading时，数据是排序的,数据的范围[min,max],…，））本文提出了一个传统索引结构（Hist-tree），利用了这些隐藏条件，并在只读工作负载的比较实验中，比RMI，PGM-index，RadixSpline的性能要好</p>
<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>学习索引做了一些隐含假设，例如<br><br>（1）假设bulk-loading数据已经排序<br><br>（2）数据的范围[min, max]<br><br>（3）数据是不被修改的<br><br>但是传统数据结构例如B-tree并没有这样的假设，这样会让B-tree的构建时间变得更长，或者导致B-tree和学习型索引进行比较实验时，处于劣势<br></p>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>提出Hist-tree（利用了隐含假设（1）（2））<br><br>以及压缩版本Compact-Hist-tree（利用了隐含假设（1）（2）（3））<br></p>
<p><img src="/../images/Hist-Tree-Those-Who-Ignore-It-Are-Doomed-to-Learn/image.png" alt="img"><br>图中的Hist-tree是从一个数据集中选取200个key构建的，数据集的数据分布如（a）所示，（b）（c）为Hist-tree和Compact Hist-tree<br></p>
<h4 id="（b）Hist-tree"><a href="#（b）Hist-tree" class="headerlink" title="（b）Hist-tree"></a>（b）Hist-tree<br></h4><p>每一个node根据histogram分成多个bin，terminal bin是灰色的，non-terminal bin是白色的，每个bin的值为该子树所包含的key的数量<br><br>查找过程为先锁定一个terminal-bin（有threshold），之后进行二分查找</p>
<h4 id="（c）-Compact-Hist-tree"><a href="#（c）-Compact-Hist-tree" class="headerlink" title="（c） Compact Hist-tree"></a>（c） Compact Hist-tree</h4><p>每一行代表一个node，每个node根据histogram分为多个binterminal bin是灰色的，non-terminal bin是白色的，白色的bin存储的值为child node的offset，灰色的bin存储累计直到该bin的所有key的数量</p>
<h3 id="physical-layout"><a href="#physical-layout" class="headerlink" title="physical layout"></a>physical layout</h3><p>Hist-tree的物理结构为两个32位整形数组，第一个数组包含的inner node（含有child node的node 或者说是 至少包含一个non-terminal bin的node），第二个数组包含leaf node（只有terminal bin的node）<br>例如：（b）中的root node要存储在第一个数组中占八个元素，其中由四个histogram bin计数组成，后跟四个child pointers(如果该pointer对应的bin为terminal bin或者指向leaf node，将高位flag标记为1)，并且第一个和第四个child pointer的高位flag标记为1</p>
<p><img src="/../images/Hist-Tree-Those-Who-Ignore-It-Are-Doomed-to-Learn/image%20copy.png" alt="img"><br><img src="/../images/Hist-Tree-Those-Who-Ignore-It-Are-Doomed-to-Learn/image%20copy%202.png" alt="img"></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果:"></a>结果:</h2><p><img src="/../images/Hist-Tree-Those-Who-Ignore-It-Are-Doomed-to-Learn/image%20copy%203.png" alt="img"><br><img src="/../images/Hist-Tree-Those-Who-Ignore-It-Are-Doomed-to-Learn/image%20copy%204.png" alt="img"></p>
<p>个人实现版本：<a href="https://github.com/jingtao8a/Hist">https://github.com/jingtao8a/Hist</a></p>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>NFL-Robust-Learned-Index-via-Distribution-Transformation</title>
    <url>/2023/12/05/NFL-Robust-Learned-Index-via-Distribution-Transformation/</url>
    <content><![CDATA[<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>只读负载</li>
<li>读写负载，但是数据分布变化不大（即CDF随着key的插入删除变化较小）</li>
</ul>
<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>之前的学习索引通过设计更好的启发式方法来划分key空间，使得每一份被分割的sub key空间可以更好地被线性模型拟合。<br>缺点：</p>
<ul>
<li>为了达到这个目的，学习索引必须构建更深的层次结构，从而产生更多的遍历时间和预测数量<br>（类似于用一个分段线性函数去拟合数据分布CDF）。</li>
</ul>
<h2 id="难点和分析过程："><a href="#难点和分析过程：" class="headerlink" title="难点和分析过程："></a>难点和分析过程：</h2><p>本文提出了学习索引NFL（包括两个结构Normalizing Flow 和 Learned Index ）</p>
<p><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/1.jpg" alt="img"><br>思想： 先用分布转换模型将复杂key分布转换为近似均匀的分布，然后利用转换的key构建学习索引</p>
<p><strong>难点</strong></p>
<p>（1）Efficacy of Normalizing flow:</p>
<ul>
<li>由于key的数字数据特征有限，分布转换模型表现不佳</li>
<li>均匀分布很难作为训练目标（我们设计了一个具有丰富特征空间的分布转换模型和一个易于操作的训练目标）</li>
</ul>
<p>（2）Efficiency of normalizing flow</p>
<ul>
<li>分布转化必须是高效的在线步骤，这样就限制了NF的复杂性。但是直接减少参数数量标准化流程可能会降低转换质量（这样会导致学习索引需要更深的层次结构和更多的模型来近似CDF），（我们设计了一套效率优化方案，并且保证NF的功效）</li>
</ul>
<p>（3）Lack of proper indexes for transformed keys：</p>
<ul>
<li>numerica NF的转换使线性模型拟合地更好，学习索引应该以新的视角重新思考。（我们提出了After-Flow Learned Index（AFLI），充分利用转换后的key）</li>
</ul>
<p><strong>方法</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/1.jpg" alt="img"><br>以下两个是评价模型转换质量的指标<br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/2.jpg" alt="img"></p>
<p>Tail conflict degree：</p>
<p>Numerical Normalizing Flow:<br>Feature Space Expansion:现有的NF大多用在cv和nlp领域，用于处理高纬的图片和文本，这些数据都有丰富的特征。然而keys都是数值数据，含有的特征较少。<br>使用Algorithm 3.1分布转换算法（对keys的数值特征进行扩展）<br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/3.jpg" alt="img"></p>
<p>特征扩展的时间复杂度为O（n x d）</p>
<p><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/4.png" alt="img"></p>
<p>Structure of AFLI：<br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/5.jpg" alt="img"></p>
<p><strong>Model node:</strong><br>Empty Slot：unused slot<br>Data Slot：key payload<br>Bucket Pointer: 指向一个bucket<br>Node Pointer：指向一个model node或者dense node<br><strong>Bucket:</strong><br>a short data array.它的size由tail conflict degree决定，但将保持在预设阈值范围内。我们提供两种桶，线性桶（默认）和有序桶</p>
<p><strong>Dense node：</strong><br>Also a data array，比bucket大一点，但是比Model node小很多，是一个ordered and gapped array, gap的最大值由tail conflict degree</p>
<p><strong>Analysis:</strong><br>当索引无法建立模型节点时，因为节点中的所有键都太近（即拟合线性模型的斜率为0），索引会分配一个dense array</p>
<p><strong>Queries:</strong><br>（1）从root node开始查找，如果是model node，先用linear model预测position，判断它的类型，如果是empty slot，表示不存在；如果是data slot，比较是否是相同的key；如果是bucket pointer，在bucket中查找；如果是node pointer，递归操作<br>（2）如果node是dense node，使用二分查找查找这个结果。</p>
<p><strong>Insertions:</strong><br>（1）如果key-payload pair被插入model node，先用linear model预测position</p>
<ul>
<li>如果是empty slot，直接存储key-payload</li>
<li>如果是data slot，表明发生冲突，创建一个bucket来存储这两个key</li>
<li>如果是bucket pointer或者node pointer，插入key-payload到bucket或者child node中<br>（2）插入到bucket中时，将key-payload会直接被加到sorted data的末尾；如果bucket是一个ordered mode，将会执行一次插入排序。<br>（3）插入到dense node中时，先在array上执行二分查找，如果那个position是一个empty slot，我们会直接插入key-payload pair；，否则会移动到最近的empty slot再插入。</li>
</ul>
<p>如果bucket或者dense node没有empty slots，我们尽量通过一个modeling operation将它转换为model node<br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/6.jpg" alt="img"></p>
<p><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/7.jpg" alt="img"><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/8.jpg" alt="img"></p>
<p>我们首先一个使用线性回归创建线性模型（Line 1）<br>如果slope 为0（所有key被映射到一个相同的position），我们为创建一个dense node（Line 2 - 4）<br>否则如果我们成功创建一个linear model，就计算model node所有位置的conflict degree（Line 6）<br>然后我们遍历所有预测的位置，决定每个pos的entry type。如果conflict degree为1，我们直接在data slot存储该key；如果conflict degree大于1但是比bucket的tail confict degree小，存储在一个bucket中（Line 14 - 17）；<br>否则，如果某个position的confict degree比bucket的tail conflict degree大，找到下一个conflict degree也大于tail conflict degree的position或者到末尾，并将经过的position的key都收集起来，并分配一个新的节点来处理它们（第18 - 21行）<br>BulkLoad：首先计算tail conflict degree. The returned result is the root node.<br>Update: lookup + in-place update<br>Delete</p>
<h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><p><strong>数据集：</strong><br>选取了7个不同的数据集进行评估<br>（Key的类型为double     payload的类型是int64）</p>
<p>对每种类型的数据集构建了四种类型的工作负载</p>
<p>每种工作负载包括 批量加载和运行阶段<br>我们使用批量加载操作来加载数据集的50%的key；在运行阶段，根据不同的操作比率生成请求</p>
<ul>
<li>只读</li>
<li>读80% 写20%</li>
<li>写 20% 读80%</li>
<li>只写</li>
</ul>
<p>将NFL与LIPP、ALEX、PGM-index、B-Tree、an efficient B-Tree对比</p>
<p><strong>平均吞吐量</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/9.jpg" alt="img"></p>
<ul>
<li>只读：NFL与LIPP、ALEX、PGM、B-Tree相比，平均吞吐量分别提高了2.34倍、2.46倍、3.82倍、7.45倍；对于具有大冲突程度的工作负载（即LLT和FB），可以分别实现比LIPP、ALEX高2.41x和3.70x的吞吐量。</li>
<li>重读：与LIPP、ALEX、PGM、B-Tree相比，NFL在吞吐量上分别提高72.22%、101.05%、611.48%、389.45%</li>
<li>重写：与LIPP、ALEX、PGM、B-Tree相比，NFL在吞吐量上分别提高29.10%、39.28%、50.88%、162.92%</li>
<li>只写：与LIPP、ALEX、B-Tree相比，NFL在吞吐量上分别提高22.65%、28.30%和131.58%</li>
</ul>
<p><strong>延迟</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/10.jpg" alt="img"></p>
<ul>
<li>只读：与LIPP、ALEX、PGM index、B-Tree相比，NFL可以将延迟分别降低58.68%、32.89%、62.73%和80.77%</li>
<li>读写：与LIPP、ALEX、PGM index和B-Tree相比，NFL可以将延迟分别降低26.64%、45.05%、59.49%、65.31%</li>
<li>只写：与LIPP、ALEX、B-Tree相比，NFL可以将延迟减少2.26%、27.92%、50.48%</li>
</ul>
<p><strong>批量加载时间</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/11.jpg" alt="img"></p>
<p>与LIPP、ALEX、B-Tree相比，NFL需要2.25倍、0.86倍、2.81倍的大容量加载时间，其中77%的时间是用来转换key的</p>
<p><strong>索引大小：</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/12.jpg" alt="img"><br>NFL的指数大小分别是ALEX和PGM的2.26倍和3.1倍；然而，NFL的大小仅为LIPP大小的0.51</p>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>RadixSpline-A-Single-Pass-Learned-Index</title>
    <url>/2023/10/03/RadixSpline-A-Single-Pass-Learned-Index/</url>
    <content><![CDATA[<h2 id="RadixSpline"><a href="#RadixSpline" class="headerlink" title="RadixSpline"></a>RadixSpline</h2><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><blockquote>
<ol>
<li>a set of spline points</li>
<li>a radix table</li>
</ol>
</blockquote>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><blockquote>
<ol>
<li>Build Spline<blockquote>
<p>首先建立一个Spline Model S<br>S(ki) &#x3D; pi +&#x2F;- e<br>(ki, pi)为要查找的key和真实的position e为error<br>模型的计算如下，其中(kleft,pleft)和(kright, pright)为两个spline point<br><img src="/../images/RadixSpline-A-Single-Pass-Learned-Index/1.png" alt="img"></p>
</blockquote>
</li>
</ol>
</blockquote>
<blockquote>
<p>2.Build Radix Tablle</p>
<blockquote>
<p><strong>作用：</strong> 用于所定查找key的附近的两个spline point<br><img src="/../images/RadixSpline-A-Single-Pass-Learned-Index/2.png" alt="img"><br><strong>过程：</strong> 确定使用的key的prefix的长度r，分配2^r长度的数组，遍历所有的spline points，碰到新的prefix，就插入该数组 </p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models</title>
    <url>/2023/12/05/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/</url>
    <content><![CDATA[<p>SALI: A Scalable Adaptive Learned Index Framework based on<br>Probability Models<br>一个基于概率模型的可进化学习索引框架</p>
<h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>LI：只读<br>可写：<br>1.基于缓冲区的策略（插入时放入缓冲区，到达一个阈值后进行合并操作）<br>XIndex、FINEdex<br>2.基于模型的策略（就地插入）<br>ALEX（在插入冲突中，映射的slot已经被占用，通过移动来尝试重新组织节点）、<br>LIPP（利用链接方案，为相应的时隙创建一个新节点，将最后一英里问题转化为子树遍历问题）</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/1.png" alt="img"><br>上述的索引结构都不能以高并发性进行扩展</p>
<p>并发数较少的时候，与基于模型的策略（ALEX+、LIPP+）相比，基于缓冲区策略（XIndex、FINEdex）的索引表现出较差的基本性能和较差的扩展性；并且随着并发数的提高，“最后一英里问题”搜索会迅速饱和内存带宽，从而成为系统的瓶颈（ALEX+必须为此操作获取粗粒度写锁，线程数量增加时，越来越多的线程被阻塞）</p>
<p>LIPP+没有最后一英里问题，但是它需要在每个节点中维护统计信息，如访问计数和冲突计数（以触发节点再训练，防止性能下降）。这些节点计数器在线程之间造成高争用。</p>
<h2 id="难点与分析过程"><a href="#难点与分析过程" class="headerlink" title="难点与分析过程"></a>难点与分析过程</h2><p>我们需要设计一个满足如下要求的可扩展学习索引<br>1.Efficient Concurrency高效并发：<br>为了实现高效的插入性能，索引必须跟踪统计信息，这些信息反映了由于新的插入而导致的索引结构随时间的退化（这些信息对于触发节点再训练至关重要），但是节点计数器在线程之间会造成高争用，需要一种轻量级方法<br>2.Adaptive ability适应能力<br>与均匀工作负载相比，学习索引在倾斜插入工作负载下表现出次优性能。因此，学习索引需要有自适应能力以保证其在并发场景的鲁棒性。此外，学习的索引缺乏用于查找操作的优化策略。在偏斜的工作负载下，学习索引尚未充分利用显著降低索引空间成本的机会。</p>
<p>3.Low overheads of basic performance基本性能的低开销<br>(1)Efficient lookup<br>实现高查找性能，通常取决于最大限度地减少查找的预测错误<br>(2)Efficient insert<br>采用基于模型的策略，而不是基于缓冲区的策略，通过在每个节点中保留间隙，可以显著提高学习索引的插入性能</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>提出SALI<br>1.利用LIPP+结构（使用细粒度锁）<br>2.除了模型重训练以外定义一组节点进化策略，以允许学习到的索引自适应于不同的工作负载倾斜（建议对具有不同读写热度的节点应用不同的进化策略）<br>3.用轻量级概率模型取代了现有学习索引中的每个节点的统计信息，以消除统计信息维护的可扩展性瓶颈</p>
<p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/2.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/3.png" alt="img"></p>
<p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/4.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/5.png" alt="img"></p>
<p>进化策略：<br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/6.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/7.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/8.png" alt="img"></p>
<p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/9.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/10.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/11.png" alt="img"></p>
<p>概率模型：<br>为了确保最佳性能，学习索引必须监控退化统计信息，以便在必要时启动调整；另外，进化策略需要额外的统计信息。<br>基本概念：模拟信息积累时利用概率</p>
<p>例子：<br>1.当模拟指定时间段内插入key的累积数量时，我们设计一个基于插入率和插入时间的概率模型<br>2.几何分布可以用来模拟信息的累计（插入冲突等）</p>
<p>触发insert evolution的条件</p>
<p>Condition1：评估一个节点及其子树中新key插入的频率<br>该节点容纳足够数量的新插入的key<br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/12.png" alt="img"></p>
<p>n.current_num:是指在当前插入操作结束时节点中包含的key的数量<br>n.build_num:是指上一次执行完进化策略后节点中的key的数量<br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/13.png" alt="img"></p>
<p>Condition2：节点内冲突的升级（判断节点是否恶化）<br>Node必须由足够的新插入的key<br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/14.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/15.png" alt="img"></p>
<p><strong>先计算Pconflict是否被触发，如果触发，再判断Pacc是否被触发，如果两个条件都被触发，执行进化策略</strong></p>
<p>触发lookup evolution的条件<br>Phl<br>还需要考虑以下两个条件<br>Condition1:<br>再很长的一段时间内，节点上的查找操作没有触发进化策略</p>
<p>Condition2:<br>节点累计数据的速率并不慢</p>
<p>For condition1：如果一个节点的最后一次进化操作是由hot lookup触发的，这意味着自那以后没有插入操作触发该节点进化，即该节点没有严重恶化，并且新插入key的数量可能很少，可以将Phl调整到一个更小的值</p>
<p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/16.png" alt="img"></p>
<p>For condition2：引入Pacc，如果自上次进化操作以来插入了大量新的key，则表明可能需要进行新一轮的进化操作</p>
<p>每个线程维护一个skip_counter，每次查找操作，skip_counter加1，10次查找操作后，执行一次伯努利实验来判断Phl是否被触发。如果Phl被触发，判断Pacc是否也被触发，如果触发，执行进化策略。</p>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>The-PGM-index-a-fully-dynamic-compressed-learned-index-with-provable-worst-case-bounds</title>
    <url>/2023/10/05/The-PGM-index-a-fully-dynamic-compressed-learned-index-with-provable-worst-case-bounds/</url>
    <content><![CDATA[<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>PGM &#x3D;&#x3D; PieceWise Geometric Model 分段几何模型<br>关键词：dynamic(表示PGM-index除了支持查询还支持插入和删除)、compressed(表示还对模型进行了压缩，达到更好的空间效率)</p>
<p>本文的注意力集中在解决所谓的全动态可索引字典问题。这个问题要求存储多重集S，以便有效支持以下查询和更新操作</p>
<ol>
<li>member (x) &#x3D; true if x ∈ S, false otherwise;</li>
<li>lookup(x) returns the satellite data of x ∈ S (if any), nil otherwise;</li>
<li>predecessor (x) &#x3D; max{y ∈ S | y &lt; x};</li>
<li>range(x, y) &#x3D; S ∩ [x, y];</li>
<li>insert(x) adds x to S, i.e. S ← S ∪ {x};</li>
<li>delete(x) removes x from S, i.e. S ← S \ {x}.</li>
</ol>
<ul>
<li>member(x)，判断关键字x是否属于多重集S</li>
<li>lookup(x)，给定一个key，若该key已被插入，则返回其value</li>
<li>predecessor(x)，翻译软件叫“前任”，返回所有小于x的数据中最大的那个，其实可以简单理解为排好序的数组中，x的前一个数据</li>
<li>range(x, y)，范围查询，给出[x, y]关键字x和y之间的所有对应的value</li>
<li>insert和delete很好理解，插入和删除对应的（K, V）</li>
</ul>
<p>本文将 member,lookup,predecessor称为点查询，range称为范围查询<br>对于点查询和范围查询只要实现rank(x)<br>member(x) &lt;–&gt; A[rank(x)] &#x3D;&#x3D; x<br>predecessor(x) &lt;–&gt;A[rank(x) - 1]<br>range(x, y) &lt;–&gt; 从rank(x)对应的A数组的位置开始向后查找直到key大于y为止</p>
<p>现存的解决上述问题的经典索引数据结构：（1）哈希索引（2）B树（3）位图索引（4）字典树trie索引<br>哈希索引不支持predecesor和range，位图索引维护成本过高，字典树空间消耗过大，主流数据库还是使用B树及其变种作为存储引擎</p>
<p>本文提出的PGM-Index不像RMI和FITing-Tree那样混合了传统的索引和学习型索引。(RMI的最后一个stage中的模型若error超过阈值，则将模型替换为B+树，FITing-Tree在确定segment时也是查找B+树)</p>
<h2 id="PGM-Index"><a href="#PGM-Index" class="headerlink" title="PGM-Index"></a>PGM-Index</h2><p>两个关键点：</p>
<blockquote>
<p>1.PLA-Model(Piecewise Linear Approximation model, 分段线性近似模型)</p>
</blockquote>
<p>这里使用了多个线性模型(segment, FITing-Tree中的分段线性模型)组成了一个PLA-Model(PGM-Index中的一层)，一个segment包含了三部分(start key, slope, intercept)</p>
<blockquote>
<p>2.recursive index structure (递归索引结构)</p>
</blockquote>
<p>为了适应key的分布，PGM-Index使用了多层PLA-Model，我们先使用所有的key来构建最底层的PLA-Model，然后提取Segment中的key形成新的集合，然后对该集合再次构建PLA-Model，如此递归直到最高层的PLA-Model只有一个segment</p>
<p>下图包含了PGM-Index的构建伪代码，查找伪代码和查找示意图<br><img src="/../images/The-PGM-index-a-fully-dynamic-compressed-learned-index-with-provable-worst-case-bounds/1.png" alt="img"></p>
<h3 id="Optimal-PLA-model"><a href="#Optimal-PLA-model" class="headerlink" title="Optimal PLA-model"></a>Optimal PLA-model</h3><p>找到最优的PLA-model的方法是动态规划，但它所需要的O(n^3)是禁止的。FITing-Tree的作者通过收缩锥的方式来在线性时间内解决这个问题但无法保证是最优的PLA-model</p>
<p>然而我们发现这个问题在时间序列的有损压缩和相似性搜索中得到了广泛的研究，并且它允许采用O(n)最优时间和空间的流媒体算法。这类方法的关键思想是将分段线性近似问题简化为构造一组点的凸包在我们的情况下，这是集合{(ki，rank(ki))}为i &#x3D; 0，…，n−1。只要凸包可以被封闭在一个高度不超过2ε的（可能是旋转的）矩形中，索引i就会递增，集合就会被扩展。一旦包围凸壳的矩形高于2ε，我们就停止构造，通过取将矩形分成两个等尺寸的半的线来确定pla模型的一部分。然后，清空当前的处理元素集，算法从其余的输入点重新启动。这种贪婪方法可以被证明在pla模型的大小上是最优的，并且具有线性的时间和空间复杂度。</p>
<h2 id="DYNAMIC-PGM-INDEX"><a href="#DYNAMIC-PGM-INDEX" class="headerlink" title="DYNAMIC PGM-INDEX"></a>DYNAMIC PGM-INDEX</h2><p>插入和删除操作</p>
<p>现有学习型索引插入操作的实现方案是，将元素按序插入到相应段的缓存中，当缓存满了，将缓存与主索引合并，合并需要重新训练。这个方案在key非常多时，效率较低。本文提出两个插入策略：（1）面向时序数据（2）面向一般数据</p>
<ul>
<li>如果是时间序列的数据，插入的数据肯定是在数组A的最后面，那么如果最后一个段能够存放这个数据，且满足ε的条件，就直接放在最后一个段；否则新建一个段，然后向上层一层一层更新Segment。在这种策略下，每层更新最多只涉及到一个Segment的添加，因此需要的I&#x2F;O少。</li>
<li>如果是一般的数据，即插入的位置可以是任意的。这里则采用LSM-Tree更新数据的思想。</li>
</ul>
<p><img src="/../images/The-PGM-index-a-fully-dynamic-compressed-learned-index-with-provable-worst-case-bounds/2.png" alt="img"></p>
<h2 id="COMPRESSED-PGM-INDEX"><a href="#COMPRESSED-PGM-INDEX" class="headerlink" title="COMPRESSED PGM-INDEX"></a>COMPRESSED PGM-INDEX</h2>]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>Towards Practical Learned Indexing</title>
    <url>/2024/10/03/Towards-Practical-Learned-Indexing/</url>
    <content><![CDATA[<h2 id="背景和应用场景："><a href="#背景和应用场景：" class="headerlink" title="背景和应用场景："></a>背景和应用场景：</h2><p>(1)Learned Index<br></p>
<p>(2)RadixSpline </p>
<ul>
<li>只读工作负载</li>
<li>相对于Learned Index，RadixSpline含有两个超参数构建spline points的error和radix table的大小（b-length prefix of a lookup key），训练更快（one-single pass）或者说bulk-loading时间更短</li>
<li>查找过程，radix-table定位包含lookup key的两个spline point，之后使用线性插值得到predict_pos，最后使用二分查找定位real_pos</li>
</ul>
<p><img src="/../images/Towards-Practical-Learned-Indexing/image.png" alt="img"><br><img src="/../images/Towards-Practical-Learned-Indexing/image%20copy.png" alt="img"></p>
<p>(3)PLEX</p>
<ul>
<li>RadixSpline + CHT</li>
<li>只有一个超参数构建spline points的error</li>
<li>只读工作负载</li>
</ul>
<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>(1)RadixSpline的超参数（radix table的大小（b-length prefix of a lookup key））很难调试<br><br>(2)RadixSpline的radix-layer可能因为异常值（如face数据集中key的最长公共前缀很长时，这样radix-table所需要的size就会很大）而导致性能下降<br></p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>提出PLEX(RadixSpline + compact-hist-tree)，需要two-pass</p>
<p>PLEX对RadixSpline改进，解决两个问题<br><br>1.Radix layer很难参数化。<br><br>2.Radix layer会被outliers影响。<br></p>
<blockquote>
<p>RadixSpline使用radix table来索引spline points，然而当key的二进制表示的最长公共前缀很大时，RadixSpline可能会降低性能。PLEX通过由CHT表示的RadixTree来解决这个问题</p>
</blockquote>
<h3 id="Hist-tree："><a href="#Hist-tree：" class="headerlink" title="Hist-tree："></a>Hist-tree：</h3><p>Compact-hist-tree是Hist-tree在只读工作负载中的优化<br><br>Compact-hist-tree的构建方式<br><br>（1）从hist-tree构建<br><br>（2）直接从data构建（本文实现）<br></p>
<h3 id="auto-tuner"><a href="#auto-tuner" class="headerlink" title="auto-tuner"></a>auto-tuner</h3><p>为Compact-hist-tree实现auto-tuner（本文实现）</p>
<h3 id="cost-model"><a href="#cost-model" class="headerlink" title="cost-model"></a>cost-model</h3><h4 id="radix-Table-cost-model"><a href="#radix-Table-cost-model" class="headerlink" title="radix-Table cost-model"></a>radix-Table cost-model</h4><p>Radix-table使用lookup-key的prefix长度为r<br><br>则radix-table的长度为2^r<br><br>k为lookup key，则bk为radix-table通过k锁定的区间长度<br></p>
<p><img src="/../images/Towards-Practical-Learned-Indexing/image%20copy%202.png" alt="img"><br>Average lookup time 如下:<br><img src="/../images/Towards-Practical-Learned-Indexing/image%20copy%203.png" alt="img"><br>Memory Consumption是O(2^R)</p>
<h4 id="CHT-cost-model"><a href="#CHT-cost-model" class="headerlink" title="CHT cost-model"></a>CHT cost-model</h4><p>CHT有两个参数：（1）使用lookup-key的prefix长度为r（2）通过CHT确定对应的node后，在node中对应的bin中需要进行二分查找的bound</p>
<p><img src="/../images/Towards-Practical-Learned-Indexing/image%20copy%204.png" alt="img"></p>
<p>Average lookup time 如下:</p>
<p><img src="/../images/Towards-Practical-Learned-Indexing/image%20copy%205.png" alt="img"></p>
<p><img src="/../images/Towards-Practical-Learned-Indexing/image%20copy%206.png" alt="img"></p>
<p><img src="/../images/Towards-Practical-Learned-Indexing/image%20copy%207.png" alt="img"></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/../images/Towards-Practical-Learned-Indexing/image%20copy%208.png" alt="img"><br><img src="/../images/Towards-Practical-Learned-Indexing/image%20copy%209.png" alt="img"></p>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>Updatable-Learned-Index-with-Precise-Positions</title>
    <url>/2023/10/10/Updatable-Learned-Index-with-Precise-Positions/</url>
    <content><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>读写负载</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Learned Index：只能在只读数据集上查找，无法处理索引结构中必不可少的更新操作<br>ALEX和PGM：它们对更新的支持是以查找操作的额外搜索为代价的；并且这些索引的更新操作也会导致大量元素的移动</p>
<p>需要一种索引可以解决“最后一英里问题”</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>每个Node包含一个model、一个entries array、一个bit数组，<br>每个bit表示array中一个entry的类型，<br>类型有<br>NULL（空entry），<br>DATA(entry包含一个键值对，如果键值对太大，保存一个指向payload的指针)，<br>NODE（该entry指向下一层中的一个子节点，将一个新元素插入DATA entry时，创建一个子节点保存这两个entry，该entry指向这个新的节点）</p>
<p>三种类型的entry的大小都为16byte，其中DATA类型的entry由8byte的key和8byte的payload组成<br>对于第i个entry，bit数组的第2<em>i位表示该entry是不是NULL,第2</em>i + 1位表示entry的type</p>
<p>LIPP不区分leaf node和internal node<br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/1.jpg" alt="img"><br>各种操作的算法：<br>FMCD算法：</p>
<blockquote>
<p>给定一组key和数组长度L，计算最小的冲突度T及相应的linear model</p>
</blockquote>
<p><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/2.jpg" alt="img"><br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/3.jpg" alt="img"><br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/4.jpg" alt="img"><br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/5.jpg" alt="img"><br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/6.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>Learned Index</category>
      </categories>
      <tags>
        <tag>Learned Index</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware的三种网络模式</title>
    <url>/2024/08/20/VMware%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://wxler.github.io/2021/02/02/221724/">参考链接</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake-generator-error-under-windows-system</title>
    <url>/2023/12/07/cmake-generator-error-under-windows-system/</url>
    <content><![CDATA[<p>1.安装windows版本cmake（配置环境变量）<br>2.安装windows版本mingw（配置环境变量）<br>3.创建工程目录<br>执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -G &quot;MinGW Makefiles&quot; -D &quot;CMAKE_MAKE_PROGRAM:PATH=your path to make.exe&quot;</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="https://blog.csdn.net/dcrmg/article/details/103918543">https://blog.csdn.net/dcrmg/article/details/103918543</a><br><a href="https://codeantenna.com/a/ELzh11ElWs">https://codeantenna.com/a/ELzh11ElWs</a></p>
]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake学习</title>
    <url>/2023/05/28/cmake%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>语法手册：cmake语法手册及教程_可克的博客-CSDN博客_cmake语法</p>
<p><a href="https://www.bilibili.com/video/BV1vR4y1u77h?spm_id_from=333.337.search-card.all.click">哔哩哔哩视频</a></p>
<p>视频下方有笔记</p>
<p><img src="/images/cmake%E5%AD%A6%E4%B9%A0/1.jpg" alt="图片"></p>
<p>add_definitions()添加编译选项</p>
<p>include_directories()将指定目录添加到编译器的头文件搜索路径下</p>
<p><a href="https://www.jianshu.com/p/e7de3de1b0fa">参考</a></p>
<p>add_library()生成静态库（STATIC)或者动态库（SHARED）</p>
<p>add_executable()生成可执行文件</p>
<p>aux_source_directory(dir VAR) 发现一个目录(dir)下所有的源代码文件并将列表存储在一个变量(VAR)中</p>
<p>target_link_libraries( # 目标库 demo # 目标库需要链接的库 ${log-lib} )</p>
]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>cmu15445-project0</title>
    <url>/2024/02/22/cmu15445-project0/</url>
    <content><![CDATA[<h2 id="TASK-1-Copy-On-Write-Trie"><a href="#TASK-1-Copy-On-Write-Trie" class="headerlink" title="TASK 1 Copy-On-Write Trie"></a>TASK 1 Copy-On-Write Trie</h2><p>COW Trie在每次插入和删除时不会改变原有节点，而是对该节点的副本进行修改后，依次为其父节点创建修改后的副本，最后返回一个新的根节点。<br>此外，删除操作中，如果回溯路径上的某节点无值，且不存在子节点，还需要删除该节点</p>
<hr>
<p>插入(“ad”, 2),创建了一个新的Node2<br><img src="/../images/cmu15445-project0/2.png" alt="img"></p>
<hr>
<p>插入(“b”, 3)<br><img src="/../images/cmu15445-project0/1.png" alt="img"></p>
<hr>
<p>插入(“a”, “abc”) 删除(“ab”, 1)<br><br>注意删除操作后需要清除所有不需要的节点</p>
<p><img src="/../images/cmu15445-project0/3.png" alt="img"></p>
<p>Get函数实现</p>
<blockquote>
<p>从root节点遍历Tire树，<br>如果key不存在返回nullptr，<br>如果key存在，但是对应的Node无value或者value的类型不匹配，返回nullptr<br>其它情况，返回value</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the value associated with the given key.</span></span><br><span class="line"><span class="comment">// 1. If the key is not in the trie, return nullptr.</span></span><br><span class="line"><span class="comment">// 2. If the key is in the trie but the type is mismatched, return nullptr.</span></span><br><span class="line"><span class="comment">// 3. Otherwise, return the value.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Get</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> T * </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; <span class="title">ptr</span><span class="params">(root_)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> ch : key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr-&gt;children_.<span class="built_in">count</span>(ch) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = ptr-&gt;children_.<span class="built_in">at</span>(ch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!ptr-&gt;is_value_node_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> p = std::dynamic_pointer_cast&lt;<span class="type">const</span> TrieNodeWithValue&lt;T&gt;&gt;(ptr);</span><br><span class="line">  <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p-&gt;value_.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Put</span><span class="params">(std::string_view key, T value)</span> <span class="type">const</span> -&gt; Trie </span>&#123;</span><br><span class="line">  <span class="comment">// Note that `T` might be a non-copyable type. Always use `std::move` when creating `shared_ptr` on that value.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// You should walk through the trie and create new nodes if necessary. If the node corresponding to the key already</span></span><br><span class="line">  <span class="comment">// exists, you should create a new `TrieNodeWithValue`.</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; <span class="title">new_root</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">  std::map&lt;<span class="type">char</span>, std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;&gt; children;</span><br><span class="line">  <span class="keyword">if</span> (key.<span class="built_in">length</span>() == <span class="number">0</span>) &#123;<span class="comment">//key长度为0，表示在root节点put value</span></span><br><span class="line">    <span class="keyword">if</span> (root_) &#123;</span><br><span class="line">      children = root_-&gt;children_;</span><br><span class="line">    &#125;</span><br><span class="line">    new_root = std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;T&gt;&gt;(children, std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value)));<span class="comment">//创建一个新的root节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Trie</span>(new_root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;TrieNode&gt;&gt; stack;</span><br><span class="line">  <span class="keyword">if</span> (root_) &#123;</span><br><span class="line">    stack.<span class="built_in">push_back</span>(root_-&gt;<span class="built_in">Clone</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    stack.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;TrieNode&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">ptr</span><span class="params">(root_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int64_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(key.<span class="built_in">length</span>() - <span class="number">1</span>); ++i) &#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;TrieNode&gt; <span class="title">tmp_ptr</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (ptr &amp;&amp; ptr-&gt;children_.<span class="built_in">count</span>(key[i]) == <span class="number">1</span>) &#123;</span><br><span class="line">      ptr = ptr-&gt;children_.<span class="built_in">at</span>(key[i]);</span><br><span class="line">      tmp_ptr = ptr-&gt;<span class="built_in">Clone</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp_ptr = std::<span class="built_in">make_unique</span>&lt;TrieNode&gt;();</span><br><span class="line">      ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(tmp_ptr));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> value_ptr = std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">  <span class="keyword">if</span> (ptr &amp;&amp; ptr-&gt;children_.<span class="built_in">count</span>(key.<span class="built_in">back</span>())) &#123;</span><br><span class="line">    ptr = ptr-&gt;children_.<span class="built_in">at</span>(key.<span class="built_in">back</span>());</span><br><span class="line">    children = ptr-&gt;children_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> value_node = std::make_unique&lt;TrieNodeWithValue&lt;T&gt;&gt;(children, std::<span class="built_in">move</span>(value_ptr));</span><br><span class="line">  stack.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(value_node));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int64_t</span> i = key.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp_ptr = std::<span class="built_in">move</span>(stack.<span class="built_in">back</span>());</span><br><span class="line">    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">    stack.<span class="built_in">back</span>()-&gt;children_[key[i]] = std::<span class="built_in">move</span>(tmp_ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  new_root = std::<span class="built_in">move</span>(stack.<span class="built_in">back</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Trie</span>(new_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="TASK-2-Concurrent-Key-Value-Store"><a href="#TASK-2-Concurrent-Key-Value-Store" class="headerlink" title="TASK 2 Concurrent Key-Value Store"></a>TASK 2 Concurrent Key-Value Store</h2><blockquote>
<p>concurrent Key-Value store需要支持 <strong>多个读者和一个写者</strong> 工作的情况<br>也就是当一个写者在创建一个新的root的时候，读者可以在old root进行读操作<br>Tire_store.cpp文件<br></p>
</blockquote>
<p>读操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TrieStore::Get</span><span class="params">(std::string_view key)</span> -&gt; std::optional&lt;ValueGuard&lt;T&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Pseudo-code:</span></span><br><span class="line">  <span class="comment">// (1) Take the root lock, get the root, and release the root lock. Don&#x27;t lookup the value in the</span></span><br><span class="line">  <span class="comment">//     trie while holding the root lock.</span></span><br><span class="line">  <span class="comment">// (2) Lookup the value in the trie.</span></span><br><span class="line">  <span class="comment">// (3) If the value is found, return a ValueGuard object that holds a reference to the value and the</span></span><br><span class="line">  <span class="comment">//     root. Otherwise, return std::nullopt.</span></span><br><span class="line">  Trie root;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root = root_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> T *val = root.<span class="built_in">Get</span>&lt;T&gt;(key);</span><br><span class="line">  <span class="keyword">if</span> (!val) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ValueGuard</span>&lt;T&gt;(root, *val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Put</span><span class="params">(std::string_view key, T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span></span><br><span class="line">  <span class="comment">// The logic should be somehow similar to `TrieStore::Get`.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(write_lock_)</span></span>;</span><br><span class="line">  Trie root;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root = root_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Trie new_root = root.<span class="built_in">Put</span>&lt;T&gt;(key, std::<span class="built_in">move</span>(value));</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root_ = new_root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Remove</span><span class="params">(std::string_view key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span></span><br><span class="line">  <span class="comment">// The logic should be somehow similar to `TrieStore::Get`.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(write_lock_)</span></span>;</span><br><span class="line">  Trie root;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root = root_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Trie new_root = root.<span class="built_in">Remove</span>(key);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root_ = new_root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="TASK-3-Debugging"><a href="#TASK-3-Debugging" class="headerlink" title="TASK 3 Debugging"></a>TASK 3 Debugging</h2><p>skip…….</p>
<h2 id="TASK-4-SQL-String-Functions"><a href="#TASK-4-SQL-String-Functions" class="headerlink" title="TASK 4 SQL String Functions"></a>TASK 4 SQL String Functions</h2><p>实现Upper方法和Lower方法<br>src&#x2F;include&#x2F;execution&#x2F;string_expression.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Compute</span><span class="params">(<span class="type">const</span> std::string &amp;val)</span> <span class="type">const</span> -&gt; std::string </span>&#123;</span><br><span class="line">    <span class="comment">// TODO(student): implement upper / lower.</span></span><br><span class="line">    std::string res;</span><br><span class="line">    res.<span class="built_in">resize</span>(val.<span class="built_in">length</span>());</span><br><span class="line">    <span class="keyword">switch</span> (expr_type_) &#123;</span><br><span class="line">      <span class="keyword">case</span> StringExpressionType::Lower:</span><br><span class="line">        std::<span class="built_in">transform</span>(val.<span class="built_in">begin</span>(), val.<span class="built_in">end</span>(), res.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> StringExpressionType::Upper:</span><br><span class="line">        std::<span class="built_in">transform</span>(val.<span class="built_in">begin</span>(), val.<span class="built_in">end</span>(), res.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:<br><br><img src="/../images/cmu15445-project0/4.png" alt="img"></p>
<p>测试通过截图：<br><br><img src="/../images/cmu15445-project0/5.png" alt="img"></p>
]]></content>
      <categories>
        <category>cmu15445-2023</category>
      </categories>
      <tags>
        <tag>cmu15445—2023</tag>
      </tags>
  </entry>
  <entry>
    <title>cmu15445-project1</title>
    <url>/2024/02/26/cmu15445-project1/</url>
    <content><![CDATA[<h2 id="project1的任务就是实现一个Buffer-Pool-Manager"><a href="#project1的任务就是实现一个Buffer-Pool-Manager" class="headerlink" title="project1的任务就是实现一个Buffer Pool Manager"></a>project1的任务就是实现一个Buffer Pool Manager<br></h2><p>DBMS启动时会从OS申请一片内存区域，即Buffer Pool，并将这块区域划分成大小相同的pages，为了与disk pages区别，通常称为frames，当DBMS请求一个disk page时，它首先需要被复制到Buffer Pool的一个frame中。当Buffer Pool空间不足时，需要采取某种replacement policy，淘汰已有的page。<br><img src="/../images/cmu15445-project1/1.png" alt="img"></p>
<p>question 1:<br>为什么不使用OS自带的磁盘管理模块，OS为开发者提供了mmap这样的调用，使开发者能够依赖OS自动管理数据在内外存之间的移动？</p>
<blockquote>
<p>DBMS比OS拥有更多、更充分的知识来决定数据移动的移动和数量，具体包括</p>
<ol>
<li>将dirty pages按正确的顺序写到磁盘</li>
<li>根据具体情况预获取数据</li>
<li>定制化缓存置换策略</li>
</ol>
</blockquote>
<p>同时DBMS会维护一个page table，负责记录每个page在内存中的位置，以及是否被写过(Dirty Flag),是否被引用或引用计数(Pin&#x2F;Reference Counter)等元信息，如下图所示:</p>
<p><img src="/../images/cmu15445-project1/2.png" alt="img"></p>
<p>当page table中的某page被引用时，会记录引用数(pin&#x2F;reference),表示该page正在被使用，空间不够时不应该被移除；当被请求的page不再page table中时，DBMS会申请一个latch(lock的别名)，表示该entry被占用，然后从disk中读取相关page到buffer pool，释放latch</p>
<p><img src="/../images/cmu15445-project1/3.png" alt="img"></p>
<h2 id="Buffer-Replacement-Policies"><a href="#Buffer-Replacement-Policies" class="headerlink" title="Buffer Replacement Policies"></a>Buffer Replacement Policies</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>维护每个page上一次被访问的时间戳，每次移除时间戳最早的page</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>Clock是LRU的近似策略，它不需要每个page上次被访问的时间戳，而是为每个page保存一个reference</p>
<ul>
<li>每当page被访问时，reference bit设置为1</li>
<li>每当需要移动page时，从上次访问的位置开始，按顺序轮询，每个page的reference bit，若该bit为1，则重置为0；若该bit为0，则移除该page</li>
</ul>
<h3 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h3><p>保存每个page的最后K次访问时间戳，利用这些时间戳来估计它们下次被访问的时间，通常K取1就能获得很好的效果。</p>
<h2 id="Task-1-LRU-K-Replacement-Policy"><a href="#Task-1-LRU-K-Replacement-Policy" class="headerlink" title="Task#1 LRU-K Replacement Policy"></a>Task#1 LRU-K Replacement Policy</h2><p>实现LRUKReplacer<br>实现策略:</p>
<blockquote>
<p>LRU-K算法驱逐replacer的所有frame中backward k-distance最大的frame<br><br>backward k-distance计算方式:当前时间戳与之前k次访问的时间戳之间的时间差。<br><br>历史访问次数少于k的帧被赋予+inf作为其backward k-distance,当多个frame具有+inf backward k-distance时，replacer将驱逐具有最早总体时间戳的frame<br></p>
</blockquote>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：<br></h3><p>一个LRUKNode对应一个frame</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUKNode</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/** History of last seen K timestamps of this page. Least recent timestamp stored in front. */</span></span><br><span class="line">  std::list&lt;<span class="type">size_t</span>&gt; history_;<span class="comment">//记录一批时间戳</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid_;<span class="comment">//</span></span><br><span class="line">  <span class="type">bool</span> is_evictable_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUKReplacer</span> &#123;</span><br><span class="line">  std::unordered_map&lt;<span class="type">frame_id_t</span>, LRUKNode&gt; node_store_;<span class="comment">//frame LRUKNode couple</span></span><br><span class="line">  <span class="type">size_t</span> current_timestamp_&#123;<span class="number">0</span>&#125;;<span class="comment">//当前时间戳</span></span><br><span class="line">  <span class="comment">//replacer_size_ &gt;= curr_size</span></span><br><span class="line">  <span class="type">size_t</span> curr_size_&#123;<span class="number">0</span>&#125;;<span class="comment">//curr_size为当前is_evictable被标记为true的frame数量</span></span><br><span class="line">  <span class="type">size_t</span> replacer_size_;<span class="comment">//replacer_size == num_frames</span></span><br><span class="line">  <span class="type">size_t</span> k_;</span><br><span class="line">  std::mutex latch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Evict函数</p>
<blockquote>
<p>驱逐一个frame，驱逐成功返回true，否则返回false</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LRUKReplacer::Evict</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  *frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : node_store_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.second.is_evictable_) &#123;<span class="comment">//通过Judge函数选择backward k-distance中最大的frame</span></span><br><span class="line">      <span class="keyword">if</span> (*frame_id == <span class="number">-1</span> || <span class="built_in">Judge</span>(p.second, node_store_[*frame_id])) &#123;</span><br><span class="line">        *frame_id = p.second.fid_;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (*frame_id != <span class="number">-1</span>) &#123;</span><br><span class="line">    node_store_.<span class="built_in">erase</span>(*frame_id);</span><br><span class="line">    --curr_size_;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Judge函数实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//lhs的backward k-distance大于rhs的backward k-distance 返回true 否则返回false</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Judge</span><span class="params">(<span class="type">const</span> LRUKNode &amp;lhs, <span class="type">const</span> LRUKNode &amp;rhs)</span> <span class="type">const</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rhs.history_.<span class="built_in">size</span>() == k_ &amp;&amp; lhs.history_.<span class="built_in">size</span>() &lt; k_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rhs.history_.<span class="built_in">size</span>() &lt; k_ &amp;&amp; lhs.history_.<span class="built_in">size</span>() == k_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较最早的时间戳,若lhs的时间戳更小，则返回true 否则返回false</span></span><br><span class="line">    <span class="keyword">return</span> lhs.history_.<span class="built_in">back</span>() &lt; rhs.history_.<span class="built_in">back</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>RecordAccess函数</p>
<blockquote>
<ol>
<li>如果访问的frame_id大于等于replacer_size抛出异常</li>
<li>否则，对该frame对应的LRUKNode添加时间戳，并且保证history_列表长度不超过k_</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::RecordAccess</span><span class="params">(<span class="type">frame_id_t</span> frame_id, [[maybe_unused]] AccessType access_type)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (frame_id &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(replacer_size_)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;frame_id is larger than or equal to replacer_size_&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node_store_.<span class="built_in">count</span>(frame_id) == <span class="number">0</span>) &#123;</span><br><span class="line">    node_store_[frame_id] = <span class="built_in">LRUKNode</span>();</span><br><span class="line">    node_store_[frame_id].fid_ = frame_id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> &amp;node = node_store_[frame_id];</span><br><span class="line">  node.history_.<span class="built_in">push_front</span>(current_timestamp_++);</span><br><span class="line">  <span class="keyword">while</span> (node.history_.<span class="built_in">size</span>() &gt; k_) &#123;</span><br><span class="line">    node.history_.<span class="built_in">pop_back</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SetEvictable函数</p>
<blockquote>
<p>将某个frame的is_evictable标记为set_evictable,如果该frame未被占用，抛出异常<br>false-&gt;true   curr_size_++<br>true-&gt;false   curr_size_–</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::SetEvictable</span><span class="params">(<span class="type">frame_id_t</span> frame_id, <span class="type">bool</span> set_evictable)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (node_store_.<span class="built_in">count</span>(frame_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;frame_id should be used&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!node_store_[frame_id].is_evictable_ &amp;&amp; set_evictable) &#123;  <span class="comment">// false -&gt; true</span></span><br><span class="line">    curr_size_++;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node_store_[frame_id].is_evictable_ &amp;&amp; !set_evictable) &#123;  <span class="comment">// true -&gt; false</span></span><br><span class="line">    curr_size_--;</span><br><span class="line">  &#125;</span><br><span class="line">  node_store_[frame_id].is_evictable_ = set_evictable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Remove函数</p>
<blockquote>
<p>如果删除的frame不存在直接返回<br>如果删除的frame的is_evictable_未被设置为true，抛出异常<br>删除frame，–curr_size_</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::Remove</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (node_store_.<span class="built_in">count</span>(frame_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!node_store_[frame_id].is_evictable_) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;Remove a non-evictable frame&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  node_store_.<span class="built_in">erase</span>(frame_id);</span><br><span class="line">  --curr_size_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>task1本地测试：<br><img src="/../images/cmu15445-project1/5.png" alt="img"></p>
<h2 id="Task-2-Buffer-Pool-Manager"><a href="#Task-2-Buffer-Pool-Manager" class="headerlink" title="Task#2 -Buffer Pool Manager"></a>Task#2 -Buffer Pool Manager</h2><p>完成LRU-K替换策略之后，接下来需要实现Buffer Pool的基本功能。对于DBMS来说，Buffer Pool可以隐藏内存和磁盘交互的细节，包括脏页面写回磁盘的过程。</p>
<p>Page</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">  <span class="type">char</span> *data_;<span class="comment">//4096字节</span></span><br><span class="line">  <span class="type">page_id_t</span> page_id;<span class="comment">//physical page id</span></span><br><span class="line">  <span class="type">int</span> pin_count_;<span class="comment">//该Page对象的引用计数</span></span><br><span class="line">  <span class="type">bool</span> is_dirty_;<span class="comment">//脏位</span></span><br><span class="line">  ReaderWriterLatch rwlatch_;<span class="comment">//读写锁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BufferPoolManager</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BufferPoolManager</span> &#123;</span><br><span class="line">    <span class="comment">/** Number of pages in the buffer pool. */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> pool_size_;</span><br><span class="line">  <span class="comment">/** The next page id to be allocated  */</span></span><br><span class="line">  std::atomic&lt;<span class="type">page_id_t</span>&gt; next_page_id_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Array of buffer pool pages. */</span></span><br><span class="line">  Page *pages_;</span><br><span class="line">  <span class="comment">/** Pointer to the disk manager. */</span></span><br><span class="line">  DiskManager *disk_manager_ __attribute__((__unused__));</span><br><span class="line">  <span class="comment">/** Pointer to the log manager. Please ignore this for P1. */</span></span><br><span class="line">  LogManager *log_manager_ __attribute__((__unused__));</span><br><span class="line">  <span class="comment">/** Page table for keeping track of buffer pool pages. */</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_;</span><br><span class="line">  <span class="comment">/** Replacer to find unpinned pages for replacement. */</span></span><br><span class="line">  std::unique_ptr&lt;LRUKReplacer&gt; replacer_;</span><br><span class="line">  <span class="comment">/** List of free frames that don&#x27;t have any pages on them. */</span></span><br><span class="line">  std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;</span><br><span class="line">  <span class="comment">/** This latch protects shared data structures. We recommend updating this comment to describe what it protects. */</span></span><br><span class="line">  std::mutex latch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BufferPoolManager初始化时，分配pool_size_个Page对象，LRUKReplacer的num_frame也设置为pool_size_</p>
<h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：<br></h3><p>NewPage函数实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::NewPage</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> -&gt; Page * </span>&#123;</span><br><span class="line">  <span class="type">frame_id_t</span> free_frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">//获取一个空闲的frame</span></span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;<span class="comment">//存在空的frame</span></span><br><span class="line">    free_frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//不存在空的frame</span></span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Evict</span>(&amp;free_frame_id)) &#123;<span class="comment">//通过LRUKReplacer得到一个空闲的frame</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pages_[free_frame_id].<span class="built_in">IsDirty</span>()) &#123;<span class="comment">//如果被驱逐的frame对应的page为脏页，需要进行写回操作</span></span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[free_frame_id].page_id_, pages_[free_frame_id].data_);</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_.<span class="built_in">erase</span>(pages_[free_frame_id].page_id_);<span class="comment">//将page_table_中该frame对应的page_id_删除</span></span><br><span class="line">    pages_[free_frame_id].<span class="built_in">ResetMemory</span>();<span class="comment">//重置该改frame对应的内存</span></span><br><span class="line">  &#125;</span><br><span class="line">  *page_id = <span class="built_in">AllocatePage</span>();</span><br><span class="line">  pages_[free_frame_id].page_id_ = *page_id;</span><br><span class="line">  pages_[free_frame_id].pin_count_ = <span class="number">1</span>;</span><br><span class="line">  pages_[free_frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  page_table_[*page_id] = free_frame_id;</span><br><span class="line"></span><br><span class="line">  replacer_-&gt;<span class="built_in">RecordAccess</span>(free_frame_id);</span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(free_frame_id, <span class="literal">false</span>);  <span class="comment">// no use</span></span><br><span class="line">  <span class="keyword">return</span> pages_ + free_frame_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FetchPage函数实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPage</span><span class="params">(<span class="type">page_id_t</span> page_id, [[maybe_unused]] AccessType access_type)</span> -&gt; Page * </span>&#123;</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(page_id != INVALID_PAGE_ID, <span class="string">&quot;page_id is equal to INVALID_PAGE_ID&quot;</span>);</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) != <span class="number">0</span>) &#123;<span class="comment">//如果page_table_中存在该page_id</span></span><br><span class="line">    pages_[page_table_[page_id]].pin_count_++;<span class="comment">//该page的引用计数增加</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">RecordAccess</span>(page_table_[page_id]);<span class="comment">//增加该page对应的frame的访问时间戳</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(page_table_[page_id], <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> pages_ + page_table_[page_id];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> free_frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//获取一个空闲的frame</span></span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    free_frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Evict</span>(&amp;free_frame_id)) &#123;<span class="comment">//通过LRUKReplacer得到一个空闲的frame</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pages_[free_frame_id].<span class="built_in">IsDirty</span>()) &#123;<span class="comment">//如果被驱逐的frame对应的page为脏页，需要进行写回操作</span></span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[free_frame_id].page_id_, pages_[free_frame_id].data_);</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_.<span class="built_in">erase</span>(pages_[free_frame_id].page_id_);<span class="comment">//将page_table_中该frame对应的page_id_删除</span></span><br><span class="line">    pages_[free_frame_id].<span class="built_in">ResetMemory</span>();<span class="comment">//重置该改frame对应的内存</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pages_[free_frame_id].page_id_ = page_id;</span><br><span class="line">  pages_[free_frame_id].pin_count_ = <span class="number">1</span>;</span><br><span class="line">  pages_[free_frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  page_table_[page_id] = free_frame_id;</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, pages_[free_frame_id].data_);<span class="comment">//读取该page_id对应的物理页</span></span><br><span class="line"></span><br><span class="line">  replacer_-&gt;<span class="built_in">RecordAccess</span>(free_frame_id);<span class="comment">//增加该frame的访问时间戳</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(free_frame_id, <span class="literal">false</span>);  <span class="comment">// no use</span></span><br><span class="line">  <span class="keyword">return</span> pages_ + free_frame_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UnpinPage函数实现：<br><br>需要注意的是入参is_dirty不能破坏已经置为脏的状态，这里用 | 运算符来实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::UnpinPage</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty, [[maybe_unused]] AccessType access_type)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = page_table_[page_id];</span><br><span class="line">  <span class="keyword">if</span> (pages_[frame_id].pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (--pages_[frame_id].pin_count_ == <span class="number">0</span>) &#123;<span class="comment">//引用计数减为0时，将该frame设置为evictable</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pages_[frame_id].is_dirty_ |= is_dirty;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FlushPage函数实现:<br><br>强制将page_id对应的Page的内容写回磁盘，并将该Page对应脏位置为false</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FlushPage</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = page_table_[page_id];</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, pages_[frame_id].data_);</span><br><span class="line">  pages_[frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FlushAllPages函数实现:<br>写回所有在内存中的Page</p>
<p>DeletePage函数实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::DeletePage</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = page_table_[page_id];</span><br><span class="line">  <span class="keyword">if</span> (pages_[frame_id].pin_count_ != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//只有当该page_id对应的Page的引用计数为0时可以进行删除</span></span><br><span class="line">  page_table_.<span class="built_in">erase</span>(page_id);<span class="comment">//page_table_删除该page_id</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">true</span>);<span class="comment">//replacer驱逐该frame</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">Remove</span>(frame_id);</span><br><span class="line">  free_list_.<span class="built_in">push_back</span>(frame_id);<span class="comment">//将该frame加入free_list</span></span><br><span class="line">  <span class="comment">//该Page初始化</span></span><br><span class="line">  pages_[frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  pages_[frame_id].page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  pages_[frame_id].<span class="built_in">ResetMemory</span>();</span><br><span class="line">  <span class="built_in">DeallocatePage</span>(page_id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>task2本地测试:<br><img src="/../images/cmu15445-project1/6.png" alt="img"></p>
<h2 id="Task-3-Read-Write-Page-Guards"><a href="#Task-3-Read-Write-Page-Guards" class="headerlink" title="Task#3 Read&#x2F;Write Page Guards"></a>Task#3 Read&#x2F;Write Page Guards</h2><p>FetchPage和NewPage函数返回指向pages的指针，并且pages已经被pinned，并且当一个page不再需要时，要调用UnpinPage。另一方面，如果忘记调用UnPinPage，该Page将永远不会被evict。于是PageGuard就派上用场了</p>
<p>BasicPageGuard<br>思路：BasicPageGuard析构时调用Page的UnpinPage函数，并且BasicPageGuard中保存变量is_dirty_,调用AsMut或GetDataMut函数时将is_dirty_设置为true</p>
<p>WritePageGuard和ReadPageGuard<br>思路：与BasicPageGuard思路相似，析构函数调用UnpinPage多了一步释放Page的写锁和读锁</p>
<p>FetchPageBasic、FetchPageRead、FetchPageWrite和NewPageGuarded的实现代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageBasic</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; BasicPageGuard </span>&#123; <span class="keyword">return</span> &#123;<span class="keyword">this</span>, <span class="built_in">FetchPage</span>(page_id)&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageRead</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; ReadPageGuard </span>&#123;</span><br><span class="line">  Page *page = <span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (page != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    page-&gt;<span class="built_in">RLatch</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, page&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageWrite</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; WritePageGuard </span>&#123;</span><br><span class="line">  Page *page = <span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (page != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, page&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::NewPageGuarded</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> -&gt; BasicPageGuard </span>&#123; <span class="keyword">return</span> &#123;<span class="keyword">this</span>, <span class="built_in">NewPage</span>(page_id)&#125;; &#125;</span><br></pre></td></tr></table></figure>
<p>task3本地测试：<br><img src="/../images/cmu15445-project1/7.png" alt="img"></p>
<p>测试通过截图：<br><img src="/../images/cmu15445-project1/4.png" alt="img"></p>
]]></content>
      <categories>
        <category>cmu15445-2023</category>
      </categories>
      <tags>
        <tag>cmu15445—2023</tag>
      </tags>
  </entry>
  <entry>
    <title>cmu15445-project2</title>
    <url>/2024/02/26/cmu15445-project2/</url>
    <content><![CDATA[<h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h1><p>B+ Tree是一种自平衡树，它将数据有序地存储，并且在search、sequential access、insertions以及deletions操作的复杂度上都满足O(logn),其中sequential access的最终复杂度还与所需数据总量有关<br><img src="/../images/cmu15445-project2/1.png" alt="img"><br>以M—way B+tree为例，它的特点总结如下：</p>
<ul>
<li>每个节点最多存储M个key，有M+1个children</li>
<li>B+ Tree是perfectly balanced，即每个leaf node的深度都一样</li>
<li>除了root节点，所有节点必须至少处于半满状态，即 M&#x2F;2 - 1 &lt;&#x3D; #keys &lt;&#x3D; M - 1</li>
<li>假设每个inner node中包含k个keys，那么它必然有k + 1个children</li>
</ul>
<h1 id="B-Tree-Operations"><a href="#B-Tree-Operations" class="headerlink" title="B+ Tree Operations"></a>B+ Tree Operations</h1><p>Insert</p>
<blockquote>
<ol>
<li>找到对应的leafNode L</li>
<li>将key&#x2F;value pair按顺序插入到 L 中</li>
<li>如果L 还有足够的空间，操作结束；如果空间不足，则需要将L分裂成两个节点，同时在parent node上新增entry，若parent node也空间不足，则递归地分裂，直到root node为止</li>
</ol>
</blockquote>
<p>Max.degree &#x3D; 5时<br><br>从1插入到13的情况  <a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">BPlusTree可视化网站</a><br><img src="/../images/cmu15445-project2/2.png" alt="img"></p>
<p>Delete</p>
<blockquote>
<ol>
<li>从root开始，找到目标entry所在的leaf node L</li>
<li>删除该entry</li>
<li>如果L仍然处在半满状态，操作结束；否则先尝试从siblings那里借entries，如果失败，则将L 与相应的sibling合并</li>
<li>如果合并发生了，则可能需要递归地删除parent node中的entry</li>
</ol>
</blockquote>
<h1 id="CheckPoint-1"><a href="#CheckPoint-1" class="headerlink" title="CheckPoint#1"></a>CheckPoint#1</h1><h2 id="Task-1-B-Tree-Pages"><a href="#Task-1-B-Tree-Pages" class="headerlink" title="Task #1 B+ Tree Pages"></a>Task #1 B+ Tree Pages</h2><h3 id="class-BPlusTreePage的3个类成员"><a href="#class-BPlusTreePage的3个类成员" class="headerlink" title="class BPlusTreePage的3个类成员"></a>class BPlusTreePage的3个类成员</h3><p><img src="/../images/cmu15445-project2/3.png" alt="img"><br>GetMinSize函数实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPlusTreePage::GetMinSize</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsLeafPage</span>()) &#123;<span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">return</span> max_size_ / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (max_size_ + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="class-BPlusTreeInternalPage-public-BPlusTreePage"><a href="#class-BPlusTreeInternalPage-public-BPlusTreePage" class="headerlink" title="class BPlusTreeInternalPage : public BPlusTreePage "></a>class BPlusTreeInternalPage : public BPlusTreePage <br></h3><blockquote>
<p>一个Internal Page存储 m 个顺序 key 和 m + 1 个child pointers(其它BPlusTreePage的page_ids)<br><br>使用一个数组存储key&#x2F;page_id pairs，并且第一个key被设置为invalid，并且查找要从第二个key开始查找</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::Init</span><span class="params">(<span class="type">int</span> max_size, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetPageType</span>(IndexPageType::INTERNAL_PAGE);</span><br><span class="line">  <span class="built_in">SetMaxSize</span>(max_size);</span><br><span class="line">  <span class="built_in">SetSize</span>(size);<span class="comment">//size 默认为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::ValueIndex</span><span class="params">(<span class="type">const</span> ValueType &amp;value)</span> <span class="type">const</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">GetSize</span>(); ++i) &#123;<span class="comment">//顺序查找</span></span><br><span class="line">    <span class="keyword">if</span> (array_[i].second == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::LookUp</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> KeyComparator &amp;comparator)</span> <span class="type">const</span> -&gt; ValueType </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">GetSize</span>(); ++i) &#123;  <span class="comment">// 顺序查找</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator</span>(key, array_[i].first) &lt; <span class="number">0</span>) &#123;<span class="comment">//找到第一个大于key的array_[i].first</span></span><br><span class="line">      <span class="keyword">return</span> array_[i - <span class="number">1</span>].second;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array_[<span class="built_in">GetSize</span>() - <span class="number">1</span>].second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::Insert</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value, <span class="type">const</span> KeyComparator &amp;comparator)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetSize</span>() == <span class="built_in">GetMaxSize</span>()) &#123;<span class="comment">//已经满了返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// upper_bound</span></span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> r = <span class="built_in">GetSize</span>();</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator</span>(array_[mid].first, key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetSize</span>() - <span class="number">1</span>; i &gt;= l; --i) &#123;<span class="comment">//元素移位</span></span><br><span class="line">    array_[i + <span class="number">1</span>] = array_[i];</span><br><span class="line">  &#125;</span><br><span class="line">  array_[l] = &#123;key, value&#125;;<span class="comment">//存储插入的key-value</span></span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">1</span>);<span class="comment">//size ++</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="class-BPlusTreeLeafPage-public-BPlusTreePage"><a href="#class-BPlusTreeLeafPage-public-BPlusTreePage" class="headerlink" title="class BPlusTreeLeafPage : public BPlusTreePage"></a>class BPlusTreeLeafPage : public BPlusTreePage</h3><blockquote>
<p>一个Leaf Page存储 m 个顺序 key 和 m 个对应的value.value应该为 64-bit record_id 用于表示实际的tuple存储的地方(src&#x2F;include&#x2F;common&#x2F;rid.h)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::Init</span><span class="params">(<span class="type">int</span> max_size, <span class="type">int</span> size, <span class="type">page_id_t</span> next_page_id)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetPageType</span>(IndexPageType::LEAF_PAGE);</span><br><span class="line">  <span class="built_in">SetMaxSize</span>(max_size);</span><br><span class="line">  <span class="built_in">SetSize</span>(size);<span class="comment">//size 默认为0</span></span><br><span class="line">  <span class="built_in">SetNextPageId</span>(next_page_id);<span class="comment">//next_page_id默认为INVALID_PAGE_ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::KeyIndex</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> KeyComparator &amp;comparator, <span class="type">int</span> &amp;index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// lower_bound</span></span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> r = <span class="built_in">GetSize</span>();</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator</span>(array_[mid].first, key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  index = l;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(l != <span class="built_in">GetSize</span>() &amp;&amp; <span class="built_in">comparator</span>(<span class="built_in">KeyAt</span>(l), key) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::Insert</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value, <span class="type">const</span> KeyComparator &amp;comparator)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">KeyIndex</span>(key, comparator, pos)) &#123;  <span class="comment">// duplicate key</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//重复的key，直接返回false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetSize</span>() - <span class="number">1</span>; i &gt;= pos; --i) &#123;<span class="comment">//移动array_元素</span></span><br><span class="line">    array_[i + <span class="number">1</span>] = array_[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// insert</span></span><br><span class="line">  array_[pos] = &#123;key, value&#125;;<span class="comment">//插入key-value</span></span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">1</span>);<span class="comment">//size ++</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Class-BplusTreeHeaderPage"><a href="#Class-BplusTreeHeaderPage" class="headerlink" title="Class BplusTreeHeaderPage"></a>Class BplusTreeHeaderPage</h3><blockquote>
<p>头节点，存储了root page id，使得根节点和非根节点一样拥有父节点</p>
</blockquote>
<h2 id="Task-2a-B-Tree-Data-Structure-Insertion-Point-Search"><a href="#Task-2a-B-Tree-Data-Structure-Insertion-Point-Search" class="headerlink" title="Task #2a B+ Tree Data Structure(Insertion, Point Search)"></a>Task #2a B+ Tree Data Structure(Insertion, Point Search)</h2><p>GetRootPageId函数实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS <span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::GetRootPageId</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">page_id_t</span> </span>&#123;</span><br><span class="line">  ReadPageGuard guard = bpm_-&gt;<span class="built_in">FetchPageRead</span>(header_page_id_);</span><br><span class="line">  <span class="keyword">auto</span> page = guard.<span class="built_in">As</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">return</span> page-&gt;root_page_id_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Search操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::GetValue</span><span class="params">(<span class="type">const</span> KeyType &amp;key, std::vector&lt;ValueType&gt; *result, Transaction *txn)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Declaration of context instance.</span></span><br><span class="line">  Context ctx;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//先给header_page加读锁判断root_page是否存在，如果存在，给root_page加读锁，放入Context中</span></span><br><span class="line">    <span class="keyword">auto</span> header_page_guard = bpm_-&gt;<span class="built_in">FetchPageRead</span>(header_page_id_);</span><br><span class="line">    <span class="keyword">auto</span> header_page = header_page_guard.<span class="built_in">As</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">    <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">    ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(ctx.root_page_id_));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//查找到对应的leafPage</span></span><br><span class="line">  <span class="built_in">FindLeafPage</span>(key, Operation::Search, ctx);</span><br><span class="line">  <span class="keyword">auto</span> leaf_page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;LeafPage&gt;();</span><br><span class="line">  <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">KeyIndex</span>(key, comparator_, index)) &#123;</span><br><span class="line">    result-&gt;<span class="built_in">push_back</span>(leaf_page-&gt;<span class="built_in">ValueAt</span>(index));<span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::FindLeafPage</span><span class="params">(<span class="type">const</span> KeyType &amp;key, Operation op, Context &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Search) &#123;</span><br><span class="line">    <span class="comment">//Search的加锁策略</span></span><br><span class="line">    <span class="comment">//从root往下，不断地</span></span><br><span class="line">    <span class="comment">// - 获取child的read latch</span></span><br><span class="line">    <span class="comment">// - 释放parent的read latch</span></span><br><span class="line">    <span class="keyword">auto</span> page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> internal = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;InternalPage&gt;();</span><br><span class="line">      <span class="keyword">auto</span> next_page_id = internal-&gt;<span class="built_in">LookUp</span>(key, comparator_);</span><br><span class="line">      ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(next_page_id));</span><br><span class="line">      ctx.read_set_.<span class="built_in">pop_front</span>();</span><br><span class="line">      page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Insert || op == Operation::Remove) &#123;</span><br><span class="line">    <span class="comment">//Insert和Remove的加锁策略</span></span><br><span class="line">    <span class="comment">//从root往下，按照需要获取write latch，一旦获取到了child的write latch，检查</span></span><br><span class="line">    <span class="comment">//它是否安全，如果安全，则释放之前获取的所有write latch</span></span><br><span class="line">    <span class="keyword">auto</span> page = ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> internal = ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;InternalPage&gt;();</span><br><span class="line">      <span class="keyword">auto</span> next_page_id = internal-&gt;<span class="built_in">LookUp</span>(key, comparator_);</span><br><span class="line">      ctx.write_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageWrite</span>(next_page_id));</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">IsSafePage</span>(ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;(), op, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ctx.write_set_.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          ctx.write_set_.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      page = ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::IsSafePage</span><span class="params">(<span class="type">const</span> BPlusTreePage *tree_page, Operation op, <span class="type">bool</span> isRootPage)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Search) &#123;<span class="comment">//no use</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Insert) &#123;<span class="comment">//插入操作</span></span><br><span class="line">    <span class="comment">//若会发生上溢，表示不安全</span></span><br><span class="line">    <span class="keyword">if</span> (tree_page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">      <span class="comment">//叶子节点中，size最大为tree_page-&gt;GetMaxSize() - 1;</span></span><br><span class="line">      <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() + <span class="number">1</span> &lt; tree_page-&gt;<span class="built_in">GetMaxSize</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部节点中，size最大为tree_page-&gt;GetMaxSize()</span></span><br><span class="line">    <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() &lt; tree_page-&gt;<span class="built_in">GetMaxSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Remove) &#123;<span class="comment">//删除操作</span></span><br><span class="line">    <span class="comment">//若会发生下溢，表示不安全</span></span><br><span class="line">    <span class="keyword">if</span> (isRootPage) &#123;<span class="comment">//对RootPage进行Remove操作</span></span><br><span class="line">      <span class="keyword">if</span> (tree_page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">        <span class="comment">//如果为叶子节点，size至少为2</span></span><br><span class="line">        <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() &gt; <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果为内部节点，size至少为3</span></span><br><span class="line">      <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() &gt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() &gt; tree_page-&gt;<span class="built_in">GetMinSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Insert操作</p>
<blockquote>
<p>插入到leaf节点中，插入前，如果size &#x3D;&#x3D; max_size表示溢出，需要进行分裂<br>插入到internal节点中，插入前，如果size &#x3D;&#x3D; max_size表示溢出，需要进行分裂 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS <span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::Insert</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value, Transaction *txn)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Declaration of context instance.</span></span><br><span class="line">  Context ctx;</span><br><span class="line">  ctx.header_page_ = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(header_page_id_);<span class="comment">//先给header_page_id写锁</span></span><br><span class="line">  <span class="keyword">auto</span> header_page = ctx.header_page_-&gt;<span class="built_in">AsMut</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;  <span class="comment">// root not exist,start a new tree</span></span><br><span class="line">    <span class="keyword">auto</span> root_guard = bpm_-&gt;<span class="built_in">NewPageGuarded</span>(&amp;ctx.root_page_id_);<span class="comment">//申请root_page</span></span><br><span class="line">    header_page-&gt;root_page_id_ = ctx.root_page_id_;</span><br><span class="line">    <span class="keyword">auto</span> leaf_page = root_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line">    leaf_page-&gt;<span class="built_in">Init</span>(leaf_max_size_, <span class="number">1</span>);</span><br><span class="line">    leaf_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>] = &#123;key, value&#125;;<span class="comment">//插入key-value</span></span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">  ctx.write_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageWrite</span>(ctx.root_page_id_));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsSafePage</span>(ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;(), Operation::Insert, <span class="literal">true</span>)) &#123;<span class="comment">//如果root_page安全，释放header_page的写锁</span></span><br><span class="line">    ctx.header_page_ = std::<span class="literal">nullopt</span>;  <span class="comment">// unlock header_page</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">FindLeafPage</span>(key, Operation::Insert, ctx);</span><br><span class="line">  <span class="keyword">auto</span> &amp;leaf_page_guard = ctx.write_set_.<span class="built_in">back</span>();</span><br><span class="line">  <span class="keyword">auto</span> leaf_page = leaf_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (!leaf_page-&gt;<span class="built_in">Insert</span>(key, value, comparator_)) &#123;  <span class="comment">// duplicate key, 插入失败</span></span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">GetSize</span>() &lt; leaf_page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 叶子节点未溢出，不需要分裂</span></span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发生溢出,叶子节点分裂</span></span><br><span class="line">  <span class="keyword">auto</span> new_page_id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> new_leaf_page_guard = bpm_-&gt;<span class="built_in">NewPageGuarded</span>(&amp;new_page_id);</span><br><span class="line">  <span class="keyword">auto</span> new_leaf_page = new_leaf_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line">  std::<span class="built_in">copy</span>(leaf_page-&gt;<span class="built_in">GetArray</span>() + leaf_page-&gt;<span class="built_in">GetMinSize</span>(), leaf_page-&gt;<span class="built_in">GetArray</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">            new_leaf_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">  new_leaf_page-&gt;<span class="built_in">Init</span>(leaf_max_size_, leaf_page-&gt;<span class="built_in">GetSize</span>() - leaf_page-&gt;<span class="built_in">GetMinSize</span>(), leaf_page-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">  leaf_page-&gt;<span class="built_in">SetNextPageId</span>(new_leaf_page_guard.<span class="built_in">PageId</span>());</span><br><span class="line">  leaf_page-&gt;<span class="built_in">SetSize</span>(leaf_page-&gt;<span class="built_in">GetMinSize</span>());</span><br><span class="line">  KeyType split_key = new_leaf_page-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 将split_key插入父节点</span></span><br><span class="line">  <span class="built_in">InsertIntoParent</span>(split_key, new_leaf_page_guard.<span class="built_in">PageId</span>(), ctx, ctx.write_set_.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">  ctx.<span class="built_in">Drop</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPLUSTREE_TYPE::InsertIntoParent</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">page_id_t</span> right_child_id, Context &amp;ctx, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;  <span class="comment">// parent为header_page</span></span><br><span class="line">    <span class="comment">//创建新的root_page，并更新header_page中的root_page_id_</span></span><br><span class="line">    <span class="keyword">auto</span> new_root_page_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> new_root_page_guard = bpm_-&gt;<span class="built_in">NewPageGuarded</span>(&amp;new_root_page_id);</span><br><span class="line">    <span class="keyword">auto</span> new_root_page = new_root_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">    new_root_page-&gt;<span class="built_in">Init</span>(internal_max_size_, <span class="number">2</span>);</span><br><span class="line">    new_root_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].second = ctx.write_set_[index + <span class="number">1</span>].<span class="built_in">PageId</span>();</span><br><span class="line">    new_root_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">1</span>] = &#123;key, right_child_id&#125;;</span><br><span class="line">    <span class="keyword">auto</span> header_page = ctx.header_page_-&gt;<span class="built_in">AsMut</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">    header_page-&gt;root_page_id_ = new_root_page_id;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> parent_page = ctx.write_set_[index].<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (parent_page-&gt;<span class="built_in">Insert</span>(key, right_child_id, comparator_)) &#123;  <span class="comment">// 父节点不需要分裂</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父节点需要分裂</span></span><br><span class="line">  <span class="keyword">auto</span> new_parent_page_id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> new_parent_page_guard = bpm_-&gt;<span class="built_in">NewPageGuarded</span>(&amp;new_parent_page_id);</span><br><span class="line">  <span class="keyword">auto</span> new_parent_page = new_parent_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">auto</span> array = <span class="keyword">new</span> std::pair&lt;KeyType, <span class="type">page_id_t</span>&gt;[parent_page-&gt;<span class="built_in">GetMaxSize</span>() + <span class="number">1</span>];</span><br><span class="line">  std::<span class="built_in">copy</span>(parent_page-&gt;<span class="built_in">GetArray</span>(), parent_page-&gt;<span class="built_in">GetArray</span>() + parent_page-&gt;<span class="built_in">GetMaxSize</span>(), array);</span><br><span class="line">  <span class="comment">// upper_bound</span></span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> r = parent_page-&gt;<span class="built_in">GetMaxSize</span>();</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator_</span>(array[mid].first, key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 右移一位，腾出空间</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = parent_page-&gt;<span class="built_in">GetMaxSize</span>() - <span class="number">1</span>; i &gt;= l; --i) &#123;</span><br><span class="line">    array[i + <span class="number">1</span>] = array[i];</span><br><span class="line">  &#125;</span><br><span class="line">  array[l] = &#123;key, right_child_id&#125;;</span><br><span class="line">  std::<span class="built_in">copy</span>(array, array + parent_page-&gt;<span class="built_in">GetMinSize</span>(), parent_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">  std::<span class="built_in">copy</span>(array + parent_page-&gt;<span class="built_in">GetMinSize</span>(), array + parent_page-&gt;<span class="built_in">GetMaxSize</span>() + <span class="number">1</span>, new_parent_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">  new_parent_page-&gt;<span class="built_in">Init</span>(internal_max_size_, parent_page-&gt;<span class="built_in">GetMaxSize</span>() + <span class="number">1</span> - parent_page-&gt;<span class="built_in">GetMinSize</span>());</span><br><span class="line">  parent_page-&gt;<span class="built_in">SetSize</span>(parent_page-&gt;<span class="built_in">GetMinSize</span>());</span><br><span class="line">  <span class="keyword">delete</span>[] array;</span><br><span class="line">  <span class="built_in">InsertIntoParent</span>(new_parent_page-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>), new_parent_page_id, ctx, index - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CheckPoint#1本地测试<br><br><img src="/../images/cmu15445-project2/4.png" alt="img"><br><img src="/../images/cmu15445-project2/5.png" alt="img"></p>
<p>线上测试<br><br><img src="/../images/cmu15445-project2/6.png" alt="img"></p>
<h1 id="CheckPoint-2"><a href="#CheckPoint-2" class="headerlink" title="CheckPoint#2"></a>CheckPoint#2</h1><h2 id="Task-2b-B-Tree-Data-Structure-Deletion"><a href="#Task-2b-B-Tree-Data-Structure-Deletion" class="headerlink" title="Task #2b B+ Tree Data Structure(Deletion)"></a>Task #2b B+ Tree Data Structure(Deletion)</h2><p>Deletion操作:</p>
<blockquote>
<p>如果删除的leaf节点是root节点，那么删除后的size &#x3D;&#x3D; 0,表示下溢，需要将header_page中的root_page设置为INVALID_PAGE_ID<br><br>如果删除的leaf节点不是root节点，那么删除后的size &lt; min_size表示下溢<br><br>1.如果有右孩子<br></p>
<blockquote>
<p>2.判断是否能merge(merge_size &lt; max_size),能则merge，否则转3<br><br>3.向右孩子进行borrow<br></p>
</blockquote>
</blockquote>
<blockquote>
<p>4.如果有左孩子<br></p>
<blockquote>
<p>5.判断是否能merge(merge_size &lt; min_size),能则merge，否则转6<br><br>6.向左孩子进行borrow<br></p>
</blockquote>
</blockquote>
<blockquote>
<p>merge操作后需要删除internal节点中的entry, 与删除leaf节点中的entry十分相似<br></p>
</blockquote>
<blockquote>
<p>如果删除的internal节点是root节点，那么删除后的size&#x3D;&#x3D;1表示下溢，需要将header_page_中的root_page_id_设置为page-&gt;GetArray()[0].second<br><br>如果删除的internal节点不是root节点，那么删除后的size &lt; min_size表示下溢<br><br>1.如果有右孩子<br></p>
<blockquote>
<p>2.判断是否能merge(merge_size &lt;&#x3D; max_size),能则merge，否则转3<br><br>3.向右孩子进行borrow<br></p>
</blockquote>
</blockquote>
<blockquote>
<p>4.如果有左孩子<br></p>
<blockquote>
<p>5.判断是否能merge(merge_size &lt;&#x3D; max_size),能则merge，否则转6<br><br>6.向左孩子进行borrow<br></p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPLUSTREE_TYPE::Remove</span><span class="params">(<span class="type">const</span> KeyType &amp;key, Transaction *txn)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Declaration of context instance.</span></span><br><span class="line">  Context ctx;</span><br><span class="line">  ctx.header_page_ = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(header_page_id_);</span><br><span class="line">  <span class="keyword">auto</span> header_page = ctx.header_page_-&gt;<span class="built_in">AsMut</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;  <span class="comment">// root not exist</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">  ctx.write_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageWrite</span>(ctx.root_page_id_));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsSafePage</span>(ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;(), Operation::Remove, <span class="literal">true</span>)) &#123;</span><br><span class="line">    ctx.header_page_ = std::<span class="literal">nullopt</span>;  <span class="comment">// unlock header_page</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">FindLeafPage</span>(key, Operation::Remove, ctx);</span><br><span class="line">  <span class="keyword">auto</span> &amp;leaf_page_guard = ctx.write_set_.<span class="built_in">back</span>();</span><br><span class="line">  <span class="keyword">auto</span> leaf_page = leaf_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// key不存在</span></span><br><span class="line">  <span class="keyword">if</span> (!leaf_page-&gt;<span class="built_in">KeyIndex</span>(key, comparator_, pos)) &#123;</span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// key存在,将其从leaf中删除</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = pos + <span class="number">1</span>; i &lt; leaf_page-&gt;<span class="built_in">GetSize</span>(); ++i) &#123;</span><br><span class="line">    leaf_page-&gt;<span class="built_in">GetArray</span>()[i - <span class="number">1</span>] = leaf_page-&gt;<span class="built_in">GetArray</span>()[i];</span><br><span class="line">  &#125;</span><br><span class="line">  leaf_page-&gt;<span class="built_in">SetSize</span>(leaf_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);  <span class="comment">// 更新leaf_page的size</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">GetSize</span>() &gt;= leaf_page-&gt;<span class="built_in">GetMinSize</span>()) &#123;  <span class="comment">// 无underflow 直接返回</span></span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// underflow</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="built_in">IsRootPage</span>(leaf_page_guard.<span class="built_in">PageId</span>())) &#123;  <span class="comment">// 该叶子节点是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">GetSize</span>() == <span class="number">0</span>) &#123;               <span class="comment">// size为0</span></span><br><span class="line">      header_page-&gt;root_page_id_ = INVALID_PAGE_ID;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> &amp;parent_page_guard = ctx.write_set_[ctx.write_set_.<span class="built_in">size</span>() - <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">auto</span> parent_page = parent_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">auto</span> index = parent_page-&gt;<span class="built_in">ValueIndex</span>(leaf_page_guard.<span class="built_in">PageId</span>());</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(index != <span class="number">-1</span>, <span class="string">&quot;index must not be -1&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果有右brother</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; parent_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">page_id_t</span> right_brother_page_id = parent_page-&gt;<span class="built_in">GetArray</span>()[index + <span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">auto</span> right_brother_page_guard = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(right_brother_page_id);</span><br><span class="line">    <span class="keyword">auto</span> right_brother_page = right_brother_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge_size = right_brother_page-&gt;<span class="built_in">GetSize</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">    <span class="keyword">if</span> (merge_size &lt; leaf_page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 可以合并</span></span><br><span class="line">      <span class="comment">// merge</span></span><br><span class="line">      std::<span class="built_in">copy</span>(right_brother_page-&gt;<span class="built_in">GetArray</span>(), right_brother_page-&gt;<span class="built_in">GetArray</span>() + right_brother_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                leaf_page-&gt;<span class="built_in">GetArray</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>());</span><br><span class="line">      leaf_page-&gt;<span class="built_in">SetSize</span>(merge_size);</span><br><span class="line">      leaf_page-&gt;<span class="built_in">SetNextPageId</span>(right_brother_page-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">      <span class="built_in">RemoveFromParent</span>(index + <span class="number">1</span>, ctx, ctx.write_set_.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// borrow</span></span><br><span class="line">      leaf_page-&gt;<span class="built_in">GetArray</span>()[leaf_page-&gt;<span class="built_in">GetSize</span>()] = right_brother_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>];</span><br><span class="line">      std::<span class="built_in">copy</span>(right_brother_page-&gt;<span class="built_in">GetArray</span>() + <span class="number">1</span>, right_brother_page-&gt;<span class="built_in">GetArray</span>() + right_brother_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                right_brother_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">      leaf_page-&gt;<span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">      right_brother_page-&gt;<span class="built_in">SetSize</span>(right_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">      parent_page-&gt;<span class="built_in">SetKeyAt</span>(index + <span class="number">1</span>, right_brother_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 左brother</span></span><br><span class="line">    <span class="built_in">BUSTUB_ASSERT</span>(index - <span class="number">1</span> &gt;= <span class="number">0</span>, <span class="string">&quot;left brother must exist&quot;</span>);</span><br><span class="line">    <span class="type">page_id_t</span> left_brother_page_id = parent_page-&gt;<span class="built_in">GetArray</span>()[index - <span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">auto</span> left_brother_page_guard = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(left_brother_page_id);</span><br><span class="line">    <span class="keyword">auto</span> left_brother_page = left_brother_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge_size = left_brother_page-&gt;<span class="built_in">GetSize</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">    <span class="keyword">if</span> (merge_size &lt; left_brother_page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 可以合并</span></span><br><span class="line">      <span class="comment">// merge</span></span><br><span class="line">      std::<span class="built_in">copy</span>(leaf_page-&gt;<span class="built_in">GetArray</span>(), leaf_page-&gt;<span class="built_in">GetArray</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                left_brother_page-&gt;<span class="built_in">GetArray</span>() + left_brother_page-&gt;<span class="built_in">GetSize</span>());</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetSize</span>(merge_size);</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetNextPageId</span>(leaf_page-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">      <span class="built_in">RemoveFromParent</span>(index, ctx, ctx.write_set_.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// borrow</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = leaf_page-&gt;<span class="built_in">GetSize</span>(); i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        leaf_page-&gt;<span class="built_in">GetArray</span>()[i] = leaf_page-&gt;<span class="built_in">GetArray</span>()[i - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      leaf_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>] = left_brother_page-&gt;<span class="built_in">GetArray</span>()[left_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>];</span><br><span class="line">      leaf_page-&gt;<span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetSize</span>(left_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">      parent_page-&gt;<span class="built_in">SetKeyAt</span>(index, leaf_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.<span class="built_in">Drop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPLUSTREE_TYPE::RemoveFromParent</span><span class="params">(<span class="type">int</span> valueIndex, Context &amp;ctx, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;page_guard = ctx.write_set_[index];</span><br><span class="line">  <span class="keyword">auto</span> page = page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = valueIndex + <span class="number">1</span>; i &lt; page-&gt;<span class="built_in">GetSize</span>(); ++i) &#123;  <span class="comment">// 删除key value</span></span><br><span class="line">    page-&gt;<span class="built_in">GetArray</span>()[i - <span class="number">1</span>] = page-&gt;<span class="built_in">GetArray</span>()[i];</span><br><span class="line">  &#125;</span><br><span class="line">  page-&gt;<span class="built_in">SetSize</span>(page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);  <span class="comment">// 更新page的size</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">GetSize</span>() &gt;= page-&gt;<span class="built_in">GetMinSize</span>()) &#123;  <span class="comment">// 无underflow</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// underflow</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="built_in">IsRootPage</span>(page_guard.<span class="built_in">PageId</span>())) &#123;  <span class="comment">// 该page是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;<span class="built_in">GetSize</span>() == <span class="number">1</span>) &#123;               <span class="comment">// 根节点需要更换了</span></span><br><span class="line">      <span class="built_in">BUSTUB_ASSERT</span>(ctx.header_page_ != std::<span class="literal">nullopt</span>, <span class="string">&quot;ctx.header_page must exist&quot;</span>);</span><br><span class="line">      <span class="keyword">auto</span> header_page = ctx.header_page_-&gt;<span class="built_in">AsMut</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">      header_page-&gt;root_page_id_ = page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(index - <span class="number">1</span> &gt;= <span class="number">0</span>, <span class="string">&quot;parent_page_guard must exist&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> &amp;parent_page_guard = ctx.write_set_[index - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">auto</span> parent_page = parent_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">auto</span> pos = parent_page-&gt;<span class="built_in">ValueIndex</span>(page_guard.<span class="built_in">PageId</span>());</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(pos != <span class="number">-1</span>, <span class="string">&quot;pos must not be -1&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果有右brother</span></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; parent_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">page_id_t</span> right_brother_page_id = parent_page-&gt;<span class="built_in">GetArray</span>()[pos + <span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">auto</span> right_brother_page_guard = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(right_brother_page_id);</span><br><span class="line">    <span class="keyword">auto</span> right_brother_page = right_brother_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge_size = right_brother_page-&gt;<span class="built_in">GetSize</span>() + page-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">    <span class="keyword">if</span> (merge_size &lt;= page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 可以合并</span></span><br><span class="line">      <span class="comment">// merge</span></span><br><span class="line">      std::<span class="built_in">copy</span>(right_brother_page-&gt;<span class="built_in">GetArray</span>(), right_brother_page-&gt;<span class="built_in">GetArray</span>() + right_brother_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                page-&gt;<span class="built_in">GetArray</span>() + page-&gt;<span class="built_in">GetSize</span>());</span><br><span class="line">      page-&gt;<span class="built_in">SetSize</span>(merge_size);</span><br><span class="line">      <span class="built_in">RemoveFromParent</span>(pos + <span class="number">1</span>, ctx, index - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// borrow</span></span><br><span class="line">      page-&gt;<span class="built_in">GetArray</span>()[page-&gt;<span class="built_in">GetSize</span>()] = right_brother_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>];</span><br><span class="line">      std::<span class="built_in">copy</span>(right_brother_page-&gt;<span class="built_in">GetArray</span>() + <span class="number">1</span>, right_brother_page-&gt;<span class="built_in">GetArray</span>() + right_brother_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                right_brother_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">      page-&gt;<span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">      right_brother_page-&gt;<span class="built_in">SetSize</span>(right_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">      parent_page-&gt;<span class="built_in">SetKeyAt</span>(pos + <span class="number">1</span>, right_brother_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 左brother</span></span><br><span class="line">    <span class="built_in">BUSTUB_ASSERT</span>(pos - <span class="number">1</span> &gt;= <span class="number">0</span>, <span class="string">&quot;left brother must exist&quot;</span>);</span><br><span class="line">    <span class="type">page_id_t</span> left_brother_page_id = parent_page-&gt;<span class="built_in">GetArray</span>()[pos - <span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">auto</span> left_brother_page_guard = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(left_brother_page_id);</span><br><span class="line">    <span class="keyword">auto</span> left_brother_page = left_brother_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge_size = left_brother_page-&gt;<span class="built_in">GetSize</span>() + page-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">    <span class="keyword">if</span> (merge_size &lt;= left_brother_page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 可以合并</span></span><br><span class="line">      <span class="comment">// merge</span></span><br><span class="line">      std::<span class="built_in">copy</span>(page-&gt;<span class="built_in">GetArray</span>(), page-&gt;<span class="built_in">GetArray</span>() + page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                left_brother_page-&gt;<span class="built_in">GetArray</span>() + left_brother_page-&gt;<span class="built_in">GetSize</span>());</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetSize</span>(merge_size);</span><br><span class="line">      <span class="built_in">RemoveFromParent</span>(pos, ctx, index - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// borrow</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = page-&gt;<span class="built_in">GetSize</span>(); i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        page-&gt;<span class="built_in">GetArray</span>()[i] = page-&gt;<span class="built_in">GetArray</span>()[i - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>] = left_brother_page-&gt;<span class="built_in">GetArray</span>()[left_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>];</span><br><span class="line">      page-&gt;<span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetSize</span>(left_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">      parent_page-&gt;<span class="built_in">SetKeyAt</span>(pos, page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Task-3-Index-Iterator"><a href="#Task-3-Index-Iterator" class="headerlink" title="Task #3 Index Iterator"></a>Task #3 Index Iterator</h2><p>Index Iterator 代码实现：</p>
<blockquote>
<p>Index Iterator的实现只需要支持单线程</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">INDEXITERATOR_TYPE::IsEnd</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">bool</span> </span>&#123; <span class="keyword">return</span> read_guard_ == std::<span class="literal">nullopt</span>; &#125;</span><br><span class="line"></span><br><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">auto</span> INDEXITERATOR_TYPE::<span class="keyword">operator</span>*() -&gt; <span class="type">const</span> MappingType &amp; &#123;</span><br><span class="line">  <span class="keyword">auto</span> page = read_guard_-&gt;<span class="built_in">As</span>&lt;B_PLUS_TREE_LEAF_PAGE_TYPE&gt;();</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(page-&gt;<span class="built_in">GetSize</span>() &gt; index_, <span class="string">&quot;index_ must be valid&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> page-&gt;<span class="built_in">GetArray</span>()[index_];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">auto</span> INDEXITERATOR_TYPE::<span class="keyword">operator</span>++() -&gt; INDEXITERATOR_TYPE &amp; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsEnd</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> leaf_page = read_guard_-&gt;<span class="built_in">As</span>&lt;B_PLUS_TREE_LEAF_PAGE_TYPE&gt;();</span><br><span class="line">  <span class="keyword">if</span> (index_ + <span class="number">1</span> &lt; leaf_page-&gt;<span class="built_in">GetSize</span>()) &#123;</span><br><span class="line">    index_++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">GetNextPageId</span>() != INVALID_PAGE_ID) &#123;</span><br><span class="line">    read_guard_ = bpm_-&gt;<span class="built_in">FetchPageRead</span>(leaf_page-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">    index_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  read_guard_ = std::<span class="literal">nullopt</span>;</span><br><span class="line">  index_ = INVALID_PAGE_ID;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>==(<span class="type">const</span> IndexIterator &amp;itr) <span class="type">const</span> -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEnd</span>() &amp;&amp; itr.<span class="built_in">IsEnd</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEnd</span>() || itr.<span class="built_in">IsEnd</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> read_guard_-&gt;<span class="built_in">PageId</span>() == itr.read_guard_-&gt;<span class="built_in">PageId</span>() &amp;&amp; index_ == itr.index_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>!=(<span class="type">const</span> IndexIterator &amp;itr) <span class="type">const</span> -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == itr); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BplusTree实现Begin和End函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::Begin</span><span class="params">()</span> -&gt; INDEXITERATOR_TYPE </span>&#123;</span><br><span class="line">  Context ctx;</span><br><span class="line">  <span class="keyword">auto</span> header_page_guard = bpm_-&gt;<span class="built_in">FetchPageRead</span>(header_page_id_);</span><br><span class="line">  <span class="keyword">auto</span> header_page = header_page_guard.<span class="built_in">As</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">  ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(ctx.root_page_id_));</span><br><span class="line">  header_page_guard.<span class="built_in">Drop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">  <span class="keyword">while</span> (!page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> internal = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;InternalPage&gt;();</span><br><span class="line">    <span class="type">page_id_t</span> id = internal-&gt;<span class="built_in">ValueAt</span>(<span class="number">0</span>);</span><br><span class="line">    ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(id));</span><br><span class="line">    ctx.read_set_.<span class="built_in">pop_front</span>();</span><br><span class="line">    page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>(bpm_, std::<span class="built_in">move</span>(ctx.read_set_.<span class="built_in">back</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::Begin</span><span class="params">(<span class="type">const</span> KeyType &amp;key)</span> -&gt; INDEXITERATOR_TYPE </span>&#123;</span><br><span class="line">  Context ctx;</span><br><span class="line">  <span class="keyword">auto</span> header_page_guard = bpm_-&gt;<span class="built_in">FetchPageRead</span>(header_page_id_);</span><br><span class="line">  <span class="keyword">auto</span> header_page = header_page_guard.<span class="built_in">As</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">  ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(ctx.root_page_id_));</span><br><span class="line">  header_page_guard.<span class="built_in">Drop</span>();</span><br><span class="line">  <span class="built_in">FindLeafPage</span>(key, Operation::Search, ctx);</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;LeafPage&gt;()-&gt;<span class="built_in">KeyIndex</span>(key, comparator_, pos)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;key not exist&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>(bpm_, std::<span class="built_in">move</span>(ctx.read_set_.<span class="built_in">back</span>()), pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::End</span><span class="params">()</span> -&gt; INDEXITERATOR_TYPE </span>&#123; <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>(); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Task-4-Concurrency-Control"><a href="#Task-4-Concurrency-Control" class="headerlink" title="Task #4 Concurrency Control"></a>Task #4 Concurrency Control</h2><h3 id="Latch-Crabbing-Coupling"><a href="#Latch-Crabbing-Coupling" class="headerlink" title="Latch Crabbing&#x2F;Coupling"></a>Latch Crabbing&#x2F;Coupling<br></h3><p>Latch Crabbing 的基本思想如下：<br></p>
<ol>
<li>获取 parent 的 latch<br></li>
<li>获取 child 的 latch<br></li>
<li>如果安全，则可以释放 parent 的 latch</li>
</ol>
<p>这里的“安全”指的是，当发生更新操作时，该节点不会发生 split 或 merge 的操作，即：</p>
<ul>
<li>在插入元素时，节点未满</li>
<li>在删除元素时，节点超过半满</li>
</ul>
<p>Search<br>从 root 往下，不断地：</p>
<ul>
<li>获取 child 的 read latch</li>
<li>释放 parent 的 read latch</li>
</ul>
<p><img src="/../images/cmu15445-project2/8.png" alt="img"><br><img src="/../images/cmu15445-project2/9.png" alt="img"><br><img src="/../images/cmu15445-project2/10.png" alt="img"><br><img src="/../images/cmu15445-project2/11.png" alt="img"><br><img src="/../images/cmu15445-project2/12.png" alt="img"></p>
<p>Insert&#x2F;Delete<br><br>从 root 往下，按照需要获取 write latch，一旦获取了 child 的 write latch，检查它是否安全，如果安全，则释放之前获取的所有 write latch。<br>安全判断函数逻辑见函数IsSafePage<br></p>
<h3 id="Better-Latching-Algorithm"><a href="#Better-Latching-Algorithm" class="headerlink" title="Better Latching Algorithm"></a>Better Latching Algorithm<br></h3><ul>
<li>Search：与 Latch Crabbing 相同<br></li>
<li>Insert&#x2F;Delete:<br><ul>
<li>使用与 Search 相同的方式在查询路径上获取、释放 latch，在 leaf node 上获取 write latch<br></li>
<li>如果 leaf node 不安全，可能会引起其它节点的变动，则使用 Latch Crabbing 的策略再执行一遍<br></li>
</ul>
</li>
</ul>
<p>该方法乐观地假设整个操作只会引起 leaf node 的变化，若假设错误，则使用 Latch Crabbing 的原始方案。<br></p>
<p>CheckPoint#2本地测试<br><br><img src="/../images/cmu15445-project2/13.png" alt="img"><br><img src="/../images/cmu15445-project2/14.png" alt="img"><br><img src="/../images/cmu15445-project2/15.png" alt="img"><br><img src="/../images/cmu15445-project2/16.png" alt="img"></p>
<p><a href="https://15445.courses.cs.cmu.edu/spring2023/bpt-printer/">Bustub Tree printer</a><br></p>
<p>CheckPoint#2线上测试<br><br><img src="/../images/cmu15445-project2/7.png" alt="img"></p>
]]></content>
      <categories>
        <category>cmu15445-2023</category>
      </categories>
      <tags>
        <tag>cmu15445—2023</tag>
      </tags>
  </entry>
  <entry>
    <title>cmu15445-project3</title>
    <url>/2024/02/27/cmu15445-project3/</url>
    <content><![CDATA[<h2 id="Query-Processing-Model"><a href="#Query-Processing-Model" class="headerlink" title="Query Processing Model"></a>Query Processing Model</h2><p>OLAP与OLTP数据库</p>
<ul>
<li>OLAP数据库架构将数据读取优先于数据写入操作。可以快速地对大量数据执行复杂的查询</li>
<li>OLTP数据库架构将数据写入优先于数据读取操作。它针对写入密集型工作负载进行了优化</li>
</ul>
<p>example:<br><br>以一家大型零售公司为例。该公司有一个庞大的数据库，用于跟踪销售、库存、客户数据等</p>
<ul>
<li>使用OLTP数据库实时处理交易、更新库存水平和管理客户账户</li>
<li>使用OLAP数据库来分析有关销售趋势、库存水平、客户人口统计等</li>
</ul>
<hr>
<p>DBMS的Processing Model定义了系统如何执行一个query plan,目前主要有三种模型</p>
<ul>
<li>Iterator Model</li>
<li>Materialization Model</li>
<li>Vectorized&#x2F;Batch Model</li>
</ul>
<h3 id="Iterator-Model"><a href="#Iterator-Model" class="headerlink" title="Iterator Model"></a>Iterator Model</h3><p>query plan 中的每步 operator 都实现一个 next 函数，每次调用时，operator 返回一个 tuple 或者 null，后者表示数据已经遍历完毕。operator 本身实现一个循环，每次调用其 child operators 的 next 函数，从它们那边获取下一条数据供自己操作，这样整个 query plan 就被从上至下地串联起来，它也称为 Volcano&#x2F;Pipeline Model：<br><img src="/../images/cmu15445-project3/1.png" alt="img"><br>Iterator 几乎被用在每个 DBMS 中，包括 sqlite、MySQL、PostgreSQL 等等，其它需要注意的是:</p>
<ul>
<li>有些 operators 会等待 children 返回所有 tuples 后才执行，如 Joins, Subqueries 和 Order By</li>
<li>Output Control 在 Iterator Model 中比较容易，如 Limit，只按需调用 next 即可</li>
</ul>
<h3 id="Materialization-Model"><a href="#Materialization-Model" class="headerlink" title="Materialization Model"></a>Materialization Model</h3><p>每个 operator 处理完所有输入后，将所有结果一次性输出，DBMS 会将一些参数传递到 operator 中防止处理过多的数据，这是一种从下至上的思路，示意如下：<br><img src="/../images/cmu15445-project3/2.png" alt="img"><br>materialization model：</p>
<ul>
<li>更适合 OLTP 场景，因为后者通常指需要处理少量的 tuples，这样能减少不必要的执行、调度成本</li>
<li>不太适合会产生大量中间结果的 OLAP 查询</li>
</ul>
<h3 id="Vectorization-Model"><a href="#Vectorization-Model" class="headerlink" title="Vectorization Model"></a>Vectorization Model</h3><p>Vectorization Model 是 Iterator 与 Materialization Model 折衷的一种模型：</p>
<ul>
<li>每个 operator 实现一个 next 函数，但每次 next 调用返回一批 tuples，而不是单个 tuple</li>
<li>operator 内部的循环每次也是一批一批 tuples 地处理</li>
<li>batch 的大小可以根据需要改变（hardware、query properties)<br><br><img src="/../images/cmu15445-project3/3.png" alt="img"></li>
</ul>
<p>vectorization model 是 OLAP 查询的理想模型:</p>
<ul>
<li>极大地减少每个 operator 的调用次数</li>
<li>允许 operators 使用 vectorized instructions (SIMD) 来批量处理 tuples</li>
</ul>
<h2 id="BACKGROUND：QUERY-PROCESSING"><a href="#BACKGROUND：QUERY-PROCESSING" class="headerlink" title="BACKGROUND：QUERY PROCESSING"></a>BACKGROUND：QUERY PROCESSING</h2><p>BusTub架构如下<br><img src="/../images/cmu15445-project3/4.png" alt="img"></p>
<h3 id="note"><a href="#note" class="headerlink" title="note:"></a>note:</h3><ul>
<li>BusTub只支持SQL的一个小子集，可以通过tests&#x2F;sql中的SQLLogicTest文件来查看它所支持的SQL语句</li>
<li>如果你使用Clion来运行Bustub shell，添加–disable-tty参数</li>
<li>SQL语句使用;结尾</li>
<li>BusTub只支持INT和VARCHAR(n)类型，字符串使用单引号</li>
<li>Bustub使用Iterator Porcessing Model</li>
</ul>
<h3 id="Inspecting-SQL-query-plans"><a href="#Inspecting-SQL-query-plans" class="headerlink" title="Inspecting SQL query plans"></a>Inspecting SQL query plans</h3><p>BusTub支持EXPLAIN来打印SQL查询计划<br><img src="/../images/cmu15445-project3/5.png" alt="img"><br>EXPLAIN会展示query processing这一层的转换过程 Parser -&gt; Binder -&gt; Planner -&gt; Optimizer<br><br>Parser解析SQL语句生成Binder AST语法树，接着生成query plan，然后由Optimizer优化query plan生成executor树</p>
<h2 id="Task-1-Access-Method-Executors"><a href="#Task-1-Access-Method-Executors" class="headerlink" title="Task#1 Access Method Executors"></a>Task#1 Access Method Executors</h2><p>我们并不需要关心query plan是如何创建的；但有必要理解query plan的组成结构:这是棵树，每个plan节点都对应具体的算子，Bustub采用iterator procesing model，也就是Top-to-Bottom的火山模型，因此query plan的执行就是从根节点开始，将plan节点转换为对应的算子</p>
<p>Plan节点的类型如下<br><img src="/../images/cmu15445-project3/6.png" alt="img"><br>还是有必要阅读一些相关代码<br></p>
<p>表Table的元信息</p>
<blockquote>
<p>其中TableHeap代表磁盘上的一张表，是一个doubly-linked of pages</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TableInfo</span> &#123;</span><br><span class="line">  <span class="comment">/** The table schema */</span></span><br><span class="line">  Schema schema_;</span><br><span class="line">  <span class="comment">/** The table name */</span></span><br><span class="line">  <span class="type">const</span> std::string name_;</span><br><span class="line">  <span class="comment">/** An owning pointer to the table heap */</span></span><br><span class="line">  std::unique_ptr&lt;TableHeap&gt; table_;</span><br><span class="line">  <span class="comment">/** The table OID */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">table_oid_t</span> oid_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TableHeap</span> &#123;</span><br><span class="line">  <span class="type">page_id_t</span> first_page_id_&#123;INVALID_PAGE_ID&#125;;</span><br><span class="line">  <span class="type">page_id_t</span> last_page_id_&#123;INVALID_PAGE_ID&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>索引Index的元信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexInfo</span> &#123;</span><br><span class="line">  <span class="comment">/** The schema for the index key */</span></span><br><span class="line">  Schema key_schema_;</span><br><span class="line">  <span class="comment">/** The name of the index */</span></span><br><span class="line">  std::string name_;</span><br><span class="line">  <span class="comment">/** An owning pointer to the index */</span></span><br><span class="line">  std::unique_ptr&lt;Index&gt; index_;</span><br><span class="line">  <span class="comment">/** The unique OID for the index */</span></span><br><span class="line">  <span class="type">index_oid_t</span> index_oid_;</span><br><span class="line">  <span class="comment">/** The name of the table on which the index is created */</span></span><br><span class="line">  std::string table_name_;</span><br><span class="line">  <span class="comment">/** The size of the index key, in bytes */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> key_size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>catalog<br></p>
<blockquote>
<p>记录所有TableInfo和IndexInfo</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Catalog</span> &#123;</span><br><span class="line">  std::unordered_map&lt;<span class="type">table_oid_t</span>, std::unique_ptr&lt;TableInfo&gt;&gt; tables_;</span><br><span class="line">  <span class="comment">/** Map table name -&gt; table identifiers. */</span></span><br><span class="line">  std::unordered_map&lt;std::string, <span class="type">table_oid_t</span>&gt; table_names_;</span><br><span class="line">  </span><br><span class="line">  std::unordered_map&lt;<span class="type">index_oid_t</span>, std::unique_ptr&lt;IndexInfo&gt;&gt; indexes_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Map table name -&gt; index names -&gt; index identifiers. */</span></span><br><span class="line">  std::unordered_map&lt;std::string, std::unordered_map&lt;std::string, <span class="type">index_oid_t</span>&gt;&gt; index_names_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="SeqScanExecutor实现"><a href="#SeqScanExecutor实现" class="headerlink" title="SeqScanExecutor实现"></a>SeqScanExecutor实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加数据成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqScanExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> SeqScanPlanNode *plan_;<span class="comment">//对应的SeqScanPlanNode</span></span><br><span class="line">  TableInfo *table_info_;<span class="comment">//扫描的table</span></span><br><span class="line">  std::unique_ptr&lt;TableIterator&gt; iterator_;<span class="comment">//TableIterator</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SeqScanExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = catalog-&gt;<span class="built_in">GetTable</span>(plan_-&gt;table_oid_);<span class="comment">//获取TableInfo</span></span><br><span class="line">  iterator_ = std::<span class="built_in">make_unique</span>&lt;TableIterator&gt;(table_info_-&gt;table_-&gt;<span class="built_in">MakeIterator</span>());<span class="comment">//获取对应Table的TableIterator</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SeqScanExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  std::pair&lt;TupleMeta, Tuple&gt; pair;</span><br><span class="line">  <span class="keyword">while</span> (!iterator_-&gt;<span class="built_in">IsEnd</span>()) &#123;<span class="comment">//如果未遍历完Table</span></span><br><span class="line">    pair = iterator_-&gt;<span class="built_in">GetTuple</span>();<span class="comment">//获取一个TupleMeta-Tuple pair</span></span><br><span class="line">    <span class="keyword">if</span> (pair.first.is_deleted_) &#123;<span class="comment">//如果该TupleMeta标记Tuple为已删除</span></span><br><span class="line">      ++(*iterator_);<span class="comment">//跳过</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (plan_-&gt;filter_predicate_) &#123;<span class="comment">//如果该算子对应的SeqScanPlanNode含有filter_predicate表达式</span></span><br><span class="line">      <span class="keyword">auto</span> res = plan_-&gt;filter_predicate_-&gt;<span class="built_in">Evaluate</span>(&amp;pair.second, table_info_-&gt;schema_);</span><br><span class="line">      <span class="keyword">if</span> (!(!res.<span class="built_in">IsNull</span>() &amp;&amp; res.<span class="built_in">GetAs</span>&lt;<span class="type">bool</span>&gt;())) &#123;<span class="comment">//如果该Tuple不满足该filter_predicate表达式</span></span><br><span class="line">        ++(*iterator_);<span class="comment">//跳过</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++(*iterator_);<span class="comment">//迭代器前进一步</span></span><br><span class="line">    *tuple = std::<span class="built_in">move</span>(pair.second);</span><br><span class="line">    *rid = tuple-&gt;<span class="built_in">GetRid</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InsertExecutor实现"><a href="#InsertExecutor实现" class="headerlink" title="InsertExecutor实现"></a>InsertExecutor实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加数据成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InsertExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> InsertPlanNode *plan_;<span class="comment">//对应的InsertPlanNode</span></span><br><span class="line">  <span class="type">bool</span> successful_;<span class="comment">//是否插入成功</span></span><br><span class="line">  TableInfo *table_info_;<span class="comment">//插入的Table</span></span><br><span class="line">  std::vector&lt;IndexInfo *&gt; index_infos_;<span class="comment">//该Table对应的Index，如果Table变更，索引也需更改</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;<span class="comment">//一个孩子executor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  <span class="keyword">auto</span> cata_log = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = cata_log-&gt;<span class="built_in">GetTable</span>(plan_-&gt;table_oid_);</span><br><span class="line">  index_infos_ = cata_log-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">  successful_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">InsertExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  TupleMeta meta;</span><br><span class="line">  <span class="keyword">if</span> (successful_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  meta.insert_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  meta.delete_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  meta.is_deleted_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;<span class="comment">//从孩子executor获取tuple</span></span><br><span class="line">    <span class="keyword">auto</span> tuple_rid = table_info_-&gt;table_-&gt;<span class="built_in">InsertTuple</span>(meta, *tuple, exec_ctx_-&gt;<span class="built_in">GetLockManager</span>(), exec_ctx_-&gt;<span class="built_in">GetTransaction</span>(), table_info_-&gt;oid_);<span class="comment">//插入Table</span></span><br><span class="line">    <span class="keyword">if</span> (tuple_rid == std::<span class="literal">nullopt</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新该Table的所有索引结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;</span><br><span class="line">      <span class="keyword">auto</span> key = tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(key, *tuple_rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ++count;<span class="comment">//插入记录count++</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">emplace_back</span>(TypeId::INTEGER, count);</span><br><span class="line">  *tuple = <span class="built_in">Tuple</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());<span class="comment">//入参tuple返回插入的记录的数量</span></span><br><span class="line">  successful_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UpdateExecutor实现"><a href="#UpdateExecutor实现" class="headerlink" title="UpdateExecutor实现"></a>UpdateExecutor实现</h3><blockquote>
<p>这里实现的思路就是将旧的Tuple删除，插入新的Tuple</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加数据成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpdateExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> UpdatePlanNode *plan_;<span class="comment">//对应的UpdatePlanNode</span></span><br><span class="line">  <span class="comment">/** Metadata identifying the table that should be updated */</span></span><br><span class="line">  <span class="type">const</span> TableInfo *table_info_;<span class="comment">//要update的table</span></span><br><span class="line">  <span class="comment">/** The child executor to obtain value from */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;<span class="comment">//孩子executor</span></span><br><span class="line"></span><br><span class="line">  std::vector&lt;IndexInfo *&gt; index_infos_;<span class="comment">//该Table上的所有index</span></span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> successful_;<span class="comment">//更新是否成功</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  successful_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> cata_log = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = cata_log-&gt;<span class="built_in">GetTable</span>(plan_-&gt;<span class="built_in">TableOid</span>());</span><br><span class="line">  index_infos_ = cata_log-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">UpdateExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  TupleMeta tuple_meta;</span><br><span class="line">  <span class="keyword">if</span> (successful_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tuple_meta.delete_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  tuple_meta.insert_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  <span class="keyword">auto</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;<span class="comment">//从孩子executor拿到需要更新的tuple</span></span><br><span class="line">    <span class="comment">// 删除tuple</span></span><br><span class="line">    tuple_meta.is_deleted_ = <span class="literal">true</span>;</span><br><span class="line">    table_info_-&gt;table_-&gt;<span class="built_in">UpdateTupleMeta</span>(tuple_meta, *rid);<span class="comment">//将Table中相同rid的Tuple标记为删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;<span class="comment">//将Table对应的Index中与该Tuple对应的key删除</span></span><br><span class="line">      <span class="keyword">auto</span> key = tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">DeleteEntry</span>(key, *rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的tuple</span></span><br><span class="line">    std::vector&lt;Value&gt; values;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;expresssion : plan_-&gt;target_expressions_) &#123;</span><br><span class="line">      values.<span class="built_in">emplace_back</span>(expresssion-&gt;<span class="built_in">Evaluate</span>(tuple, child_executor_-&gt;<span class="built_in">GetOutputSchema</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> new_tuple = <span class="built_in">Tuple</span>(values, &amp;child_executor_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    <span class="comment">// 插入新的tuple</span></span><br><span class="line">    tuple_meta.is_deleted_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> tuple_rid = table_info_-&gt;table_-&gt;<span class="built_in">InsertTuple</span>(tuple_meta, new_tuple, exec_ctx_-&gt;<span class="built_in">GetLockManager</span>(), exec_ctx_-&gt;<span class="built_in">GetTransaction</span>(), table_info_-&gt;oid_);</span><br><span class="line">    <span class="keyword">if</span> (tuple_rid == std::<span class="literal">nullopt</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;</span><br><span class="line">      <span class="keyword">auto</span> key = new_tuple.<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(key, *tuple_rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());<span class="comment">//Index插入key</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">emplace_back</span>(TypeId::INTEGER, count);</span><br><span class="line">  *tuple = &#123;values, &amp;<span class="built_in">GetOutputSchema</span>()&#125;;<span class="comment">//入参tuple返回update的参数个数</span></span><br><span class="line">  successful_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DeleteExecutor实现"><a href="#DeleteExecutor实现" class="headerlink" title="DeleteExecutor实现"></a>DeleteExecutor实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeleteExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> DeletePlanNode *plan_;<span class="comment">//对应的DeletePlanNode</span></span><br><span class="line">  <span class="comment">/** The child executor from which RIDs for deleted tuples are pulled */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;<span class="comment">//孩子DeleteExecutor</span></span><br><span class="line">  <span class="type">bool</span> successful_;<span class="comment">//判断删除是否成功</span></span><br><span class="line">  TableInfo *table_info_;<span class="comment">//删除的Table</span></span><br><span class="line">  std::vector&lt;IndexInfo *&gt; index_infos_;<span class="comment">//Table对应的所有Index</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  successful_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = catalog-&gt;<span class="built_in">GetTable</span>(plan_-&gt;<span class="built_in">TableOid</span>());</span><br><span class="line">  index_infos_ = catalog-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">DeleteExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  TupleMeta tuple_meta;</span><br><span class="line">  <span class="keyword">if</span> (successful_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tuple_meta.delete_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  tuple_meta.insert_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  tuple_meta.is_deleted_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">auto</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;<span class="comment">//从孩子节点获取tuple</span></span><br><span class="line">    table_info_-&gt;table_-&gt;<span class="built_in">UpdateTupleMeta</span>(tuple_meta, *rid);<span class="comment">//删除Table中对应的Tuple，标记为删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;<span class="comment">//删除该Table上所有Index中与该Tuple对应的key</span></span><br><span class="line">      <span class="keyword">auto</span> key = tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">DeleteEntry</span>(key, *rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    count++;<span class="comment">//删除计数count++</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">emplace_back</span>(TypeId::INTEGER, count);</span><br><span class="line">  *tuple = <span class="built_in">Tuple</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());<span class="comment">//入参tuple返回删除的tuple数量</span></span><br><span class="line">  successful_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IndexScanExecutor实现"><a href="#IndexScanExecutor实现" class="headerlink" title="IndexScanExecutor实现"></a>IndexScanExecutor实现</h3><p>SELECT FROM <table> ORDER BY <index column>中的ORDER BY会被转为IndexScan<br></index></table></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加数据成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexScanExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> IndexScanPlanNode *plan_;<span class="comment">//对应的IndexScanPlanNode</span></span><br><span class="line">  IndexInfo *index_info_;<span class="comment">//IndexInfo</span></span><br><span class="line">  TableInfo *table_info_;<span class="comment">//TableInfo</span></span><br><span class="line">  BPlusTreeIndexForTwoIntegerColumn *index_;<span class="comment">//扫描的Index</span></span><br><span class="line">  std::unique_ptr&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt; index_iterator_;<span class="comment">//扫描的Index的IndexIterator</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexScanExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  index_info_ = catalog-&gt;<span class="built_in">GetIndex</span>(plan_-&gt;index_oid_);<span class="comment">//获取对应的Index_Info</span></span><br><span class="line">  table_info_ = catalog-&gt;<span class="built_in">GetTable</span>(index_info_-&gt;table_name_);<span class="comment">//获取对应的Table_Info</span></span><br><span class="line">  index_ = <span class="built_in">dynamic_cast</span>&lt;BPlusTreeIndexForTwoIntegerColumn *&gt;(index_info_-&gt;index_.<span class="built_in">get</span>());</span><br><span class="line">  index_iterator_ = std::<span class="built_in">make_unique</span>&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt;(index_-&gt;<span class="built_in">GetBeginIterator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">IndexScanExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!index_iterator_-&gt;<span class="built_in">IsEnd</span>()) &#123;<span class="comment">//遍历Index</span></span><br><span class="line">    <span class="keyword">auto</span> map = *(*index_iterator_);</span><br><span class="line">    *rid = map.second;<span class="comment">//拿到rid</span></span><br><span class="line">    <span class="keyword">if</span> (!table_info_-&gt;table_-&gt;<span class="built_in">GetTupleMeta</span>(*rid).is_deleted_) &#123;  <span class="comment">// 未被删除</span></span><br><span class="line">      index_iterator_-&gt;<span class="keyword">operator</span>++();</span><br><span class="line">      *tuple = table_info_-&gt;table_-&gt;<span class="built_in">GetTuple</span>(*rid).second;<span class="comment">//入参tuple返回rid指向的tuple</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index_iterator_-&gt;<span class="keyword">operator</span>++();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过SQLLogicTests#1 to #6<br><img src="/../images/cmu15445-project3/10.png" alt="img"><br><img src="/../images/cmu15445-project3/11.png" alt="img"><br><img src="/../images/cmu15445-project3/12.png" alt="img"><br><img src="/../images/cmu15445-project3/13.png" alt="img"><br><img src="/../images/cmu15445-project3/14.png" alt="img"><br><img src="/../images/cmu15445-project3/15.png" alt="img"></p>
<h2 id="Task-2-Aggregation-Join-Executors"><a href="#Task-2-Aggregation-Join-Executors" class="headerlink" title="Task#2 Aggregation &amp; Join Executors"></a>Task#2 Aggregation &amp; Join Executors</h2><h3 id="AggregationExecutor实现"><a href="#AggregationExecutor实现" class="headerlink" title="AggregationExecutor实现"></a>AggregationExecutor实现</h3><blockquote>
<p>AggregationExecutor用来支持以下的sql查询，第四条sql语句的DISTINCT相当于GROUP BY<br><br>AggregationExecutor不需要处理HAVING语句，planner会让AggregationPlanNode跟着一个FilterPlanNode<br><img src="/../images/cmu15445-project3/7.png" alt="img"></p>
</blockquote>
<p>补充完成SimpleAggregationHashTable，其中哈希表的键AggregateKey就是GROUP BY的columns<br></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleAggregationHashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/** The hash table is just a map from aggregate keys to aggregate values */</span></span><br><span class="line">  std::unordered_map&lt;AggregateKey, AggregateValue&gt; ht_&#123;&#125;;</span><br><span class="line">  <span class="comment">/** The aggregate expressions that we have */</span></span><br><span class="line">  <span class="type">const</span> std::vector&lt;AbstractExpressionRef&gt; &amp;agg_exprs_;</span><br><span class="line">  <span class="comment">/** The types of aggregations that we have */</span></span><br><span class="line">  <span class="type">const</span> std::vector&lt;AggregationType&gt; &amp;agg_types_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">GenerateInitialAggregateValue</span><span class="params">()</span> -&gt; AggregateValue </span>&#123;</span><br><span class="line">    std::vector&lt;Value&gt; values&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;agg_type : agg_types_) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (agg_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::CountStarAggregate:</span><br><span class="line">          <span class="comment">// Count start starts at zero.</span></span><br><span class="line">          values.<span class="built_in">emplace_back</span>(ValueFactory::<span class="built_in">GetIntegerValue</span>(<span class="number">0</span>));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::CountAggregate:</span><br><span class="line">        <span class="keyword">case</span> AggregationType::SumAggregate:</span><br><span class="line">        <span class="keyword">case</span> AggregationType::MinAggregate:</span><br><span class="line">        <span class="keyword">case</span> AggregationType::MaxAggregate:</span><br><span class="line">          <span class="comment">// Others starts at null.</span></span><br><span class="line">          values.<span class="built_in">emplace_back</span>(ValueFactory::<span class="built_in">GetNullValueByType</span>(TypeId::INTEGER));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;values&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">CombineAggregateValues</span><span class="params">(AggregateValue *result, <span class="type">const</span> AggregateValue &amp;input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; agg_exprs_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (agg_types_[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::CountStarAggregate:<span class="comment">//count(*)统计null数量</span></span><br><span class="line">          result-&gt;aggregates_[i] = &#123;INTEGER, result-&gt;aggregates_[i].<span class="built_in">GetAs</span>&lt;<span class="type">int32_t</span>&gt;() + <span class="number">1</span>&#125;;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::CountAggregate:<span class="comment">//count()不统计null数量</span></span><br><span class="line">          <span class="keyword">if</span> (input.aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result-&gt;aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = &#123;INTEGER, <span class="number">1</span>&#125;;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = &#123;INTEGER, result-&gt;aggregates_[i].<span class="built_in">GetAs</span>&lt;<span class="type">int32_t</span>&gt;() + <span class="number">1</span>&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::SumAggregate:</span><br><span class="line">          <span class="keyword">if</span> (input.aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result-&gt;aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = input.aggregates_[i];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = result-&gt;aggregates_[i].<span class="built_in">Add</span>((input.aggregates_[i]));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::MinAggregate:</span><br><span class="line">          <span class="keyword">if</span> (input.aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result-&gt;aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = input.aggregates_[i];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = result-&gt;aggregates_[i].<span class="built_in">Min</span>(input.aggregates_[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::MaxAggregate:</span><br><span class="line">          <span class="keyword">if</span> (input.aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result-&gt;aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = input.aggregates_[i];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = result-&gt;aggregates_[i].<span class="built_in">Max</span>(input.aggregates_[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">InsertCombine</span><span class="params">(<span class="type">const</span> AggregateKey &amp;agg_key, <span class="type">const</span> AggregateValue &amp;agg_val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ht_.<span class="built_in">count</span>(agg_key) == <span class="number">0</span>) &#123;</span><br><span class="line">      ht_.<span class="built_in">insert</span>(&#123;agg_key, <span class="built_in">GenerateInitialAggregateValue</span>()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CombineAggregateValues</span>(&amp;ht_[agg_key], agg_val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> AggregateKey &amp;agg_key, <span class="type">const</span> AggregateValue &amp;agg_val)</span> </span>&#123; ht_.<span class="built_in">insert</span>(&#123;agg_key, agg_val&#125;); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AggregationExecutor</span> &#123;</span><br><span class="line">  <span class="comment">// 添加数据成员</span></span><br><span class="line">  <span class="type">const</span> AggregationPlanNode *plan_;</span><br><span class="line">  <span class="comment">/** The child executor that produces tuples over which the aggregation is computed */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_;</span><br><span class="line">  <span class="comment">/** Simple aggregation hash table */</span></span><br><span class="line">  SimpleAggregationHashTable aht_;</span><br><span class="line">  <span class="comment">/** Simple aggregation hash table iterator */</span></span><br><span class="line">  std::unique_ptr&lt;SimpleAggregationHashTable::Iterator&gt; aht_iterator_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AggregationExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple tuple;</span><br><span class="line">  RID rid;</span><br><span class="line">  <span class="keyword">while</span> (child_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;<span class="comment">//遍历孩子executor中所有的tuple</span></span><br><span class="line">    <span class="comment">//构建AggregateKey 和 AggregateValue 插入哈希表</span></span><br><span class="line">    AggregateKey key = <span class="built_in">MakeAggregateKey</span>(&amp;tuple);</span><br><span class="line">    AggregateValue value = <span class="built_in">MakeAggregateValue</span>(&amp;tuple);</span><br><span class="line">    aht_.<span class="built_in">InsertCombine</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (aht_.<span class="built_in">Begin</span>() == aht_.<span class="built_in">End</span>() &amp;&amp; plan_-&gt;<span class="built_in">GetGroupBys</span>().<span class="built_in">empty</span>()) &#123;  <span class="comment">// hash表为空,</span></span><br><span class="line">    AggregateKey key;</span><br><span class="line">    aht_.<span class="built_in">Insert</span>(key, aht_.<span class="built_in">GenerateInitialAggregateValue</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  aht_iterator_ = std::<span class="built_in">make_unique</span>&lt;SimpleAggregationHashTable::Iterator&gt;(aht_.<span class="built_in">Begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">AggregationExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((*aht_iterator_) == aht_.<span class="built_in">End</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> key = aht_iterator_-&gt;<span class="built_in">Key</span>();</span><br><span class="line">  <span class="keyword">auto</span> value = aht_iterator_-&gt;<span class="built_in">Val</span>();</span><br><span class="line">  ++(*aht_iterator_);<span class="comment">//迭代器++</span></span><br><span class="line">  key.group_bys_.<span class="built_in">insert</span>(key.group_bys_.<span class="built_in">end</span>(), value.aggregates_.<span class="built_in">begin</span>(), value.aggregates_.<span class="built_in">end</span>());</span><br><span class="line">  *tuple = &#123;key.group_bys_, &amp;<span class="built_in">GetOutputSchema</span>()&#125;;<span class="comment">//key和value合并后由入参tuple返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="NestedLoopJoinExecutor实现"><a href="#NestedLoopJoinExecutor实现" class="headerlink" title="NestedLoopJoinExecutor实现"></a>NestedLoopJoinExecutor实现</h3><p>NestedLoopJoinExecutor将支持inner join和left join，使用simple nested loop join算法<br><img src="/../images/cmu15445-project3/8.png" alt="img"></p>
<h4 id="NestedLoopJoin是流水线破坏者吗？"><a href="#NestedLoopJoin是流水线破坏者吗？" class="headerlink" title="NestedLoopJoin是流水线破坏者吗？"></a>NestedLoopJoin是流水线破坏者吗？</h4><p>BusTub采用火山模型(iterator processing<br> model)执行算子。但是某些算子直到子算子提交所有元组的计算结果，才会解除阻塞。如Join、SubQueries、Ordering等，此类操作就被称为Pipeline Breaker。在Task2中，Aggregation、HashJoin都备注了是Pipeline Breaker，但NestedLoopJoin并没有这么说明，如果把它当做Pipeline Breaker，则无法通过测试，Spring2023要求NestedLoopJoin左子节点每次调用一次Next()方法,右子节点都需要Init()一次，因此并非Pipeline Breaker。这也意味着NestedLoopJoin的性能非常糟糕。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NestedLoopJoinExecutor</span> &#123; </span><br><span class="line">  <span class="type">const</span> NestedLoopJoinPlanNode *plan_;</span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; left_executor_;<span class="comment">//左孩子</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; right_executor_;<span class="comment">//右孩子</span></span><br><span class="line">  std::vector&lt;Tuple&gt; right_tuples_;</span><br><span class="line">  <span class="type">int</span> index_;</span><br><span class="line">  Tuple left_tuple_;</span><br><span class="line">  <span class="type">bool</span> is_match_;<span class="comment">//表示当前left_tuple_是否有匹配项</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NestedLoopJoinExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  left_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  right_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple right_tuple;</span><br><span class="line">  RID right_rid;</span><br><span class="line">  <span class="comment">//将右孩子的所有Tuple遍历出来放在right_tuples中</span></span><br><span class="line">  <span class="keyword">while</span> (right_executor_-&gt;<span class="built_in">Next</span>(&amp;right_tuple, &amp;right_rid)) &#123;</span><br><span class="line">    right_tuples_.<span class="built_in">emplace_back</span>(right_tuple);</span><br><span class="line">  &#125;</span><br><span class="line">  index_ = <span class="number">0</span>;</span><br><span class="line">  is_match_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">NestedLoopJoinExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  RID left_rid;</span><br><span class="line">  <span class="keyword">if</span> (index_ != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 上次右侧循环还未结束</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NestedLoop</span>(tuple, rid)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取左孩子的一个tuple存储在left_tuple_中</span></span><br><span class="line">  <span class="keyword">while</span> (left_executor_-&gt;<span class="built_in">Next</span>(&amp;left_tuple_, &amp;left_rid)) &#123;</span><br><span class="line">    right_executor_-&gt;<span class="built_in">Init</span>();  <span class="comment">// no use 单纯为了通过测试</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NestedLoop</span>(tuple, rid)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">NestedLoopJoinExecutor::NestedLoop</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (index_ &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_tuples_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (plan_-&gt;predicate_) &#123;</span><br><span class="line">      <span class="keyword">auto</span> res = plan_-&gt;predicate_-&gt;<span class="built_in">EvaluateJoin</span>(&amp;left_tuple_, left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), &amp;right_tuples_[index_], right_executor_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">      <span class="keyword">if</span> (!(!res.<span class="built_in">IsNull</span>() &amp;&amp; res.<span class="built_in">GetAs</span>&lt;<span class="type">bool</span>&gt;())) &#123;  <span class="comment">// 不符合条件</span></span><br><span class="line">        index_++;</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// 过滤</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 符合条件</span></span><br><span class="line">    <span class="built_in">MergeTuple</span>(tuple);</span><br><span class="line">    index_ = (index_ + <span class="number">1</span>) % right_tuples_.<span class="built_in">size</span>();</span><br><span class="line">    is_match_ = (index_ != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  index_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!is_match_ &amp;&amp; plan_-&gt;<span class="built_in">GetJoinType</span>() == JoinType::LEFT) &#123;</span><br><span class="line">    <span class="comment">// left join</span></span><br><span class="line">    std::vector&lt;Value&gt; values;</span><br><span class="line">    values.<span class="built_in">reserve</span>(<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(left_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">      values.<span class="built_in">emplace_back</span>(left_tuple_.<span class="built_in">GetValue</span>(&amp;left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">      values.<span class="built_in">emplace_back</span>(ValueFactory::<span class="built_in">GetNullValueByType</span>(right_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumn</span>(i).<span class="built_in">GetType</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    *tuple = &#123;values, &amp;<span class="built_in">GetOutputSchema</span>()&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  is_match_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NestedLoopJoinExecutor::MergeTuple</span><span class="params">(Tuple *tuple)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// inner join</span></span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">reserve</span>(<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(left_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(left_tuple_.<span class="built_in">GetValue</span>(&amp;left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(right_tuples_[index_].<span class="built_in">GetValue</span>(&amp;right_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">  &#125;</span><br><span class="line">  *tuple = &#123;values, &amp;<span class="built_in">GetOutputSchema</span>()&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到这里为止，通过SQLLogicTests #7 to #12<br><img src="/../images/cmu15445-project3/16.png" alt="img"><br><img src="/../images/cmu15445-project3/17.png" alt="img"><br><img src="/../images/cmu15445-project3/18.png" alt="img"><br><img src="/../images/cmu15445-project3/19.png" alt="img"><br><img src="/../images/cmu15445-project3/20.png" alt="img"><br><img src="/../images/cmu15445-project3/21.png" alt="img"></p>
<h3 id="HashJoinExecutor实现"><a href="#HashJoinExecutor实现" class="headerlink" title="HashJoinExecutor实现"></a>HashJoinExecutor实现</h3><p> 你将要为HashJoinExecutor实现inner join和left join，使用hash join算法<br> <img src="/../images/cmu15445-project3/9.png" alt="img"><br> 和NestedLoopJoin相同，HashJoin要处理inner join和left join两种情况，而这就会影响HashJoin建表的选择———对于Left join，需要在右表不存在对应匹配时，返回将右表字段用NULL填充的记录。因此对Left Join，在创建哈希表时应该选择右表。</p>
<p>实现思路：<br><br>先遍历右表的所有tuple，收集右表的HashJoinKey，加入哈希表(键值对为HashJoinKey-tuple)<br><br>然后遍历左表的所有tuple，收集左表的HashJoinKey，在哈希表中查找是否有匹配的HashJoinKey，如果匹配成功，拼接<br><br>如果匹配失败，并且是left join，左表的tuple拼接null<br><br>拼接好的结果保存在result_中，由index_下标遍历<br></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">HashJoinExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> HashJoinPlanNode *plan_;</span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; left_child_;</span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; right_child_;</span><br><span class="line">  std::unordered_map&lt;HashJoinKey, std::vector&lt;Tuple&gt;&gt; map_;</span><br><span class="line">  std::vector&lt;Tuple&gt; result_;</span><br><span class="line">  <span class="type">int</span> index_;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">HashJoinExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  left_child_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  right_child_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple right_tuple;</span><br><span class="line">  RID right_rid;</span><br><span class="line">  <span class="keyword">while</span> (right_child_-&gt;<span class="built_in">Next</span>(&amp;right_tuple, &amp;right_rid)) &#123;</span><br><span class="line">    HashJoinKey key;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;expression : plan_-&gt;<span class="built_in">RightJoinKeyExpressions</span>()) &#123;</span><br><span class="line">      key.column_values_.<span class="built_in">emplace_back</span>(expression-&gt;<span class="built_in">Evaluate</span>(&amp;right_tuple, right_child_-&gt;<span class="built_in">GetOutputSchema</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入哈希表</span></span><br><span class="line">    <span class="keyword">if</span> (map_.<span class="built_in">count</span>(key) != <span class="number">0</span>) &#123;</span><br><span class="line">      map_[key].<span class="built_in">emplace_back</span>(right_tuple);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map_[key] = &#123;right_tuple&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历左侧查询,得到查询结果</span></span><br><span class="line">  Tuple left_tuple;</span><br><span class="line">  RID left_rid;</span><br><span class="line">  <span class="keyword">while</span> (left_child_-&gt;<span class="built_in">Next</span>(&amp;left_tuple, &amp;left_rid)) &#123;</span><br><span class="line">    HashJoinKey key;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;expression : plan_-&gt;<span class="built_in">LeftJoinKeyExpressions</span>()) &#123;</span><br><span class="line">      key.column_values_.<span class="built_in">emplace_back</span>(expression-&gt;<span class="built_in">Evaluate</span>(&amp;left_tuple, left_child_-&gt;<span class="built_in">GetOutputSchema</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map_.<span class="built_in">count</span>(key) != <span class="number">0</span>) &#123;  <span class="comment">// 匹配成功</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : map_[key]) &#123;</span><br><span class="line">        std::vector&lt;Value&gt; values;</span><br><span class="line">        values.<span class="built_in">reserve</span>(<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(left_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">          values.<span class="built_in">emplace_back</span>(left_tuple.<span class="built_in">GetValue</span>(&amp;left_child_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">          values.<span class="built_in">emplace_back</span>(t.<span class="built_in">GetValue</span>(&amp;right_child_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">        &#125;</span><br><span class="line">        result_.<span class="built_in">emplace_back</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plan_-&gt;<span class="built_in">GetJoinType</span>() == JoinType::LEFT) &#123;  <span class="comment">// 匹配失败,但是为LEFT JOIN</span></span><br><span class="line">      std::vector&lt;Value&gt; values;</span><br><span class="line">      values.<span class="built_in">reserve</span>(<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(left_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">        values.<span class="built_in">emplace_back</span>(left_tuple.<span class="built_in">GetValue</span>(&amp;left_child_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">        values.<span class="built_in">emplace_back</span>(ValueFactory::<span class="built_in">GetNullValueByType</span>(right_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumn</span>(i).<span class="built_in">GetType</span>()));</span><br><span class="line">      &#125;</span><br><span class="line">      result_.<span class="built_in">emplace_back</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  index_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">HashJoinExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index_ &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(result_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *tuple = result_[index_];</span><br><span class="line">  index_++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optimizing-NestedLoopJoin-to-HashJoin"><a href="#Optimizing-NestedLoopJoin-to-HashJoin" class="headerlink" title="Optimizing NestedLoopJoin to HashJoin"></a>Optimizing NestedLoopJoin to HashJoin</h3><p>具体来说，当连接谓词是两列之间等条件的合取时，可以使用散列连接算法。就本项目而言，处理单个等值条件以及通过 AND 连接的两个等值条件将获得满分<br><br>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Optimizer::OptimizeNLJAsHashJoin</span><span class="params">(<span class="type">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class="line">  <span class="comment">// TODO(student): implement NestedLoopJoin -&gt; HashJoin optimizer rule</span></span><br><span class="line">  <span class="comment">// Note for 2023 Spring: You should at least support join keys of the form:</span></span><br><span class="line">  <span class="comment">// 1. &lt;column expr&gt; = &lt;column expr&gt;</span></span><br><span class="line">  <span class="comment">// 2. &lt;column expr&gt; = &lt;column expr&gt; AND &lt;column expr&gt; = &lt;column expr&gt;</span></span><br><span class="line">  std::vector&lt;AbstractPlanNodeRef&gt; children;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;child : plan-&gt;<span class="built_in">GetChildren</span>()) &#123;<span class="comment">//递归优化</span></span><br><span class="line">    children.<span class="built_in">emplace_back</span>(<span class="built_in">OptimizeNLJAsHashJoin</span>(child));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> optimized_plan = plan-&gt;<span class="built_in">CloneWithChildren</span>(std::<span class="built_in">move</span>(children));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (optimized_plan-&gt;<span class="built_in">GetType</span>() == PlanType::NestedLoopJoin) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> nlj_plan = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> NestedLoopJoinPlanNode &amp;&gt;(*optimized_plan);</span><br><span class="line">    <span class="built_in">BUSTUB_ENSURE</span>(nlj_plan.children_.<span class="built_in">size</span>() == <span class="number">2</span>, <span class="string">&quot;NLJ should have exactly 2 children.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *expr = <span class="built_in">dynamic_cast</span>&lt;ComparisonExpression *&gt;(nlj_plan.<span class="built_in">Predicate</span>().<span class="built_in">get</span>()); expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (expr-&gt;comp_type_ == ComparisonType::Equal) &#123; <span class="comment">// 如果表达式的Type为 ComparisonType::Equal</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> *left_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr-&gt;children_[<span class="number">0</span>].<span class="built_in">get</span>()); left_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">auto</span> *right_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr-&gt;children_[<span class="number">1</span>].<span class="built_in">get</span>());</span><br><span class="line">              right_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            std::vector&lt;AbstractExpressionRef&gt; left_key_expressions;</span><br><span class="line">            std::vector&lt;AbstractExpressionRef&gt; right_key_expressions;</span><br><span class="line">            <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">              left_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                  std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">              right_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                  std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">1</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">              left_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                  std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">              right_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                  std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">1</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;HashJoinPlanNode&gt;(nlj_plan.output_schema_, nlj_plan.<span class="built_in">GetLeftPlan</span>(),</span><br><span class="line">                                                      nlj_plan.<span class="built_in">GetRightPlan</span>(), std::<span class="built_in">move</span>(left_key_expressions),</span><br><span class="line">                                                      std::<span class="built_in">move</span>(right_key_expressions), nlj_plan.<span class="built_in">GetJoinType</span>());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *expr = <span class="built_in">dynamic_cast</span>&lt;LogicExpression *&gt;(nlj_plan.<span class="built_in">Predicate</span>().<span class="built_in">get</span>()); expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (expr-&gt;logic_type_ == LogicType::And) &#123;<span class="comment">//如果表达式的 Type为 LogicType::And</span></span><br><span class="line">        <span class="built_in">BUSTUB_ASSERT</span>(expr-&gt;<span class="built_in">GetChildren</span>().<span class="built_in">size</span>() == <span class="number">2</span>, <span class="string">&quot;LogicExpression has two children&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> *expr1 = <span class="built_in">dynamic_cast</span>&lt;ComparisonExpression *&gt;(expr-&gt;children_[<span class="number">0</span>].<span class="built_in">get</span>()); expr1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">auto</span> *expr2 = <span class="built_in">dynamic_cast</span>&lt;ComparisonExpression *&gt;(expr-&gt;children_[<span class="number">1</span>].<span class="built_in">get</span>()); expr2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expr1-&gt;comp_type_ == ComparisonType::Equal &amp;&amp; expr2-&gt;comp_type_ == ComparisonType::Equal) &#123; <span class="comment">// 两个子表达式的Type均为 ComparisonType::Equal</span></span><br><span class="line">              std::vector&lt;AbstractExpressionRef&gt; left_key_expressions;</span><br><span class="line">              std::vector&lt;AbstractExpressionRef&gt; right_key_expressions;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">auto</span> *left_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr1-&gt;children_[<span class="number">0</span>].<span class="built_in">get</span>());</span><br><span class="line">                  left_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">auto</span> *right_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr1-&gt;children_[<span class="number">1</span>].<span class="built_in">get</span>());</span><br><span class="line">                    right_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                    left_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                    right_key_expressions.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(</span><br><span class="line">                        <span class="number">1</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    left_key_expressions.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(</span><br><span class="line">                        <span class="number">0</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                    right_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">1</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">auto</span> *left_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr2-&gt;children_[<span class="number">0</span>].<span class="built_in">get</span>());</span><br><span class="line">                  left_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">auto</span> *right_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr2-&gt;children_[<span class="number">1</span>].<span class="built_in">get</span>());</span><br><span class="line">                    right_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                    left_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                    right_key_expressions.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(</span><br><span class="line">                        <span class="number">1</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    left_key_expressions.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(</span><br><span class="line">                        <span class="number">0</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                    right_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">1</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;HashJoinPlanNode&gt;(nlj_plan.output_schema_, nlj_plan.<span class="built_in">GetLeftPlan</span>(),</span><br><span class="line">                                                        nlj_plan.<span class="built_in">GetRightPlan</span>(), std::<span class="built_in">move</span>(left_key_expressions),</span><br><span class="line">                                                        std::<span class="built_in">move</span>(right_key_expressions), nlj_plan.<span class="built_in">GetJoinType</span>());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> optimized_plan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里为止，通过SQLLogicTests #14 to #15<br><img src="/../images/cmu15445-project3/22.png" alt="img"><br><img src="/../images/cmu15445-project3/23.png" alt="img"><br><img src="/../images/cmu15445-project3/24.png" alt="img"></p>
<h2 id="Task-3-Sort-Limit-Executors-and-Top-N-Optimization"><a href="#Task-3-Sort-Limit-Executors-and-Top-N-Optimization" class="headerlink" title="Task#3 Sort + Limit Executors and Top-N Optimization"></a>Task#3 Sort + Limit Executors and Top-N Optimization</h2><h3 id="SortExecutor实现："><a href="#SortExecutor实现：" class="headerlink" title="SortExecutor实现："></a>SortExecutor实现：</h3><p>如果查询的ORDER BY属性与索引的key不匹配，BusTub将为查询生成一个SortPlanNode<br><br>如果查询不包含排序方向(即ASC、DESC)，则排序模式将为默认(即ASC)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SortExecutor</span> &#123;</span><br><span class="line">  <span class="comment">//添加数据成员</span></span><br><span class="line">  <span class="type">const</span> SortPlanNode *plan_;</span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;</span><br><span class="line">  std::vector&lt;Tuple&gt; result_;</span><br><span class="line">  <span class="type">int</span> index_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Tuple tuple;</span><br><span class="line">  RID rid;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;<span class="comment">//遍历孩子executor的所有tuple放入result_</span></span><br><span class="line">    result_.<span class="built_in">emplace_back</span>(tuple);</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">sort</span>(result_.<span class="built_in">begin</span>(), result_.<span class="built_in">end</span>(),</span><br><span class="line">            [<span class="keyword">this</span>](<span class="type">const</span> Tuple &amp;left, <span class="type">const</span> Tuple &amp;right) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">TupleComparator</span>(left, right); &#125;);<span class="comment">//对result_进行排序</span></span><br><span class="line">  index_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SortExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index_ &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(result_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *tuple = result_[index_];</span><br><span class="line">  index_++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SortExecutor::TupleComparator</span><span class="params">(<span class="type">const</span> Tuple &amp;left, <span class="type">const</span> Tuple &amp;right)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;order_by = plan_-&gt;<span class="built_in">GetOrderBy</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : order_by) &#123;</span><br><span class="line">    <span class="keyword">auto</span> order = p.first;</span><br><span class="line">    <span class="keyword">auto</span> &amp;exp = p.second;</span><br><span class="line">    <span class="keyword">auto</span> lvalue = exp-&gt;<span class="built_in">Evaluate</span>(&amp;left, child_executor_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    <span class="keyword">auto</span> rvalue = exp-&gt;<span class="built_in">Evaluate</span>(&amp;right, child_executor_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    <span class="keyword">if</span> (order == OrderByType::DESC) &#123;</span><br><span class="line">      <span class="keyword">if</span> (lvalue.<span class="built_in">CompareGreaterThan</span>(rvalue) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lvalue.<span class="built_in">CompareLessThan</span>(rvalue) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lvalue.<span class="built_in">CompareLessThan</span>(rvalue) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lvalue.<span class="built_in">CompareGreaterThan</span>(rvalue) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">UNREACHABLE</span>(<span class="string">&quot;duplicate key is not allowed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LimitExecutor实现"><a href="#LimitExecutor实现" class="headerlink" title="LimitExecutor实现:"></a>LimitExecutor实现:</h3><p>LimitExectutor限制其子executor的输出tuple数量。如果其子executor生成的元组数量小于LimitExecutor中指定的限制，则该executor无效并生成它接受到的所有tuple</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LimitExecutor</span> &#123;</span><br><span class="line">  <span class="comment">//添加数据成员</span></span><br><span class="line">  <span class="type">const</span> LimitPlanNode *plan_;</span><br><span class="line">  <span class="comment">/** The child executor from which tuples are obtained */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;</span><br><span class="line">  <span class="type">size_t</span> num_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LimitExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  num_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LimitExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num_ &gt;= plan_-&gt;<span class="built_in">GetLimit</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;</span><br><span class="line">    num_++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-N-Optimization-Rule"><a href="#Top-N-Optimization-Rule" class="headerlink" title="Top-N Optimization Rule"></a>Top-N Optimization Rule</h3><p>用一个优先队列维护top n 条tuple</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TopNExecutor</span> &#123;</span><br><span class="line">  <span class="comment">//数据成员</span></span><br><span class="line">  <span class="type">const</span> TopNPlanNode *plan_;</span><br><span class="line">  <span class="comment">/** The child executor from which tuples are obtained */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;</span><br><span class="line">  std::priority_queue&lt;HeapKeyType&gt; heap_;<span class="comment">//一个优先队列</span></span><br><span class="line">  std::deque&lt;Tuple&gt; result_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TopNExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple tuple;</span><br><span class="line">  RID rid;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;<span class="comment">//child_executor_遍历所有的tuple</span></span><br><span class="line">    <span class="function">HeapKeyType <span class="title">key</span><span class="params">(tuple, plan_-&gt;GetOrderBy(), child_executor_.get())</span></span>;</span><br><span class="line">    heap_.<span class="built_in">emplace</span>(tuple, plan_-&gt;<span class="built_in">GetOrderBy</span>(), child_executor_.<span class="built_in">get</span>());<span class="comment">//加入优先队列中</span></span><br><span class="line">    <span class="keyword">if</span> (heap_.<span class="built_in">size</span>() &gt; plan_-&gt;<span class="built_in">GetN</span>()) &#123;<span class="comment">//保证优先队列中的size不超过N</span></span><br><span class="line">      heap_.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!heap_.<span class="built_in">empty</span>()) &#123;<span class="comment">//将heap中的tuple_都放入result_</span></span><br><span class="line">    result_.<span class="built_in">emplace_front</span>(heap_.<span class="built_in">top</span>().tuple_);</span><br><span class="line">    heap_.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TopNExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetNumInHeap</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">    *tuple = result_.<span class="built_in">front</span>();</span><br><span class="line">    result_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TopNExecutor::GetNumInHeap</span><span class="params">()</span> -&gt; <span class="type">size_t</span> </span>&#123; <span class="keyword">return</span> result_.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>到这里为止，通过SQLLogicTests #16 to #19<br><img src="/../images/cmu15445-project3/25.png" alt="img"><br><img src="/../images/cmu15445-project3/26.png" alt="img"><br><img src="/../images/cmu15445-project3/27.png" alt="img"><br><img src="/../images/cmu15445-project3/28.png" alt="img"></p>
<p>通过线上测试:<br><img src="/../images/cmu15445-project3/29.png" alt="img"></p>
]]></content>
      <categories>
        <category>cmu15445-2023</category>
      </categories>
      <tags>
        <tag>cmu15445—2023</tag>
      </tags>
  </entry>
  <entry>
    <title>cmu15445-project4</title>
    <url>/2024/02/29/cmu15445-project4/</url>
    <content><![CDATA[<h2 id="Concurrency-Control-Theory"><a href="#Concurrency-Control-Theory" class="headerlink" title="Concurrency Control Theory"></a>Concurrency Control Theory</h2><h3 id="formal-Definitions"><a href="#formal-Definitions" class="headerlink" title="formal Definitions"></a>formal Definitions</h3><p>Database: A fixed set of named data objects (e.g., A, B, C, …)<br>Transaction: A sequence of read and write operations (e.g., R(A), W(B), …)</p>
<p>transaction的正确性标准ACID：</p>
<ul>
<li>Atomicity: 原子性 “all or nothing”</li>
<li>Consistency: 一致性 “it looks correct to me”</li>
<li>Isolation: 隔离性 “as if alone”</li>
<li>Durability: 持久性 “survive failures”</li>
</ul>
<h3 id="Conflicting-Operations"><a href="#Conflicting-Operations" class="headerlink" title="Conflicting Operations"></a>Conflicting Operations</h3><p>多个transaction并发执行时会发生冲突:</p>
<ul>
<li>读写冲突(R-W)</li>
<li>写读冲突(W-R)</li>
<li>写写冲突(W-W)</li>
</ul>
<p>读写冲突造成的问题：<br></p>
<ul>
<li>不可重复读(在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了[不可重复读]的现象)</li>
<li>幻读：在一个事务内多次查询某个符合查询条件的[记录数量]，出现前后两次查询到的记录数量不一样</li>
</ul>
<p>写读冲突造成的问题：<br></p>
<ul>
<li>脏读(一个事务[读到]了另一个[未提交事务修改过的数据],就意味着发生了[脏读]现象)</li>
</ul>
<p>写写冲突造成的问题: <br></p>
<ul>
<li>丢失修改</li>
</ul>
<p><img src="/../images/cmu15445-project4/2.png" alt="img"><br><img src="/../images/cmu15445-project4/3.png" alt="img"><br><img src="/../images/cmu15445-project4/4.png" alt="img"></p>
<blockquote>
<p>MySQL InnoDB引擎的默认隔离级别虽然是[可重复读]，但是它很大程度上避免幻读现象，并没有解决幻读 <a href="https://xiaolincoding.com/mysql/transaction/phantom.html">参考文章</a><br></p>
</blockquote>
<hr>
<blockquote>
<p>解决方案有两种:</p>
<ul>
<li>普通select语句(快照读),通过MVCC方式解决了幻读问题</li>
<li>select … for update语句(当前读)，通过next-key lock(记录锁 + 间隙锁)方式解决了幻读</li>
</ul>
</blockquote>
<h3 id="Read-View在MVCC里如何工作的"><a href="#Read-View在MVCC里如何工作的" class="headerlink" title="Read View在MVCC里如何工作的?"></a>Read View在MVCC里如何工作的?</h3><p>Read View有四个重要的字段<br><br>四个字段只有m_ids是一个集合，creator_trx_id在m_ids集合中，<br>min_trx_id是m_ids集合的最小值<br><img src="/../images/cmu15445-project4/5.png" alt="img"></p>
<p>记录的两个隐藏列<br><img src="/../images/cmu15445-project4/6.png" alt="img"></p>
<ul>
<li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；</li>
<li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录</li>
</ul>
<p>在创建ReadView后，一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有几种情况：</p>
<ul>
<li>如果记录的trx_id小于ReadView的min_trx_id，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见</li>
<li>如果记录的trx_id大于等于ReadView中的max_trx_id,表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见</li>
<li>如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中：<ul>
<li>如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。</li>
<li>如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。</li>
</ul>
</li>
</ul>
<h3 id="Two-Phase-Locking-两阶段锁"><a href="#Two-Phase-Locking-两阶段锁" class="headerlink" title="Two Phase Locking 两阶段锁"></a>Two Phase Locking 两阶段锁</h3><p>2PL将事务划分为两个阶段:</p>
<ul>
<li>Growing Phase: 只获得锁</li>
<li>Shrink Phase: 只释放锁</li>
</ul>
<p><img src="/../images/cmu15445-project4/7.png" alt="img"><br>2PL本身已经足够保证schedule是seriable的，但2PL可能导致cascading aborts，举例如下:<br><img src="/../images/cmu15445-project4/8.png" alt="img"></p>
<p>于是引入2PL的增强版变种，Rigorous 2PL，后者每个事务在结束之前，其写过的数据不能被其它事务读取或者重写</p>
<p><img src="/../images/cmu15445-project4/9.png" alt="img"></p>
<h3 id="Deadlock-Detection-Prevention"><a href="#Deadlock-Detection-Prevention" class="headerlink" title="Deadlock Detection &amp; Prevention"></a>Deadlock Detection &amp; Prevention</h3><p>2PL 无法避免的一个问题就是死锁，解决方案：<br></p>
<h4 id="Deadlock-Detection-事后检测"><a href="#Deadlock-Detection-事后检测" class="headerlink" title="Deadlock Detection 事后检测"></a>Deadlock Detection 事后检测</h4><p>为了检测死锁，DBMS 会维护一张 waits-for graph，来跟踪每个事务正在等待 (释放锁) 的其它事务，然后系统会定期地检查 waits-for graph，看其中是否有成环，如果成环了就要决定如何打破这个环。<br><br>waits-for graph 中的节点是事务，从 Ti 到 Tj 的边就表示 Ti 正在等待 Tj 释放锁，举例如下<br><img src="/../images/cmu15445-project4/10.png" alt="img"><br>当 DBMS 检测到死锁时，它会选择一个 “受害者” (事务)，将该事务回滚，打破环形依赖，而这个 “受害者” 将依靠配置或者应用层逻辑重试或中止。这里有两个设计决定：</p>
<ol>
<li>检测死锁的频率</li>
<li>如何选择合适的 “受害者”</li>
</ol>
<p>检测死锁的频率越高，陷入死锁的事务等待的时间越短，但消耗的 cpu 也就越多。所以这是个典型的 trade-off，通常有一个调优的参数供用户配置。</p>
<p>选择 “受害者” 的指标可能有很多：事务持续时间、事务的进度、事务锁住的数据数量、级联事务的数量、事务曾经重启的次数等等。在选择完 “受害者” 后，DBMS 还有一个设计决定需要做：完全回滚还是回滚到足够消除环形依赖即可。</p>
<h4 id="Deadlock-Prevention-事前阻止"><a href="#Deadlock-Prevention-事前阻止" class="headerlink" title="Deadlock Prevention 事前阻止"></a>Deadlock Prevention 事前阻止</h4><p>通常 prevention 会按照事务的年龄来赋予优先级，事务的时间戳越老，优先级越高。有两种 prevention 的策略： <br></p>
<ul>
<li>Old Waits for Young：如果 requesting txn 优先级比 holding txn 更高则等待后者释放锁；更低则自行中止<br></li>
<li>Young Waits for Old：如果 requesting txn 优先级比 holding txn 更高则后者自行中止释放锁，让前者获取锁，否则 requesting txn 等待 holding txn 释放锁</li>
</ul>
<p>举例如下:</p>
<p><img src="/../images/cmu15445-project4/11.png" alt="img"></p>
<p>死锁产生的必要条件是<br><br>1.互斥 2.请求与保持 3.不可抢占 4.循环等待<br></p>
<h2 id="Task-1-Lock-Manager"><a href="#Task-1-Lock-Manager" class="headerlink" title="Task#1 Lock Manager"></a>Task#1 Lock Manager</h2><p>五种锁 S X IS IX SIX<br><img src="/../images/cmu15445-project4/12.png" alt="img"><br>这里只实现三种隔离级别READ_UNCOMMITTED、READ_COMMITTED、REPEATABLE_READ</p>
<h3 id="LOCK-NOTE"><a href="#LOCK-NOTE" class="headerlink" title="LOCK NOTE"></a>LOCK NOTE</h3><ol>
<li><p>GENERAL BEHAVIOUR:</p>
<ul>
<li>Both LockTable() and LockRow() are blocking methods; they should wait till the lock is granted and then return.</li>
<li>If the transaction was aborted in the meantime, do not grant the lock and return false.</li>
</ul>
</li>
<li><p>MULTIPLE TRANSACTIONS:</p>
<ul>
<li>LockManager should maintain a queue for each resource; locks should be granted to transactions in a FIFO manner.</li>
<li>If there are multiple compatible lock requests, all should be granted at the same time</li>
<li>as long as FIFO is honoured.</li>
</ul>
</li>
<li><p>SUPPORTED LOCK MODES:</p>
<ul>
<li>Table locking should support all lock modes.</li>
<li>Row locking should not support Intention locks. Attempting this should set the TransactionState as</li>
<li>ABORTED and throw a TransactionAbortException (ATTEMPTED_INTENTION_LOCK_ON_ROW)</li>
</ul>
</li>
<li><p>ISOLATION LEVEL:</p>
<ul>
<li><p>REPEATABLE_READ:<br><br>  The transaction is required to take all locks.<br>  All locks are allowed in the GROWING state<br>  No locks are allowed in the SHRINKING state</p>
</li>
<li><p>READ_COMMITTED:<br><br> The transaction is required to take all locks.<br> All locks are allowed in the GROWING state<br> Only IS, S locks are allowed in the SHRINKING state</p>
</li>
<li><p>READ_UNCOMMITTED:<br><br> The transaction is required to take only IX, X locks.<br> X, IX locks are allowed in the GROWING state.<br> S, IS, SIX locks are never allowed</p>
</li>
</ul>
</li>
<li><p>MULTILEVEL LOCKING:</p>
<ul>
<li>While locking rows, Lock() should ensure that the transaction has an appropriate lock on the table which the row</li>
</ul>
<p> belongs to. For instance, if an exclusive lock is attempted on a row, the transaction must hold either X, IX, or SIX on the table. If such a lock does not exist on the table, Lock() should set the TransactionState as ABORTED and throw a TransactionAbortException (TABLE_LOCK_NOT_PRESENT)</p>
</li>
<li><p>LOCK UPGRADE:<br><br>Calling Lock() on a resource that is already locked should have the following behaviour:    </p>
<ul>
<li>If requested lock mode is the same as that of the lock presently held, Lock() should return true since it already has the lock.</li>
<li>If requested lock mode is different, Lock() should upgrade the lock held by the transaction.<br><br> While upgrading, only the following transitions should be allowed:<br><ol>
<li>IS -&gt; [S, X, IX, SIX]</li>
<li>S -&gt; [X, SIX]</li>
<li>IX -&gt; [X, SIX]</li>
<li>SIX -&gt; [X]</li>
</ol>
</li>
</ul>
<ul>
<li>Any other upgrade is considered incompatible, and such an attempt should set the TransactionState as ABORTED and throw a TransactionAbortException (INCOMPATIBLE_UPGRADE)</li>
<li>Furthermore, only one transaction should be allowed to upgrade its lock on a given resource. Multiple concurrent lock upgrades on the same resource should set the TransactionState as ABORTED and throw a TransactionAbortException (UPGRADE_CONFLICT).</li>
</ul>
</li>
</ol>
<h3 id="UNLOCK-NOTE"><a href="#UNLOCK-NOTE" class="headerlink" title="UNLOCK NOTE"></a>UNLOCK NOTE</h3><ol>
<li>GENERAL BEHAVIOUR:<ul>
<li>Both UnlockTable() and UnlockRow() should release the lock on the resource and return. Both should ensure that the transaction currently holds a lock on the resource it is attempting to unlock.</li>
</ul>
<p>If not, LockManager should set the TransactionState as ABORTED and throw a TransactionAbortException (ATTEMPTED_UNLOCK_BUT_NO_LOCK_HELD)</p>
<ul>
<li>Additionally, unlocking a table should only be allowed if the transaction does not hold locks on any row on that table. If the transaction holds locks on rows of the table, Unlock should set the Transaction State as ABORTED and throw a TransactionAbortException (TABLE_UNLOCKED_BEFORE_UNLOCKING_ROWS).</li>
<li>Finally, unlocking a resource should also grant any new lock requests for the resource (if possible).</li>
</ul>
</li>
<li>TRANSACTION STATE UPDATE<ul>
<li>REPEATABLE_READ:<br><br>   Unlocking S&#x2F;X locks should set the transaction state to SHRINKING</li>
<li>READ_COMMITTED:<br><br>   Unlocking X locks should set the transaction state to SHRINKING.<br><br>   Unlocking S locks does not affect transaction state.</li>
<li>READ_UNCOMMITTED:<br><br>   Unlocking X locks should set the transaction state to SHRINKING.<br><br>   S locks are not permitted under READ_UNCOMMITTED.<br><br>   The behaviour upon unlocking an S lock under this isolation level is undefined.</li>
</ul>
</li>
</ol>
<p><br><br><br></p>
<ul>
<li>LockTable(Transaction, LockMode, TableOID)</li>
<li>UnlockTable(Transction, TableOID)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LockManager::LockTable</span><span class="params">(Transaction *txn, LockMode lock_mode, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">LockTableDirectlyOrNot</span>(txn, lock_mode, oid, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LockManager::LockTableDirectlyOrNot</span><span class="params">(Transaction *txn, LockMode lock_mode, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid, <span class="type">bool</span> directly)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> txn_state = txn-&gt;<span class="built_in">GetState</span>();</span><br><span class="line">  <span class="keyword">auto</span> iso_level = txn-&gt;<span class="built_in">GetIsolationLevel</span>();</span><br><span class="line">  <span class="keyword">if</span> (txn_state == TransactionState::COMMITTED || txn_state == TransactionState::ABORTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//事务已经提交或终止，返回false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (iso_level) &#123;</span><br><span class="line">    <span class="keyword">case</span> IsolationLevel::REPEATABLE_READ:</span><br><span class="line">      <span class="keyword">if</span> (txn_state == TransactionState::SHRINKING) &#123;<span class="comment">//REPEATABLE_READ级别下,SHRINKING阶段不可加锁</span></span><br><span class="line">        <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::LOCK_ON_SHRINKING, directly);<span class="comment">//抛出异常</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IsolationLevel::READ_COMMITTED:</span><br><span class="line">      <span class="keyword">if</span> (txn_state == TransactionState::SHRINKING) &#123;</span><br><span class="line">        <span class="comment">//READ_COMMITTED级别下，SHRINGKING阶段只可加IS、S锁</span></span><br><span class="line">        <span class="keyword">if</span> (lock_mode != LockMode::INTENTION_SHARED &amp;&amp; lock_mode != LockMode::SHARED) &#123;</span><br><span class="line">          <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::LOCK_ON_SHRINKING, directly);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IsolationLevel::READ_UNCOMMITTED:</span><br><span class="line">      <span class="comment">//READ_UNCOMMITTED级别下,SHRINKING阶段不可加锁</span></span><br><span class="line">      <span class="keyword">if</span> (txn_state == TransactionState::SHRINKING) &#123;</span><br><span class="line">        <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::LOCK_ON_SHRINKING, directly);<span class="comment">//抛出异常</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//READ_UNCOMMITTED级别下,只可以加IX和X锁</span></span><br><span class="line">      <span class="keyword">if</span> (lock_mode != LockMode::INTENTION_EXCLUSIVE &amp;&amp; lock_mode != LockMode::EXCLUSIVE) &#123;</span><br><span class="line">        <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::LOCK_SHARED_ON_READ_UNCOMMITTED, directly);<span class="comment">//抛出异常</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">UNREACHABLE</span>(<span class="string">&quot;wrong IsolationLevel&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  table_lock_map_latch_.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="keyword">if</span> (table_lock_map_.<span class="built_in">count</span>(oid) == <span class="number">0</span>) &#123;</span><br><span class="line">    table_lock_map_[oid] = std::<span class="built_in">make_shared</span>&lt;LockRequestQueue&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> lrq = table_lock_map_[oid];<span class="comment">//拿到该table的LockRequestQueue</span></span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(lrq-&gt;latch_)</span></span>;</span><br><span class="line">  table_lock_map_latch_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查此锁的请求是否为一次锁升级</span></span><br><span class="line">  <span class="type">bool</span> upgrade = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> iter = lrq-&gt;request_queue_.<span class="built_in">begin</span>(); iter != lrq-&gt;request_queue_.<span class="built_in">end</span>(); iter++) &#123;<span class="comment">//遍历LockRequestQueue</span></span><br><span class="line">    <span class="keyword">auto</span> lr = *iter;</span><br><span class="line">    <span class="keyword">if</span> (lr-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;  <span class="comment">// 同一个事务对相同table请求加锁</span></span><br><span class="line">      <span class="keyword">if</span> (lr-&gt;lock_mode_ == lock_mode) &#123;           <span class="comment">// 加锁的类型相同,直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lrq-&gt;upgrading_ != INVALID_TXN_ID) &#123;  <span class="comment">// 有事务正在对该resource进行锁升级</span></span><br><span class="line">        <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::UPGRADE_CONFLICT, directly);<span class="comment">//抛出异常</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">CanLockUpgrade</span>(lr-&gt;lock_mode_, lock_mode)) &#123;  <span class="comment">// 不能够进行锁升级</span></span><br><span class="line">        <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::INCOMPATIBLE_UPGRADE, directly);<span class="comment">//抛出异常</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//锁升级</span></span><br><span class="line">      lrq-&gt;upgrading_ = txn-&gt;<span class="built_in">GetTransactionId</span>();</span><br><span class="line">      lrq-&gt;request_queue_.<span class="built_in">erase</span>(iter);<span class="comment">//将lr从LockRequestQueue中删除</span></span><br><span class="line">      <span class="built_in">RemoveFromTxnTableLockSet</span>(txn, lr-&gt;lock_mode_, oid);<span class="comment">//将txn事务持有该table的锁删除</span></span><br><span class="line">      <span class="keyword">delete</span> lr;  <span class="comment">// 防止内存泄露</span></span><br><span class="line">      lrq-&gt;request_queue_.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">LockRequest</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid));<span class="comment">//加入LockRequest</span></span><br><span class="line">      upgrade = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不是锁升级</span></span><br><span class="line">  <span class="keyword">if</span> (!upgrade) &#123;</span><br><span class="line">    lrq-&gt;request_queue_.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">LockRequest</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid));<span class="comment">//加入LockRequest</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">CanTxnTakeLock</span>(txn, lock_mode, lrq)) &#123;<span class="comment">//判断是否可以给改Table加锁</span></span><br><span class="line">    lrq-&gt;cv_.<span class="built_in">wait</span>(lock);<span class="comment">//互斥阻塞</span></span><br><span class="line">    <span class="comment">// 可能死锁检测将该事务ABORTED 或者 手动ABORT该事务</span></span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">      <span class="comment">// 删除该事务对该资源的request</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> iter = lrq-&gt;request_queue_.<span class="built_in">begin</span>(); iter != lrq-&gt;request_queue_.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> lr = *iter;</span><br><span class="line">        <span class="keyword">if</span> (lr-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">          lrq-&gt;request_queue_.<span class="built_in">erase</span>(iter);</span><br><span class="line">          <span class="keyword">delete</span> lr;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lrq-&gt;cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AddIntoTxnTableLockSet</span>(txn, lock_mode, oid);<span class="comment">//该Table获得锁</span></span><br><span class="line">  <span class="comment">// LOG_DEBUG(&quot;txn:%d LockTable %d lock_mode:%d&quot;, txn-&gt;GetTransactionId(), oid, lock_mode);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LockManager::CanTxnTakeLock</span><span class="params">(Transaction *txn, LockMode lock_mode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 std::shared_ptr&lt;LockRequestQueue&gt; &amp;lock_request_queue)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> lr : lock_request_queue-&gt;request_queue_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lr-&gt;granted_ &amp;&amp; !<span class="built_in">AreLocksCompatible</span>(lock_mode, lr-&gt;lock_mode_)) &#123;  <span class="comment">// 存在锁冲突</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 锁升级优先级最高</span></span><br><span class="line">  <span class="keyword">if</span> (lock_request_queue-&gt;upgrading_ != INVALID_TXN_ID) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock_request_queue-&gt;upgrading_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;  <span class="comment">// 事务进行锁升级</span></span><br><span class="line">      lock_request_queue-&gt;upgrading_ = INVALID_TXN_ID;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> lr : lock_request_queue-&gt;request_queue_) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lr-&gt;granted_ &amp;&amp; lr-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">          lr-&gt;granted_ = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 进行锁升级的是其它事务,那么该事务需要等待</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遵循FIFO规则</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> lr : lock_request_queue-&gt;request_queue_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lr-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">      lr-&gt;granted_ = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!lr-&gt;granted_ &amp;&amp; !<span class="built_in">AreLocksCompatible</span>(lock_mode, lr-&gt;lock_mode_)) &#123;  <span class="comment">// 锁冲突</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LockManager::UnlockTable</span><span class="params">(Transaction *txn, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">CheckAllRowsUnLock</span>(txn, oid)) &#123;<span class="comment">//检查该Table下的所有row的锁是否释放</span></span><br><span class="line">    <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::TABLE_UNLOCKED_BEFORE_UNLOCKING_ROWS, <span class="literal">true</span>);<span class="comment">//抛出异常</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  table_lock_map_latch_.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="keyword">if</span> (table_lock_map_.<span class="built_in">count</span>(oid) == <span class="number">0</span>) &#123;</span><br><span class="line">    table_lock_map_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::ATTEMPTED_UNLOCK_BUT_NO_LOCK_HELD, <span class="literal">true</span>);<span class="comment">//该table未加锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> lrq = table_lock_map_[oid];</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(lrq-&gt;latch_)</span></span>;</span><br><span class="line">  table_lock_map_latch_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> iter = lrq-&gt;request_queue_.<span class="built_in">begin</span>(); iter != lrq-&gt;request_queue_.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    <span class="keyword">auto</span> lr = *iter;</span><br><span class="line">    <span class="keyword">if</span> (lr-&gt;granted_ &amp;&amp; lr-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;<span class="comment">//找到该事务对该table的LockRequest</span></span><br><span class="line">      <span class="keyword">auto</span> iso_level = txn-&gt;<span class="built_in">GetIsolationLevel</span>();</span><br><span class="line">      <span class="keyword">switch</span> (iso_level) &#123;</span><br><span class="line">        <span class="keyword">case</span> IsolationLevel::REPEATABLE_READ:</span><br><span class="line">          <span class="keyword">if</span> (lr-&gt;lock_mode_ == LockMode::SHARED || lr-&gt;lock_mode_ == LockMode::EXCLUSIVE) &#123;</span><br><span class="line">            txn-&gt;<span class="built_in">SetState</span>(TransactionState::SHRINKING);</span><br><span class="line">            <span class="comment">// LOG_DEBUG(&quot;txn:%d be set SHRINGKING&quot;, txn-&gt;GetTransactionId());</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IsolationLevel::READ_COMMITTED:</span><br><span class="line">        <span class="keyword">case</span> IsolationLevel::READ_UNCOMMITTED:</span><br><span class="line">          <span class="keyword">if</span> (lr-&gt;lock_mode_ == LockMode::EXCLUSIVE) &#123;</span><br><span class="line">            txn-&gt;<span class="built_in">SetState</span>(TransactionState::SHRINKING);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">UNREACHABLE</span>(<span class="string">&quot;wrong IsolationLevel&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">RemoveFromTxnTableLockSet</span>(txn, lr-&gt;lock_mode_, oid);</span><br><span class="line">      <span class="comment">// LOG_DEBUG(&quot;txn:%d UnlockTable %d&quot;, txn-&gt;GetTransactionId(), oid);</span></span><br><span class="line">      lrq-&gt;request_queue_.<span class="built_in">erase</span>(iter);</span><br><span class="line">      <span class="keyword">delete</span> lr;</span><br><span class="line">      lrq-&gt;cv_.<span class="built_in">notify_all</span>();<span class="comment">//资源释放，cv_进行notify</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::ATTEMPTED_UNLOCK_BUT_NO_LOCK_HELD, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>LockRow(Transaction, LockMode, TableOID, RID)</li>
<li>UnlockRow(Transaction, TableOID, RID, force)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LockManager::LockRow</span><span class="params">(Transaction *txn, LockMode lock_mode, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid, <span class="type">const</span> RID &amp;rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">    <span class="comment">//row只能加S和E锁</span></span><br><span class="line">  <span class="keyword">if</span> (lock_mode != LockMode::SHARED &amp;&amp; lock_mode != LockMode::EXCLUSIVE) &#123;</span><br><span class="line">    <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::ATTEMPTED_INTENTION_LOCK_ON_ROW, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> txn_state = txn-&gt;<span class="built_in">GetState</span>();</span><br><span class="line">  <span class="keyword">auto</span> iso_level = txn-&gt;<span class="built_in">GetIsolationLevel</span>();</span><br><span class="line">  <span class="keyword">if</span> (txn_state == TransactionState::COMMITTED || txn_state == TransactionState::ABORTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (iso_level) &#123;</span><br><span class="line">    <span class="keyword">case</span> IsolationLevel::REPEATABLE_READ:</span><br><span class="line">    <span class="comment">//REPEATABLE_READ级别下SHRINKING阶段不可以加锁</span></span><br><span class="line">      <span class="keyword">if</span> (txn_state == TransactionState::SHRINKING) &#123;</span><br><span class="line">        <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::LOCK_ON_SHRINKING, <span class="literal">true</span>);<span class="comment">//抛出异常</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IsolationLevel::READ_COMMITTED:</span><br><span class="line">    <span class="comment">//READ_COMMITTED级别下SHRINKING阶段只能给row加SHARED锁</span></span><br><span class="line">      <span class="keyword">if</span> (txn_state == TransactionState::SHRINKING) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lock_mode != LockMode::SHARED) &#123;</span><br><span class="line">          <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::LOCK_ON_SHRINKING, <span class="literal">true</span>);<span class="comment">//抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IsolationLevel::READ_UNCOMMITTED:</span><br><span class="line">    <span class="comment">//READ_UNCOMMITTED级别下SHRINKING阶段不能加锁</span></span><br><span class="line">      <span class="keyword">if</span> (txn_state == TransactionState::SHRINKING) &#123;</span><br><span class="line">        <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::LOCK_ON_SHRINKING, <span class="literal">true</span>);<span class="comment">//抛出异常</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//READ_UNCOMMITTED级别下，只能给row加X锁</span></span><br><span class="line">      <span class="keyword">if</span> (lock_mode != LockMode::EXCLUSIVE) &#123;</span><br><span class="line">        <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::LOCK_SHARED_ON_READ_UNCOMMITTED, <span class="literal">true</span>);<span class="comment">//抛出异常</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">UNREACHABLE</span>(<span class="string">&quot;wrong IsolationLevel&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">CheckAppropriateLockOnTable</span>(txn, oid, lock_mode)) &#123;<span class="comment">//查看该row的Table是否加锁</span></span><br><span class="line">    <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::TABLE_LOCK_NOT_PRESENT, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  row_lock_map_latch_.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="keyword">if</span> (row_lock_map_.<span class="built_in">count</span>(rid) == <span class="number">0</span>) &#123;</span><br><span class="line">    row_lock_map_[rid] = std::<span class="built_in">make_shared</span>&lt;LockRequestQueue&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> lrq = row_lock_map_[rid];</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(lrq-&gt;latch_)</span></span>;</span><br><span class="line">  row_lock_map_latch_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否是一次锁升级(S-&gt;X)</span></span><br><span class="line">  <span class="type">bool</span> upgrade = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> iter = lrq-&gt;request_queue_.<span class="built_in">begin</span>(); iter != lrq-&gt;request_queue_.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">    <span class="keyword">auto</span> lr = *iter;</span><br><span class="line">    <span class="keyword">if</span> (lr-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (lr-&gt;lock_mode_ == lock_mode) &#123;  <span class="comment">// 重复的锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lrq-&gt;upgrading_ != INVALID_TXN_ID) &#123;  <span class="comment">// 抛出 UPGRADE_CONFLICT 异常</span></span><br><span class="line">        <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::UPGRADE_CONFLICT, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">CanLockUpgrade</span>(lr-&gt;lock_mode_, lock_mode)) &#123;  <span class="comment">// 抛 INCOMPATIBLE_UPGRADE 异常</span></span><br><span class="line">        <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::INCOMPATIBLE_UPGRADE, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      lrq-&gt;upgrading_ = txn-&gt;<span class="built_in">GetTransactionId</span>();</span><br><span class="line">      lrq-&gt;request_queue_.<span class="built_in">erase</span>(iter);</span><br><span class="line">      <span class="built_in">RemoveFromTxnRowLockSet</span>(txn, lr-&gt;lock_mode_, oid, rid);</span><br><span class="line">      <span class="keyword">delete</span> lr;</span><br><span class="line">      lrq-&gt;request_queue_.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">LockRequest</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid, rid));</span><br><span class="line">      upgrade = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!upgrade) &#123;</span><br><span class="line">    lrq-&gt;request_queue_.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">LockRequest</span>(txn-&gt;<span class="built_in">GetTransactionId</span>(), lock_mode, oid, rid));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">CanTxnTakeLock</span>(txn, lock_mode, lrq)) &#123;</span><br><span class="line">    lrq-&gt;cv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">    <span class="comment">// LOG_DEBUG(&quot;txn:%d wake&quot;, txn-&gt;GetTransactionId());</span></span><br><span class="line">    <span class="comment">// 死锁检测ABORT该事务 或者 手动ABORT该事务</span></span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">      <span class="comment">// LOG_DEBUG(&quot;txn:%d ABORT&quot;, txn-&gt;GetTransactionId());</span></span><br><span class="line">      <span class="comment">// 移除该事务对该资源的request</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> iter = lrq-&gt;request_queue_.<span class="built_in">begin</span>(); iter != lrq-&gt;request_queue_.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> lr = *iter;</span><br><span class="line">        <span class="keyword">if</span> (lr-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">          lrq-&gt;request_queue_.<span class="built_in">erase</span>(iter);</span><br><span class="line">          <span class="keyword">delete</span> lr;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lrq-&gt;cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">AddIntoTxnRowLockSet</span>(txn, lock_mode, oid, rid);</span><br><span class="line">  <span class="comment">// LOG_DEBUG(&quot;txn:%d LockRow oid:%d rid:%d:%d lock_mode:%d&quot;, txn-&gt;GetTransactionId(), oid, rid.GetPageId(),</span></span><br><span class="line">  <span class="comment">// rid.GetSlotNum(), lock_mode);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LockManager::UnlockRow</span><span class="params">(Transaction *txn, <span class="type">const</span> <span class="type">table_oid_t</span> &amp;oid, <span class="type">const</span> RID &amp;rid, <span class="type">bool</span> force)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  row_lock_map_latch_.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="keyword">if</span> (row_lock_map_.<span class="built_in">count</span>(rid) == <span class="number">0</span>) &#123;</span><br><span class="line">    row_lock_map_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::ATTEMPTED_UNLOCK_BUT_NO_LOCK_HELD, <span class="literal">true</span>);<span class="comment">//该row未加锁抛出异常</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> lrq = row_lock_map_[rid];</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(lrq-&gt;latch_)</span></span>;</span><br><span class="line">  row_lock_map_latch_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> iter = lrq-&gt;request_queue_.<span class="built_in">begin</span>(); iter != lrq-&gt;request_queue_.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    <span class="keyword">auto</span> lr = *iter;</span><br><span class="line">    <span class="keyword">if</span> (lr-&gt;granted_ &amp;&amp; lr-&gt;txn_id_ == txn-&gt;<span class="built_in">GetTransactionId</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!force) &#123;</span><br><span class="line">        <span class="keyword">auto</span> iso_level = txn-&gt;<span class="built_in">GetIsolationLevel</span>();</span><br><span class="line">        <span class="keyword">switch</span> (iso_level) &#123;</span><br><span class="line">          <span class="keyword">case</span> IsolationLevel::REPEATABLE_READ:</span><br><span class="line">            <span class="keyword">if</span> (lr-&gt;lock_mode_ == LockMode::SHARED || lr-&gt;lock_mode_ == LockMode::EXCLUSIVE) &#123;</span><br><span class="line">              txn-&gt;<span class="built_in">SetState</span>(TransactionState::SHRINKING);</span><br><span class="line">              <span class="comment">// LOG_DEBUG(&quot;txn:%d be set SHRINGKING&quot;, txn-&gt;GetTransactionId());</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> IsolationLevel::READ_COMMITTED:</span><br><span class="line">          <span class="keyword">case</span> IsolationLevel::READ_UNCOMMITTED:</span><br><span class="line">            <span class="keyword">if</span> (lr-&gt;lock_mode_ == LockMode::EXCLUSIVE) &#123;</span><br><span class="line">              txn-&gt;<span class="built_in">SetState</span>(TransactionState::SHRINKING);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">UNREACHABLE</span>(<span class="string">&quot;wrong IsolationLevel&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">RemoveFromTxnRowLockSet</span>(txn, lr-&gt;lock_mode_, oid, rid);</span><br><span class="line">      <span class="comment">// LOG_DEBUG(&quot;txn:%d UnlockRow oid:%d rid:%d:%d&quot;, txn-&gt;GetTransactionId(), oid, rid.GetPageId(),</span></span><br><span class="line">      <span class="comment">// rid.GetSlotNum());</span></span><br><span class="line">      lrq-&gt;request_queue_.<span class="built_in">erase</span>(iter);</span><br><span class="line">      <span class="keyword">delete</span> lr;</span><br><span class="line">      lrq-&gt;cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ABORT_FOR_REASON_DIRECTLY_OR_NOT</span>(AbortReason::ATTEMPTED_UNLOCK_BUT_NO_LOCK_HELD, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Task-2-Deadlock-Detection"><a href="#Task-2-Deadlock-Detection" class="headerlink" title="Task #2 - Deadlock Detection"></a>Task #2 - Deadlock Detection</h2><p>锁管理器应该在后台线程中运行死锁检测，定期构建等待图并根据需要中止事务以消除死锁。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给LockManger添加死锁检测所需的数据成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockManager</span> &#123;</span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; enable_cycle_detection_;</span><br><span class="line">  std::thread *cycle_detection_thread_;</span><br><span class="line">  <span class="comment">/** Waits-for graph representation. */</span></span><br><span class="line">  std::map&lt;<span class="type">txn_id_t</span>, std::set&lt;<span class="type">txn_id_t</span>&gt;&gt; waits_for_;</span><br><span class="line">  <span class="comment">// std::unordered_map&lt;txn_id_t, int&gt; node_value_;</span></span><br><span class="line">  <span class="comment">// std::vector&lt;txn_id_t&gt; route_;</span></span><br><span class="line">  std::vector&lt;<span class="type">txn_id_t</span>&gt; stk_;</span><br><span class="line">  std::unordered_map&lt;<span class="type">txn_id_t</span>, <span class="type">bool</span>&gt; in_stk_;</span><br><span class="line">  std::unordered_map&lt;<span class="type">txn_id_t</span>, <span class="type">bool</span>&gt; has_search_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>开启死锁检测的后台线程<br><img src="/../images/cmu15445-project4/13.png" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LockManager::RunCycleDetection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (enable_cycle_detection_) &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(cycle_detection_interval);</span><br><span class="line">    &#123;</span><br><span class="line">      waits_for_.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="built_in">BuildGraph</span>();<span class="comment">//构建等待图</span></span><br><span class="line">      <span class="comment">// PrintGraph();</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        stk_.<span class="built_in">clear</span>();</span><br><span class="line">        in_stk_.<span class="built_in">clear</span>();</span><br><span class="line">        has_search_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">txn_id_t</span> abort_tid;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">HasCycle</span>(&amp;abort_tid)) &#123;<span class="comment">//判断是否有环，如果有获取abort_id</span></span><br><span class="line">          <span class="comment">// LOG_DEBUG(&quot;abort_tid:%d&quot;, abort_tid);</span></span><br><span class="line">          <span class="keyword">auto</span> txn = txn_manager_-&gt;<span class="built_in">GetTransaction</span>(abort_tid);</span><br><span class="line">          txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">          <span class="built_in">RemoveAllAboutAbortTxn</span>(abort_tid);<span class="comment">//删除有向图中该abort_tid的所有入边和出边</span></span><br><span class="line">          <span class="built_in">WakeAbortedTxn</span>(abort_tid);<span class="comment">//该abort_tid的事务所占有的资源的cv_进行notify_all</span></span><br><span class="line">          <span class="comment">// LOG_DEBUG(&quot;dead_detect notify all&quot;);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HasCycle函数判断是否有环，并且返回环中最大的txn_id</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LockManager::HasCycle</span><span class="params">(<span class="type">txn_id_t</span> *txn_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">any_of</span>(waits_for_.<span class="built_in">begin</span>(), waits_for_.<span class="built_in">end</span>(),</span><br><span class="line">                     [<span class="keyword">this</span>, txn_id](<span class="type">const</span> std::pair&lt;<span class="type">txn_id_t</span>, std::set&lt;<span class="type">txn_id_t</span>&gt;&gt; &amp;p) &#123;</span><br><span class="line">                       <span class="keyword">auto</span> k = p.first;</span><br><span class="line">                       <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;has_search_[k] &amp;&amp; <span class="built_in">DFS</span>(k)) &#123;</span><br><span class="line">                         <span class="keyword">auto</span> iter = std::<span class="built_in">find</span>(<span class="keyword">this</span>-&gt;stk_.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;stk_.<span class="built_in">end</span>() - <span class="number">1</span>, <span class="keyword">this</span>-&gt;stk_.<span class="built_in">back</span>());</span><br><span class="line">                         *txn_id = <span class="number">-1</span>;</span><br><span class="line">                         <span class="keyword">while</span> (iter != <span class="keyword">this</span>-&gt;stk_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (*iter &gt; *txn_id) &#123;</span><br><span class="line">                             *txn_id = *iter;</span><br><span class="line">                           &#125;</span><br><span class="line">                           ++iter;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">this</span>-&gt;stk_.<span class="built_in">clear</span>();</span><br><span class="line">                         <span class="keyword">this</span>-&gt;in_stk_.<span class="built_in">clear</span>();</span><br><span class="line">                         <span class="keyword">this</span>-&gt;has_search_.<span class="built_in">clear</span>();</span><br><span class="line">                         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">this</span>-&gt;stk_.<span class="built_in">clear</span>();</span><br><span class="line">                       <span class="keyword">this</span>-&gt;in_stk_.<span class="built_in">clear</span>();</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                     &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DFS函数判断是否有环,txn_id为遍历的起始点</span></span><br><span class="line"><span class="comment">//有环返回true 无环返回false</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LockManager::DFS</span><span class="params">(<span class="type">txn_id_t</span> txn_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  has_search_[txn_id] = <span class="literal">true</span>;</span><br><span class="line">  stk_.<span class="built_in">push_back</span>(txn_id);</span><br><span class="line">  in_stk_[txn_id] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> id : waits_for_[txn_id]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!has_search_[id]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">DFS</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in_stk_[id]) &#123;</span><br><span class="line">      stk_.<span class="built_in">push_back</span>(id);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  stk_.<span class="built_in">pop_back</span>();</span><br><span class="line">  in_stk_[txn_id] = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Task-3-Concurrent-Query-Execution"><a href="#Task-3-Concurrent-Query-Execution" class="headerlink" title="Task #3 - Concurrent Query Execution"></a>Task #3 - Concurrent Query Execution</h2><p>TransactionManager的Abort函数需要恢复Table和对应Index的原始状态</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TransactionManager::Commit</span><span class="params">(Transaction *txn)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Release all the locks.</span></span><br><span class="line">  <span class="built_in">ReleaseLocks</span>(txn);</span><br><span class="line"></span><br><span class="line">  txn-&gt;<span class="built_in">SetState</span>(TransactionState::COMMITTED);</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">guard</span><span class="params">(txn_map_mutex_)</span></span>;</span><br><span class="line">  txn_map_.<span class="built_in">erase</span>(txn-&gt;<span class="built_in">GetTransactionId</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TransactionManager::Abort</span><span class="params">(Transaction *txn)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> revert all the changes in write set */</span></span><br><span class="line">  <span class="keyword">while</span> (!txn-&gt;<span class="built_in">GetWriteSet</span>()-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> twr = txn-&gt;<span class="built_in">GetWriteSet</span>()-&gt;<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">if</span> (twr.wtype_ == WType::INSERT) &#123;</span><br><span class="line">      <span class="keyword">auto</span> tuple_meta = twr.table_heap_-&gt;<span class="built_in">GetTupleMeta</span>(twr.rid_);</span><br><span class="line">      tuple_meta.is_deleted_ = <span class="literal">true</span>;</span><br><span class="line">      twr.table_heap_-&gt;<span class="built_in">UpdateTupleMeta</span>(tuple_meta, twr.rid_);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (twr.wtype_ == WType::DELETE) &#123;</span><br><span class="line">      <span class="keyword">auto</span> tuple_meta = twr.table_heap_-&gt;<span class="built_in">GetTupleMeta</span>(twr.rid_);</span><br><span class="line">      tuple_meta.is_deleted_ = <span class="literal">false</span>;</span><br><span class="line">      twr.table_heap_-&gt;<span class="built_in">UpdateTupleMeta</span>(tuple_meta, twr.rid_);</span><br><span class="line">    &#125;</span><br><span class="line">    txn-&gt;<span class="built_in">GetWriteSet</span>()-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!txn-&gt;<span class="built_in">GetIndexWriteSet</span>()-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> iwr = txn-&gt;<span class="built_in">GetIndexWriteSet</span>()-&gt;<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">if</span> (iwr.wtype_ == WType::INSERT) &#123;</span><br><span class="line">      iwr.catalog_-&gt;<span class="built_in">GetIndex</span>(iwr.index_oid_)-&gt;index_-&gt;<span class="built_in">DeleteEntry</span>(iwr.tuple_, iwr.rid_, txn);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iwr.wtype_ == WType::DELETE) &#123;</span><br><span class="line">      iwr.catalog_-&gt;<span class="built_in">GetIndex</span>(iwr.index_oid_)-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(iwr.tuple_, iwr.rid_, txn);</span><br><span class="line">    &#125;</span><br><span class="line">    txn-&gt;<span class="built_in">GetIndexWriteSet</span>()-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReleaseLocks</span>(txn);</span><br><span class="line"></span><br><span class="line">  txn-&gt;<span class="built_in">SetState</span>(TransactionState::ABORTED);</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">guard</span><span class="params">(txn_map_mutex_)</span></span>;</span><br><span class="line">  txn_map_.<span class="built_in">erase</span>(txn-&gt;<span class="built_in">GetTransactionId</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SeqScanExecutor修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SeqScanExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = catalog-&gt;<span class="built_in">GetTable</span>(plan_-&gt;table_oid_);</span><br><span class="line">  <span class="keyword">auto</span> txn = exec_ctx_-&gt;<span class="built_in">GetTransaction</span>();</span><br><span class="line">  <span class="keyword">auto</span> iso_level = txn-&gt;<span class="built_in">GetIsolationLevel</span>();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (exec_ctx_-&gt;<span class="built_in">IsDelete</span>()) &#123;<span class="comment">//当前进行的sql操作是DELETE或者UPDATE</span></span><br><span class="line">      <span class="keyword">auto</span> res =</span><br><span class="line">          exec_ctx_-&gt;<span class="built_in">GetLockManager</span>()-&gt;<span class="built_in">LockTable</span>(txn, LockManager::LockMode::INTENTION_EXCLUSIVE, plan_-&gt;table_oid_);</span><br><span class="line">      <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;SeqScanExecutor LockTable Failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!txn-&gt;<span class="built_in">IsTableIntentionExclusiveLocked</span>(plan_-&gt;table_oid_) &amp;&amp;  <span class="comment">// 避免反向升级</span></span><br><span class="line">               (iso_level == IsolationLevel::READ_COMMITTED || iso_level == IsolationLevel::REPEATABLE_READ)) &#123;</span><br><span class="line">      <span class="keyword">auto</span> res =</span><br><span class="line">          exec_ctx_-&gt;<span class="built_in">GetLockManager</span>()-&gt;<span class="built_in">LockTable</span>(txn, LockManager::LockMode::INTENTION_SHARED, plan_-&gt;table_oid_);</span><br><span class="line">      <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;SeqScanExecutor LockTable Failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (TransactionAbortException &amp;exception) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;SeqScanExecutor LockTable Failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  iterator_ = std::<span class="built_in">make_unique</span>&lt;TableIterator&gt;(table_info_-&gt;table_-&gt;<span class="built_in">MakeEagerIterator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SeqScanExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  std::pair&lt;TupleMeta, Tuple&gt; pair;</span><br><span class="line">  <span class="keyword">auto</span> txn = exec_ctx_-&gt;<span class="built_in">GetTransaction</span>();</span><br><span class="line">  <span class="keyword">auto</span> iso_level = txn-&gt;<span class="built_in">GetIsolationLevel</span>();</span><br><span class="line">  <span class="keyword">while</span> (!iterator_-&gt;<span class="built_in">IsEnd</span>()) &#123;</span><br><span class="line">    pair = iterator_-&gt;<span class="built_in">GetTuple</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (exec_ctx_-&gt;<span class="built_in">IsDelete</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> res = exec_ctx_-&gt;<span class="built_in">GetLockManager</span>()-&gt;<span class="built_in">LockRow</span>(txn, LockManager::LockMode::EXCLUSIVE, plan_-&gt;table_oid_, pair.second.<span class="built_in">GetRid</span>());</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;SeqScanExecutor LockRow Failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!txn-&gt;<span class="built_in">IsRowExclusiveLocked</span>(plan_-&gt;table_oid_, pair.second.<span class="built_in">GetRid</span>()) &amp;&amp;  <span class="comment">// 避免反向升级</span></span><br><span class="line">                 (iso_level == IsolationLevel::READ_COMMITTED || iso_level == IsolationLevel::REPEATABLE_READ)) &#123;</span><br><span class="line">        <span class="keyword">auto</span> res = exec_ctx_-&gt;<span class="built_in">GetLockManager</span>()-&gt;<span class="built_in">LockRow</span>(txn, LockManager::LockMode::SHARED, plan_-&gt;table_oid_, pair.second.<span class="built_in">GetRid</span>());</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;SeqScanExecutor LockRow Failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (TransactionAbortException &amp;exception) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;SeqScanExecutor LockRow Failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iterator_-&gt;<span class="built_in">GetTuple</span>().first.is_deleted_ ||</span><br><span class="line">        (plan_-&gt;filter_predicate_ &amp;&amp;</span><br><span class="line">         plan_-&gt;filter_predicate_-&gt;<span class="built_in">Evaluate</span>(&amp;pair.second, table_info_-&gt;schema_)</span><br><span class="line">                 .<span class="built_in">CompareEquals</span>(ValueFactory::<span class="built_in">GetBooleanValue</span>(<span class="literal">false</span>)) == CmpBool::CmpTrue)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (exec_ctx_-&gt;<span class="built_in">IsDelete</span>() ||</span><br><span class="line">          (iso_level == IsolationLevel::READ_COMMITTED || iso_level == IsolationLevel::REPEATABLE_READ)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">auto</span> res = exec_ctx_-&gt;<span class="built_in">GetLockManager</span>()-&gt;<span class="built_in">UnlockRow</span>(txn, plan_-&gt;table_oid_, pair.second.<span class="built_in">GetRid</span>(), <span class="literal">true</span>);</span><br><span class="line">          <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;SeqScanExecutor Force UnLockRow Failed&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="built_in">catch</span> (TransactionAbortException &amp;exception) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;SeqScanExecutor Force UnLockRow Failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++(*iterator_);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!exec_ctx_-&gt;<span class="built_in">IsDelete</span>() &amp;&amp; iso_level == IsolationLevel::READ_COMMITTED) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> res = exec_ctx_-&gt;<span class="built_in">GetLockManager</span>()-&gt;<span class="built_in">UnlockRow</span>(txn, plan_-&gt;table_oid_, pair.second.<span class="built_in">GetRid</span>());</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;SeqScanExecutor UnLockRow Failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="built_in">catch</span> (TransactionAbortException &amp;exception) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;SeqScanExecutor UnLockRow Failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++(*iterator_);</span><br><span class="line">    *tuple = std::<span class="built_in">move</span>(pair.second);</span><br><span class="line">    *rid = tuple-&gt;<span class="built_in">GetRid</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!exec_ctx_-&gt;<span class="built_in">IsDelete</span>() &amp;&amp; iso_level == IsolationLevel::READ_COMMITTED) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> res = exec_ctx_-&gt;<span class="built_in">GetLockManager</span>()-&gt;<span class="built_in">UnlockTable</span>(txn, plan_-&gt;table_oid_);</span><br><span class="line">      <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;SeqScanExecutor UnLockTable Failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (TransactionAbortException &amp;exception) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;SeqScanExecutor UnLockTable Failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InsertExecutor修改，给table加IE锁，并且table和index插入记录需要被保存下来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  <span class="keyword">auto</span> cata_log = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = cata_log-&gt;<span class="built_in">GetTable</span>(plan_-&gt;table_oid_);</span><br><span class="line">  index_infos_ = cata_log-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">  successful_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> txn = exec_ctx_-&gt;<span class="built_in">GetTransaction</span>();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> res =</span><br><span class="line">        exec_ctx_-&gt;<span class="built_in">GetLockManager</span>()-&gt;<span class="built_in">LockTable</span>(txn, LockManager::LockMode::INTENTION_EXCLUSIVE, plan_-&gt;table_oid_);</span><br><span class="line">    <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;InsertExecutor LockTable Failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (TransactionAbortException &amp;exception) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">ExecutionException</span>(<span class="string">&quot;InsertExecutor LockTable Failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">InsertExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  TupleMeta meta;</span><br><span class="line">  <span class="keyword">if</span> (successful_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  meta.insert_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  meta.delete_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  meta.is_deleted_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;</span><br><span class="line">    <span class="keyword">auto</span> tuple_rid = table_info_-&gt;table_-&gt;<span class="built_in">InsertTuple</span>(meta, *tuple, exec_ctx_-&gt;<span class="built_in">GetLockManager</span>(), exec_ctx_-&gt;<span class="built_in">GetTransaction</span>(), table_info_-&gt;oid_);</span><br><span class="line">    <span class="keyword">if</span> (tuple_rid == std::<span class="literal">nullopt</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> twr = <span class="built_in">TableWriteRecord</span>(table_info_-&gt;oid_, tuple_rid.<span class="built_in">value</span>(), table_info_-&gt;table_.<span class="built_in">get</span>());</span><br><span class="line">    twr.wtype_ = WType::INSERT;</span><br><span class="line">    exec_ctx_-&gt;<span class="built_in">GetTransaction</span>()-&gt;<span class="built_in">GetWriteSet</span>()-&gt;<span class="built_in">push_back</span>(twr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;</span><br><span class="line">      <span class="keyword">auto</span> key = tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(key, *tuple_rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">      <span class="keyword">auto</span> iwr = <span class="built_in">IndexWriteRecord</span>(tuple_rid.<span class="built_in">value</span>(), table_info_-&gt;oid_, WType::INSERT, key, index_info-&gt;index_oid_,</span><br><span class="line">                                  exec_ctx_-&gt;<span class="built_in">GetCatalog</span>());</span><br><span class="line">      exec_ctx_-&gt;<span class="built_in">GetTransaction</span>()-&gt;<span class="built_in">GetIndexWriteSet</span>()-&gt;<span class="built_in">push_back</span>(iwr);</span><br><span class="line">    &#125;</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">emplace_back</span>(TypeId::INTEGER, count);</span><br><span class="line">  *tuple = <span class="built_in">Tuple</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">  successful_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DeleteExecutor修改，并且table和index删除记录需要被保存下来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  successful_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = catalog-&gt;<span class="built_in">GetTable</span>(plan_-&gt;<span class="built_in">TableOid</span>());</span><br><span class="line">  index_infos_ = catalog-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">DeleteExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  TupleMeta tuple_meta;</span><br><span class="line">  <span class="keyword">if</span> (successful_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tuple_meta.delete_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  tuple_meta.insert_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  tuple_meta.is_deleted_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">auto</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;</span><br><span class="line">    table_info_-&gt;table_-&gt;<span class="built_in">UpdateTupleMeta</span>(tuple_meta, *rid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> twr = <span class="built_in">TableWriteRecord</span>(table_info_-&gt;oid_, *rid, table_info_-&gt;table_.<span class="built_in">get</span>());</span><br><span class="line">    twr.wtype_ = WType::DELETE;</span><br><span class="line">    exec_ctx_-&gt;<span class="built_in">GetTransaction</span>()-&gt;<span class="built_in">GetWriteSet</span>()-&gt;<span class="built_in">push_back</span>(twr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;</span><br><span class="line">      <span class="keyword">auto</span> key = tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">DeleteEntry</span>(key, *rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span> iwr = <span class="built_in">IndexWriteRecord</span>(*rid, table_info_-&gt;oid_, WType::DELETE, key, index_info-&gt;index_oid_,</span><br><span class="line">                                  exec_ctx_-&gt;<span class="built_in">GetCatalog</span>());</span><br><span class="line">      exec_ctx_-&gt;<span class="built_in">GetTransaction</span>()-&gt;<span class="built_in">GetIndexWriteSet</span>()-&gt;<span class="built_in">push_back</span>(iwr);</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">emplace_back</span>(TypeId::INTEGER, count);</span><br><span class="line">  *tuple = <span class="built_in">Tuple</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">  successful_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五种细粒度锁IS IX S SIX X相容矩阵</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">IS</th>
<th align="center">IX</th>
<th align="center">S</th>
<th align="center">SIX</th>
<th align="center">X</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IS</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">NO</td>
</tr>
<tr>
<td align="center">IX</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">NO</td>
<td align="center">NO</td>
<td align="center">NO</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">YES</td>
<td align="center">NO</td>
<td align="center">YES</td>
<td align="center">NO</td>
<td align="center">NO</td>
</tr>
<tr>
<td align="center">SIX</td>
<td align="center">YES</td>
<td align="center">NO</td>
<td align="center">NO</td>
<td align="center">NO</td>
<td align="center">NO</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">NO</td>
<td align="center">NO</td>
<td align="center">NO</td>
<td align="center">NO</td>
<td align="center">NO</td>
</tr>
</tbody></table>
<p>本地测试通过：<br><img src="/../images/cmu15445-project4/14.png" alt="img"><br><img src="/../images/cmu15445-project4/15.png" alt="img"><br><img src="/../images/cmu15445-project4/16.png" alt="img"><br><img src="/../images/cmu15445-project4/17.png" alt="img"><br><img src="/../images/cmu15445-project4/18.png" alt="img"></p>
<p>线上测试通过:<br><img src="/../images/cmu15445-project4/19.png" alt="img"></p>
]]></content>
      <categories>
        <category>cmu15445-2023</category>
      </categories>
      <tags>
        <tag>cmu15445—2023</tag>
      </tags>
  </entry>
  <entry>
    <title>configure命令</title>
    <url>/2023/05/28/configure%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_40941932/article/details/109992151">参考</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>configure</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript基础语法</title>
    <url>/2024/05/11/javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>值类型(基本类型)</strong>  ：字符串（String）、数字(Number)、布尔(Boolean)、空（null）、未定义（Undefined）、Symbol。</p>
<blockquote>
<p>所有的值类型(基本类型), 除了null和undefined, 都可以被看做对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>js中一切皆对象</p>
</blockquote>
<p><strong>引用数据类型(对象类型)</strong> ： 对象(Object)、数组(Array)、函数(Function)、正则（RegExp）和日期（Date）</p>
<p><img src="/../images/javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1.png" alt="img"></p>
<blockquote>
<p>ps: 定义变量得使用 var 或者 let<br>可以用typeof 来查看变量的类型</p>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>class关键字是原型系统上的一个语法糖，创造了一种基于类的语言的错觉。</p>
<p><strong>proto</strong>, prototype, constructor的关系</p>
<p><img src="/../images/javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/3.png" alt="img"></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下目录各个文件夹详解</title>
    <url>/2023/05/28/linux%E4%B8%8B%E7%9B%AE%E5%BD%95%E5%90%84%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_39652397/article/details/123794887">参考</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux不同目录详解</tag>
      </tags>
  </entry>
  <entry>
    <title>linux文件权限和属性</title>
    <url>/2023/05/28/linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%92%8C%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>如果一个文件被设置了SUID或SGID位，会分别表现在所有者或同组用户的权限的可执行位上。例如：</p>
<p>1、-rwsr-xr-x 表示SUID和所有者权限中可执行位被设置</p>
<p>2、-rwSr–r– 表示SUID被设置，但所有者权限中可执行位没有被设置</p>
<p>3、-rwxr-sr-x 表示SGID和同组用户权限中可执行位被设置</p>
<p>4、-rw-r-Sr– 表示SGID被设置，但同组用户权限中可执行位没有被设置</p>
<p>给文件加SUID和SUID的命令如下：</p>
<p>chmod u+s filename 设置SUID位</p>
<p>chmod u-s filename 去掉SUID设置</p>
<p>chmod g+s filename 设置SGID位</p>
<p>chmod g-s filename 去掉SGID设置</p>
<p>SUID属性<br>例如&#x2F;usr&#x2F;bin&#x2F;passwd  带有SUID属性 属于root用户 root用户主<br>其它用户只有&#x2F;usr&#x2F;bin&#x2F;passwd的可执行权限，在执行这个命令时会暂时获取root权限</p>
<p>SGID属性<br>和SUID属性十分相似<br>不同的是其它用户在执行有SGID属性的命令时，会暂时获取该程序群组的支持</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux文件权限</tag>
      </tags>
  </entry>
  <entry>
    <title>linux配置环境变量</title>
    <url>/2023/05/28/linux%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/an520_/article/details/125220048">参考</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux环境变量配置</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh免密登录失败</title>
    <url>/2024/02/28/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<h2 id="SSH免密码失败原因定位分析"><a href="#SSH免密码失败原因定位分析" class="headerlink" title="SSH免密码失败原因定位分析"></a>SSH免密码失败原因定位分析</h2><ol>
<li>服务器B上.ssh目录的权限必须是700</li>
<li>服务器B上.authorized_keys文件权限必须是600或者644</li>
<li>服务器B上用户家目录文件权限必须是700，比如用户名是aischang，则&#x2F;home&#x2F;aischang这个目录权限必须是700</li>
</ol>
<p>如果不是700，在服务器A上查看&#x2F;var&#x2F;log&#x2F;secure文件会报错</p>
<h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>sshd为了安全，对属主的目录和文件权限有所要求。如果权限不对，则ssh的免密码登陆不生效。</p>
<blockquote>
<ol>
<li>服务器B上SELinux关闭为disabled，可以使用命令修改setenforce 0 ，查看状态的命令为getenforce或者 查看&#x2F;etc&#x2F;selinux&#x2F;config 文件中是否是disabled</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>有可能是StrictModes问题<br><br> 编辑 vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br><br> 找到#StrictModes yes改成StrictModes no</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>有可能是PubkeyAuthentication问题<br><br> 编辑 vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br><br> 找到PubkeyAuthentication改成yes</li>
</ol>
</blockquote>
<p>如果还不行，可以在服务器A上用ssh -vvv 机器B的ip 查看详情，根据输出内容具体问题具体分析了</p>
<p>参考链接: <a href="https://juejin.cn/s/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0">https://juejin.cn/s/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3学习——Tutorial</title>
    <url>/2024/05/12/vue3%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Tutorial/</url>
    <content><![CDATA[<h3 id="reactive-和-ref"><a href="#reactive-和-ref" class="headerlink" title="reactive() 和 ref()"></a>reactive() 和 ref()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; reactive, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count is: &#123;&#123; counter.count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>v-bind:id&#x3D;””<br><br>v-bind:class&#x3D;””<br><br>v-bind:value&#x3D;””<br></p>
<p>简化为<br></p>
<p>:id&#x3D;””<br><br>:class&#x3D;””<br><br>:value&#x3D;””<br></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> titleClass = <span class="title function_">ref</span>(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">&quot;titleClass&quot;</span>&gt;</span>Make me red<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.title</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>Event Listeners</p>
<p>v-on:click&#x3D;””<br><br>v-on:input&#x3D;””<br></p>
<p>简化为<br></p>
<p>@click&#x3D;””<br><br>@input&#x3D;””<br></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  count.<span class="property">value</span>++</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>Count is: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Type here&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="v-if-和-v-else"><a href="#v-if-和-v-else" class="headerlink" title="v-if 和 v-else"></a>v-if 和 v-else</h3><p>Conditional Rendering</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> awesome = <span class="title function_">ref</span>(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toggle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  awesome.<span class="property">value</span> = !awesome.<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toggle&quot;</span>&gt;</span>Toggle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;awesome&quot;</span>&gt;</span>Vue is awesome!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>Oh no 😢<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>List Rendering</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// give each todo a unique id</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newTodo = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> todos = <span class="title function_">ref</span>([</span><br><span class="line">  &#123; <span class="attr">id</span>: id++, <span class="attr">text</span>: <span class="string">&#x27;Learn HTML&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: id++, <span class="attr">text</span>: <span class="string">&#x27;Learn JavaScript&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: id++, <span class="attr">text</span>: <span class="string">&#x27;Learn Vue&#x27;</span> &#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">// const index = ref(&quot;123&quot;)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTodo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  todos.<span class="property">value</span>.<span class="title function_">push</span>(&#123;<span class="attr">id</span>: id++, <span class="attr">text</span>: newTodo.<span class="property">value</span>&#125;);</span><br><span class="line">  newTodo.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeTodo</span>(<span class="params">todo</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// index.value</span></span><br><span class="line">  todos.<span class="property">value</span>.<span class="title function_">splice</span>(todos.<span class="property">value</span>.<span class="title function_">indexOf</span>(todo), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>=<span class="string">&quot;addTodo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;newTodo&quot;</span> <span class="attr">required</span> <span class="attr">placeholder</span>=<span class="string">&quot;new todo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Add Todo<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--   &lt;p&gt;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    &#123;&#123;index&#125;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  &lt;/p&gt; --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;&#123; todo.text &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;removeTodo(todo)&quot;</span>&gt;</span>X<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>


<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><blockquote>
<p>introducing computed().We can create a computed ref that computes its .value based on other reactive data sources:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> id = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newTodo = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> hideCompleted = <span class="title function_">ref</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">const</span> todos = <span class="title function_">ref</span>([</span><br><span class="line">  &#123; <span class="attr">id</span>: id++, <span class="attr">text</span>: <span class="string">&#x27;Learn HTML&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: id++, <span class="attr">text</span>: <span class="string">&#x27;Learn JavaScript&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: id++, <span class="attr">text</span>: <span class="string">&#x27;Learn Vue&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filteredTodos = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> hideCompleted.<span class="property">value</span></span><br><span class="line">    ? todos.<span class="property">value</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">t</span>) =&gt;</span> !t.<span class="property">done</span>)</span><br><span class="line">    : todos.<span class="property">value</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTodo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  todos.<span class="property">value</span>.<span class="title function_">push</span>(&#123; <span class="attr">id</span>: id++, <span class="attr">text</span>: newTodo.<span class="property">value</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">  newTodo.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeTodo</span>(<span class="params">todo</span>) &#123;</span><br><span class="line">  todos.<span class="property">value</span> = todos.<span class="property">value</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">t</span>) =&gt;</span> t !== todo)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;form @submit.prevent=&quot;addTodo&quot;&gt;</span><br><span class="line">    &lt;input v-model=&quot;newTodo&quot; required placeholder=&quot;new todo&quot;&gt;</span><br><span class="line">    &lt;button&gt;Add Todo&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;todo in filteredTodos&quot; :key=&quot;todo.id&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt;</span><br><span class="line">      &lt;span :class=&quot;&#123; done: todo.done &#125;&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;button @click=&quot;hideCompleted = !hideCompleted&quot;&gt;</span><br><span class="line">    &#123;&#123; hideCompleted ? &#x27;Show all&#x27; : &#x27;Hide completed&#x27; &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.done &#123;</span><br><span class="line">  text-decoration: line-through;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Lifecycle-and-Template-Refs"><a href="#Lifecycle-and-Template-Refs" class="headerlink" title="Lifecycle and Template Refs"></a>Lifecycle and Template Refs</h3><blockquote>
<p>Hook函数 onMounted onUpdated 等 …</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pElementRef = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> customValue = <span class="title function_">ref</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  customValue.<span class="property">value</span> = pElementRef.<span class="property">value</span>.<span class="property">textContent</span></span><br><span class="line">  pElementRef.<span class="property">value</span>.<span class="property">textContent</span> = <span class="string">&#x27;mounted!&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123;customValue&#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&quot;pElementRef&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(count, <span class="function">(<span class="params">newCount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// yes, console.log() is a side effect</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`new count is: <span class="subst">$&#123;newCount&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>watch() can directly watch a ref, and the callback gets fired whenever count’s value changes.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoId = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> todoData = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  todoData.<span class="property">value</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(</span><br><span class="line">    <span class="string">`https://jsonplaceholder.typicode.com/todos/<span class="subst">$&#123;id.value&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">  todoData.<span class="property">value</span> = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="title function_">fetchData</span>(todoId)</span><br><span class="line"><span class="title function_">watch</span>(todoId, <span class="function">(<span class="params">todoId</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">fetchData</span>(todoId);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Todo id: &#123;&#123; todoId &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;todoId++&quot;</span> <span class="attr">:disabled</span>=<span class="string">&quot;!todoData&quot;</span>&gt;</span>Fetch next todo<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;!todoData&quot;</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">pre</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; todoData &#125;&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComp</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComp.vue&#x27;</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- render child component --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">ChildComp</span>&gt;</span><span class="tag">&lt;/<span class="name">ChildComp</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><blockquote>
<p>A child component can accept input from the parent via props. First, it needs to declare the props it accepts:</p>
</blockquote>
<p>App.vue</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComp</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComp.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greeting = <span class="title function_">ref</span>(<span class="string">&#x27;Hello from parent&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">ChildComp</span> <span class="attr">:msg</span>=<span class="string">&quot;greeting&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>ChildComp.vue</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="title class_">String</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; msg || &#x27;No props passed yet&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Emits"><a href="#Emits" class="headerlink" title="Emits"></a>Emits</h3><blockquote>
<p>In addition to receiving props, a child component can also emit events to the parent:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">const childMsg = ref(&#x27;No child msg yet&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp @response=&quot;(msg) =&gt; childMsg = msg &quot; @response1=&quot;(msg)=&gt; childMsg=msg&quot;/&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; childMsg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits([&#x27;response&#x27;, &#x27;response1&#x27;])</span><br><span class="line"></span><br><span class="line">emit(&#x27;response&#x27;, &#x27;hello from child&#x27;)</span><br><span class="line">emit(&#x27;response1&#x27;, &quot;flafkjka&quot;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;Child component&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Slots"><a href="#Slots" class="headerlink" title="Slots"></a>Slots</h3><blockquote>
<p>In addition to passing data via props, the parent component can also pass down template fragments to the child via slots</p>
</blockquote>
<p>App.vue</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ChildComp</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComp.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> msg = <span class="title function_">ref</span>(<span class="string">&#x27;from parent&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">ChildComp</span>&gt;</span><span class="tag">&lt;/<span class="name">ChildComp</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>ChildComp.vue</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">slot</span>&gt;</span>Fallback content<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>动态链接</title>
    <url>/2023/05/28/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h3 id="静态链接浪费内存和磁盘空间并且更新困难。动态链接的基本思想：-把链接过程推迟到运行时进行。"><a href="#静态链接浪费内存和磁盘空间并且更新困难。动态链接的基本思想：-把链接过程推迟到运行时进行。" class="headerlink" title="静态链接浪费内存和磁盘空间并且更新困难。动态链接的基本思想： 把链接过程推迟到运行时进行。"></a>静态链接浪费内存和磁盘空间并且更新困难。动态链接的基本思想： 把链接过程推迟到运行时进行。</h3><p>-shared</p>
<blockquote>
<p>生成动态链接模块时只使用-shared，由于装载时重定位的方法需要修改指令，没有办法做到同一份指令被多个进程共享，因为指令被重定位之后对于每个进程来讲是不同的。</p>
</blockquote>
<p>-fPIC 地址无关代码</p>
<blockquote>
<p>实现的基本思想就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分可以保持不变，而数据部分在每个进程中拥有一个副本。这种方案就是地址无关技术</p>
</blockquote>
<p>GOT全局偏移表</p>
<blockquote>
<p>对于动态链接模块中,对于外部符号（数据）的访问的机制，当指令需要访问某个外部变量时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4个字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项。由于GOT表本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本。</p>
</blockquote>
<p>-fPIE</p>
<blockquote>
<p>地址无关代码技术除了可以用在动态链接模块上，它也可以用于可执行文件</p>
</blockquote>
<p>共享模块（动态链接模块）的全局变量问题</p>
<blockquote>
<p>当一个模块引用了定义在共享对象的全局变量的时候，由于可执行文件在之前链接时就必须确定该全局变量的地址，所以连接器会在创建可执行文件时，在它的.bss段创建一个global变量的副本。导致同一变量同时存在于多个位置<br>于是解决的办法只有一个，那就是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。ELF共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量，也就是说当作前面的类型四，通过GOT来实现变量的访问。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把GOT中的相应地址指向该副本，这样该变量在运行时实际上最终就只有一个实例。如果变量在共享模块中被初始化，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本；如果该全局变量在程序主模块中没有副本，那么GOT中的相应地址就指向模块内部的该变量副本。</p>
</blockquote>
<p><strong>默认情况下，如果可执行文件是动态链接的，那么GCC会使用PIC的方法来产生可执行文件的代码段部分，以便于不同的进程能够共享代码段，节省内存。所以动态链接的可执行文件中存在.got段</strong></p>
<p>延迟绑定</p>
<blockquote>
<p>由于动态链接下对于全局数据的访问和跨模块的调用都要进行复杂的GOT定位，然后间接寻址或调用，导致程序的运行速度减慢大概1%~%5。又因为动态链接的链接工作在运行时完成，导致程序的启动速度减慢。<br>程序运行过程中，会有很多函数没有用到（错误处理函数，没有使用的功能模块等），所以没有必要一开始就把所有函数都链接好，ELF采用延迟绑定的方法，基本思想是当函数第一次被用到时才由动态链接器进行绑定（符号查找，重定位等），没用到的不绑定。这提高了程序的启动速度。<br>ELF使用PLT（Procedure Linkage Table）来实现延迟绑定,它使用了一些很精巧的指令序列来完成</p>
</blockquote>
<p>ELF将GOT拆分成了两个表.got和.got.plt，其中.got用来保存全局变量引用的地址，.got.plt用来保存函数引用的地址<br>PLT在ELF文件中以独立的段存放，段名通常叫做.plt，因为它本身是一些地址无关代码，所以可以跟代码段合并成同一个可读可写可执行的“Segment”被载入内存<br><a href="https://markrepo.github.io/kernel/2018/08/19/dynamic-link/">参考链接</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>链接、装载与库</tag>
      </tags>
  </entry>
  <entry>
    <title>动手深度学习</title>
    <url>/2023/05/28/%E5%8A%A8%E6%89%8B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h2><p>正规方程是通过求解下面的方程来找出使得代价最小的函数<img src="/images/%E5%8A%A8%E6%89%8B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/1.jpg"><br>只适用于线性模型，不适合逻辑回归模型等其它模型</p>
<h2 id="过拟合、欠拟合、权重衰退"><a href="#过拟合、欠拟合、权重衰退" class="headerlink" title="过拟合、欠拟合、权重衰退"></a>过拟合、欠拟合、权重衰退</h2><h3 id="训练误差和泛化误差"><a href="#训练误差和泛化误差" class="headerlink" title="训练误差和泛化误差"></a>训练误差和泛化误差</h3><p>训练误差：模型在训练数据集上计算得到的误差<br>泛化误差：模型应用在同样从原始样本的分布中抽取的无限多数据样本时，模型误差的期望</p>
<blockquote>
<p>我们永远不能准确地计算出泛化误差。这是因为无限多地数据样本是一个虚构的对象。在实际中，我们只能通过将模型应用于一个独立的测试集来估计泛化误差，该测试集由随机选取的、未曾在训练集中出现的数据样本构成</p>
</blockquote>
<h3 id="模型复杂度"><a href="#模型复杂度" class="headerlink" title="模型复杂度"></a>模型复杂度</h3><p>几个倾向于影响模型泛化的因素<br>1.可调整参数的数量。当可调整参数的数量（自由度）很大时，模型往往更容易过拟合<br>2.参数采用的值。当权重的取值范围较大时，模型可能更容易过拟合<br>3.训练样本的数量。即使模型很简单，也很容易过拟合只包含一两个样本的数据集。而过拟合一个有数百万个样本的数据集则需要一个极其灵活的模型</p>
<blockquote>
<p>正则化是处理过拟合的常用方法：在训练集的损失函数中加入惩罚项，以降低学习到的模型的复杂度</p>
</blockquote>
<h2 id="Unet网络"><a href="#Unet网络" class="headerlink" title="Unet网络"></a>Unet网络</h2><p><a href="https://www.jianshu.com/p/14641b79a672">Unet</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2024/03/16/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>查找时，过滤掉一定不存在的key，提高查找效率</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在数组或者列表中搜索相应值的时候，你必须遍历已有的集合。若集合中存在大量的数据，就会影响查找的效率</p>
<p>针对这个问题，可以考虑使用哈希表，利用哈希表来对”值”进行哈希处理来获得该值对应的索引值，然后将该”值”存放到列表中对应的索引位置。<br>这意味着判断列表中是否存在该值时，只需要对值进行哈希处理并在相应的索引位置进行搜索即可，这时的搜索速度是非常快的。</p>
<p><img src="/../images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1.png" alt="img"></p>
<p>Bloom Filter本质上是由长度为m的位向量（仅包含0或者1）组成，最初所有值均设置为0，如下图所示：<br><img src="/../images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2.png" alt="img"></p>
<p>为了将数据项添加到布隆过滤器中，使用k个不同的哈希函数对其进行哈希，并将结果位置上对应位置为1</p>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>输入”semlinker”，预设的3个哈希函数将输出2、4、6,我们把相应位置为1<br><img src="/../images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/3.png" alt="img"><br>再输入”kakuqo”，哈希函数输出3、4、7,把对应位置为1<br><img src="/../images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4.png" alt="img"><br>再输入”fullstack”,哈希函数输出2、3、7，这时发现相应的索引位都已经置为了1，这意味着我们可以说”fullstack”可能已经插入到集合中。这是一种误判情况<br><img src="/../images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/5.png" alt="img"></p>
<p>布隆过滤器有一个可预测的误判率(FPP):<br><img src="/../images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/6.png" alt="img"></p>
<ul>
<li>n是已经添加元素的数量</li>
<li>k是哈希的次数</li>
<li>m为布隆过滤器的长度(如比特数组的大小)</li>
</ul>
<p>实际情况中，布隆过滤器的长度m可以根据误判率(FFP)的和期望添加的元素个数n的通过如下公式计算:<br><img src="/../images/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7.png" alt="img"></p>
<blockquote>
<p>因此，我们得出一个结论，当我们搜索一个值的时候，若该值经过k个哈希函数运算后任何一个索引位为0，那么该值肯定不在集合中。但如果所有哈希索引值均为1，则只能说该搜索的值可能存在集合中</p>
</blockquote>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在实际工作中，布隆过滤器常见的应用场景如下：</p>
<ul>
<li>网页爬虫对 URL 去重，避免爬取相同的 URL 地址；</li>
<li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱；</li>
<li>Google Chrome 使用布隆过滤器识别恶意 URL；</li>
<li>Medium 使用布隆过滤器避免推荐给用户已经读过的文章；</li>
<li>Google BigTable，Apache HBbase 和 Apache Cassandra 使用布隆过滤器减少对不存在的行和列的查找</li>
</ul>
]]></content>
      <categories>
        <category>布隆过滤器</category>
      </categories>
      <tags>
        <tag>布隆过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2024/10/03/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><img src="/../images/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/image.png" alt="img"><br><img src="/../images/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/image%20copy.png" alt="img"></p>
<p><img src="/../images/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/image%20copy%202.png" alt="img"><br><img src="/../images/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/image%20copy%203.png" alt="img"><br><img src="/../images/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/image%20copy%204.png" alt="img"><br><img src="/../images/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/image%20copy%205.png" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单点更新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param i     原始数组索引 i</span></span><br><span class="line"><span class="comment"> * @param delta 变化值 = 更新以后的值 - 原始值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从下到上更新，注意，预处理数组，比原始数组的 len 大 1，故 预处理索引的最大值为 len</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= len) &#123;</span><br><span class="line">        tree[i] += delta;</span><br><span class="line">        i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/../images/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/image%20copy%206.png" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询前缀和</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param i 前缀的最大索引，即查询区间 [0, i] 的所有元素之和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从右到左查询</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += tree[i];</span><br><span class="line">        i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人实现:<br><a href="https://github.com/jingtao8a/leetcode/blob/master/src/main/java/org/jingtao8a/code_random_notes/TreeArray.java">https://github.com/jingtao8a/leetcode/blob/master/src/main/java/org/jingtao8a/code_random_notes&#x2F;TreeArray.java</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2024/10/03/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p>线段树是常用的维护区间信息的数据结构</p>
<h2 id="线段树支持操作"><a href="#线段树支持操作" class="headerlink" title="线段树支持操作"></a>线段树支持操作</h2><p>（1）单点修改<br><br>（2）区间修改<br><br>（3）区间查询（区间求和，求区间max，求区间min，区间gcd等等）<br></p>
<h2 id="线段树特点："><a href="#线段树特点：" class="headerlink" title="线段树特点："></a>线段树特点：</h2><p>（1）每个节点表示一个区间<br><br>（2）root node表示区间为[1, n]<br><br>（3）leaf Node表示区间为[x, x]<br><br>（4）线段树中如果一个节点区间为[l, r]（l !&#x3D; r）那么这个节点的左子树的根表示区间为[l, mid]，这个节点的右子树的根表示区间就是[mid + 1, r], 其中mid &#x3D; Floor((l + r) &#x2F;2)<br></p>
<h2 id="线段树特点：-1"><a href="#线段树特点：-1" class="headerlink" title="线段树特点："></a>线段树特点：</h2><p>（1）每个节点表示一个区间<br>（2）root node表示区间为[1, n]<br>（3）leaf Node表示区间为[x, x]<br>（4）线段树中如果一个节点区间为[l, r]（l !&#x3D; r）那么这个节点的左子树的根表示区间为[l, mid]，这个节点的右子树的根表示区间就是[mid + 1, r], 其中mid &#x3D; Floor((l + r) &#x2F;2)</p>
<h2 id="线段树的存储方式"><a href="#线段树的存储方式" class="headerlink" title="线段树的存储方式"></a>线段树的存储方式</h2><p><img src="/../images/%E7%BA%BF%E6%AE%B5%E6%A0%91/image.png" alt="img"></p>
<h2 id="建立线段树"><a href="#建立线段树" class="headerlink" title="建立线段树"></a>建立线段树</h2><p>时间复杂度为O（n）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment_Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    info_type info;</span><br><span class="line">    tag_type tag;</span><br><span class="line">    <span class="comment">//这里可以维护任何满足区间加法的信息</span></span><br><span class="line">&#125;tr[<span class="number">4</span> * N];   <span class="comment">//要开四倍空间</span></span><br><span class="line"><span class="comment">//实现时可以写 info + info,info + tag,tag + tag 来简化代码</span></span><br><span class="line">info_type <span class="keyword">operator</span> + (info_type x,info_type y) &#123;</span><br><span class="line">    <span class="comment">// 合并 info</span></span><br><span class="line">&#125;</span><br><span class="line">info_type opreator + (info_type x,tag_type y) &#123;</span><br><span class="line">    <span class="comment">// 合并 info 和 tag</span></span><br><span class="line">&#125;</span><br><span class="line">tag_type <span class="keyword">operator</span> + (tag_type x,tag_type y) &#123;</span><br><span class="line">    <span class="comment">// 合并 tag</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">opt</span> <span class="params">(info_type &amp;x,tag_type y)</span> </span>&#123;</span><br><span class="line">    x = x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span> <span class="params">(<span class="type">int</span> u)</span> </span>&#123; </span><br><span class="line"><span class="comment">//这里举个例子，比如区间和，区间和就是由一个点的左右子节点的和相加</span></span><br><span class="line">tr[u].info = tr[u &lt;&lt; <span class="number">1</span>].info + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].info;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span> <span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;  <span class="comment">//当前正在下标为u的点，这个点表示的区间是[l,r]</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[u] = &#123;l,r,<span class="built_in">info</span> (a[l])&#125;;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    tr[u] = &#123;l,r&#125;;  <span class="comment">//记得存储当前点表示的区间，否则你会调上一整天</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span> (u &lt;&lt; <span class="number">1</span>,l,mid),<span class="built_in">build</span> (u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,mid + <span class="number">1</span>,r); <span class="comment">//u &lt;&lt; 1就是u * 2，u &lt;&lt; 1 | 1就是u * 2 + 1</span></span><br><span class="line">    <span class="built_in">push_up</span> (u);  <span class="comment">//push_up函数的意思是把某一个节点的信息由它的子节点算出来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><p>时间复杂度均为O(logN)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span> <span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,tag_type d)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == tr[u].r) &#123;</span><br><span class="line">        tr[u].info += d; <span class="comment">//如果当前区间只有一个数，那么这个数一定是要修改的</span></span><br><span class="line">        <span class="comment">// 修改不局限于覆盖，也可能是别的</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span> (u &lt;&lt; <span class="number">1</span>,x,d);  <span class="comment">//如果在左边就递归修改左半边区间</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span> (u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,x,d);    <span class="comment">//如果在右边就递归修改右半边区间</span></span><br><span class="line">    <span class="built_in">push_up</span> (u)   <span class="comment">//记得更新信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h2><p>思路1：<br>时间复杂度均为O(N)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span> <span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,tag_type d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == tr[u].r) &#123;   <span class="comment">//叶子节点</span></span><br><span class="line">        tr[u].info += d;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;  <span class="comment">//注意是tr[u].l和tr[u].r</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span> (u &lt;&lt; <span class="number">1</span>,l,r,d);  <span class="comment">//左边有修改区间，就递归左半边</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= mid + <span class="number">1</span>) <span class="built_in">modify</span> (u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,l,r,d);  <span class="comment">//右边有修改区间，就递归右半边</span></span><br><span class="line">    <span class="built_in">push_up</span> (u);  <span class="comment">//要记得要把这个点的信息更新一下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span> <span class="params">(<span class="type">int</span> u)</span> </span>&#123; <span class="comment">//下传标记函数</span></span><br><span class="line">    <span class="keyword">if</span> (tr[u].tag) &#123;  <span class="comment">//有懒标记才下传</span></span><br><span class="line">        tr[u &lt;&lt; <span class="number">1</span>].info += tr[u].tag,tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].info += tr[u].tag</span><br><span class="line">        tr[u].tag = <span class="built_in">info</span> ();  <span class="comment">//懒标记记得清零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span> <span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span> </span>&#123; <span class="comment">//当前遍历到的点下标是u，要修改区间[l,r]</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) &#123;</span><br><span class="line">        <span class="built_in">opt</span> (u,d);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span> (u);  <span class="comment">//一定要分裂，只要记牢在递归左右区间之前，就要分裂</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;  <span class="comment">//注意时tr[u].l和tr[u].r</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span> (u &lt;&lt; <span class="number">1</span>,l,r,d);  <span class="comment">//左边有修改区间，就递归左半边</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= mid + <span class="number">1</span>) <span class="built_in">modify</span> (u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,l,r,d);  <span class="comment">//右边有修改区间，就递归右半边</span></span><br><span class="line">    <span class="built_in">push_up</span> (u);  <span class="comment">//要记得要把这个点的信息更新一下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">query_sum</span> <span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="built_in">push_down</span> (u);  <span class="comment">//在递归之前一定要分裂</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum += <span class="built_in">query_sum</span> (u &lt;&lt; <span class="number">1</span>,l,r);  <span class="comment">//左半边有被查询到的数据，就递归左半边</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= mid + <span class="number">1</span>) sum += <span class="built_in">query_sum</span> (u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,l,r);  <span class="comment">//右半边有被查询到的数据，就递归右半边</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考:<a href="https://www.acwing.com/file_system/file/content/whole/index/content/6505356/">线段树 acwing</a></p>
<p>个人实现:<br><a href="https://github.com/jingtao8a/leetcode/blob/master/src/main/java/org/jingtao8a/code_random_notes/SegmentTree.java">https://github.com/jingtao8a/leetcode/blob/master/src/main/java/org/jingtao8a/code_random_notes&#x2F;SegmentTree.java</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>静态链接</title>
    <url>/2023/05/28/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<blockquote>
<p>连接器采用“两部链接”的方法，将链接过程分为两部：</p>
</blockquote>
<p>1.空间和地址分配：扫描所有的输入目标文件，获得各个节的长度、属性、位置并将它们合并，计算合并后各个段的长度与位置，建立映射关系。收集所有输入目标文件中符号表中所有的符号定义和符号引用，统一放到全局符号表中<br>2.符号解析与重定位：使用第一步中收集到的所有信息，读取输入文件中节的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。</p>
<p><strong>重定位过程是链接过程的核心</strong></p>
<h2 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h2><h4 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h4><blockquote>
<p>重定位的过程伴随着符号解析过程，每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。重定位过程中，每个重定位的入口都是一个外部符号的引用，当链接器需要对某个符号的引用进行重定位时，他就要确定这个符号的目标地址。这时候链接器会去查找有所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位，如果没有找到，就会报符号未定义的错误。</p>
</blockquote>
<h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><blockquote>
<p>对于32位 x86平台下的ELF文件的重定位入口所修正的指令寻址方式只有两种：</p>
</blockquote>
<p>1.绝对近址32位寻址<br>2.相对近址32为寻址</p>
<blockquote>
<p>这两种重定位指令修正方式每个被修正的位置的长度都为32位，即4字节。而且都是近址寻址，不用考虑Intel的段间远址寻址。</p>
</blockquote>
<p>X86基本重定位类型：<br><img src="/images/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/1.jpg" alt="QQ截图20221203153333.png"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>链接、装载与库</tag>
      </tags>
  </entry>
</search>
