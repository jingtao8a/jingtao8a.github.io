<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jingtao8a.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="this is life, full of ups and down">
<meta property="og:type" content="website">
<meta property="og:title" content="jingtao8a&#39;s blog">
<meta property="og:url" content="http://jingtao8a.github.io/page/2/index.html">
<meta property="og:site_name" content="jingtao8a&#39;s blog">
<meta property="og:description" content="this is life, full of ups and down">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="jingtao8a">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://jingtao8a.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>jingtao8a's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">jingtao8a's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2024/02/28/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/28/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5/" class="post-title-link" itemprop="url">ssh免密登录失败</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-02-28 03:22:49 / Modified: 03:30:18" itemprop="dateCreated datePublished" datetime="2024-02-28T03:22:49-08:00">2024-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SSH免密码失败原因定位分析"><a href="#SSH免密码失败原因定位分析" class="headerlink" title="SSH免密码失败原因定位分析"></a>SSH免密码失败原因定位分析</h2><ol>
<li>服务器B上.ssh目录的权限必须是700</li>
<li>服务器B上.authorized_keys文件权限必须是600或者644</li>
<li>服务器B上用户家目录文件权限必须是700，比如用户名是aischang，则&#x2F;home&#x2F;aischang这个目录权限必须是700</li>
</ol>
<p>如果不是700，在服务器A上查看&#x2F;var&#x2F;log&#x2F;secure文件会报错</p>
<h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>sshd为了安全，对属主的目录和文件权限有所要求。如果权限不对，则ssh的免密码登陆不生效。</p>
<blockquote>
<ol>
<li>服务器B上SELinux关闭为disabled，可以使用命令修改setenforce 0 ，查看状态的命令为getenforce或者 查看&#x2F;etc&#x2F;selinux&#x2F;config 文件中是否是disabled</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>有可能是StrictModes问题<br><br> 编辑 vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br><br> 找到#StrictModes yes改成StrictModes no</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>有可能是PubkeyAuthentication问题<br><br> 编辑 vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br><br> 找到PubkeyAuthentication改成yes</li>
</ol>
</blockquote>
<p>如果还不行，可以在服务器A上用ssh -vvv 机器B的ip 查看详情，根据输出内容具体问题具体分析了</p>
<p>参考链接: <a target="_blank" rel="noopener" href="https://juejin.cn/s/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0">https://juejin.cn/s/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2024/02/27/cmu15445-project3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/27/cmu15445-project3/" class="post-title-link" itemprop="url">cmu15445-project3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-27 19:38:43" itemprop="dateCreated datePublished" datetime="2024-02-27T19:38:43-08:00">2024-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-29 04:03:10" itemprop="dateModified" datetime="2024-02-29T04:03:10-08:00">2024-02-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15445-2023/" itemprop="url" rel="index"><span itemprop="name">cmu15445-2023</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Query-Processing-Model"><a href="#Query-Processing-Model" class="headerlink" title="Query Processing Model"></a>Query Processing Model</h2><p>OLAP与OLTP数据库</p>
<ul>
<li>OLAP数据库架构将数据读取优先于数据写入操作。可以快速地对大量数据执行复杂的查询</li>
<li>OLTP数据库架构将数据写入优先于数据读取操作。它针对写入密集型工作负载进行了优化</li>
</ul>
<p>example:<br><br>以一家大型零售公司为例。该公司有一个庞大的数据库，用于跟踪销售、库存、客户数据等</p>
<ul>
<li>使用OLTP数据库实时处理交易、更新库存水平和管理客户账户</li>
<li>使用OLAP数据库来分析有关销售趋势、库存水平、客户人口统计等</li>
</ul>
<hr>
<p>DBMS的Processing Model定义了系统如何执行一个query plan,目前主要有三种模型</p>
<ul>
<li>Iterator Model</li>
<li>Materialization Model</li>
<li>Vectorized&#x2F;Batch Model</li>
</ul>
<h3 id="Iterator-Model"><a href="#Iterator-Model" class="headerlink" title="Iterator Model"></a>Iterator Model</h3><p>query plan 中的每步 operator 都实现一个 next 函数，每次调用时，operator 返回一个 tuple 或者 null，后者表示数据已经遍历完毕。operator 本身实现一个循环，每次调用其 child operators 的 next 函数，从它们那边获取下一条数据供自己操作，这样整个 query plan 就被从上至下地串联起来，它也称为 Volcano&#x2F;Pipeline Model：<br><img src="/../images/cmu15445-project3/1.png" alt="img"><br>Iterator 几乎被用在每个 DBMS 中，包括 sqlite、MySQL、PostgreSQL 等等，其它需要注意的是:</p>
<ul>
<li>有些 operators 会等待 children 返回所有 tuples 后才执行，如 Joins, Subqueries 和 Order By</li>
<li>Output Control 在 Iterator Model 中比较容易，如 Limit，只按需调用 next 即可</li>
</ul>
<h3 id="Materialization-Model"><a href="#Materialization-Model" class="headerlink" title="Materialization Model"></a>Materialization Model</h3><p>每个 operator 处理完所有输入后，将所有结果一次性输出，DBMS 会将一些参数传递到 operator 中防止处理过多的数据，这是一种从下至上的思路，示意如下：<br><img src="/../images/cmu15445-project3/2.png" alt="img"><br>materialization model：</p>
<ul>
<li>更适合 OLTP 场景，因为后者通常指需要处理少量的 tuples，这样能减少不必要的执行、调度成本</li>
<li>不太适合会产生大量中间结果的 OLAP 查询</li>
</ul>
<h3 id="Vectorization-Model"><a href="#Vectorization-Model" class="headerlink" title="Vectorization Model"></a>Vectorization Model</h3><p>Vectorization Model 是 Iterator 与 Materialization Model 折衷的一种模型：</p>
<ul>
<li>每个 operator 实现一个 next 函数，但每次 next 调用返回一批 tuples，而不是单个 tuple</li>
<li>operator 内部的循环每次也是一批一批 tuples 地处理</li>
<li>batch 的大小可以根据需要改变（hardware、query properties)<br><br><img src="/../images/cmu15445-project3/3.png" alt="img"></li>
</ul>
<p>vectorization model 是 OLAP 查询的理想模型:</p>
<ul>
<li>极大地减少每个 operator 的调用次数</li>
<li>允许 operators 使用 vectorized instructions (SIMD) 来批量处理 tuples</li>
</ul>
<h2 id="BACKGROUND：QUERY-PROCESSING"><a href="#BACKGROUND：QUERY-PROCESSING" class="headerlink" title="BACKGROUND：QUERY PROCESSING"></a>BACKGROUND：QUERY PROCESSING</h2><p>BusTub架构如下<br><img src="/../images/cmu15445-project3/4.png" alt="img"></p>
<h3 id="note"><a href="#note" class="headerlink" title="note:"></a>note:</h3><ul>
<li>BusTub只支持SQL的一个小子集，可以通过tests&#x2F;sql中的SQLLogicTest文件来查看它所支持的SQL语句</li>
<li>如果你使用Clion来运行Bustub shell，添加–disable-tty参数</li>
<li>SQL语句使用;结尾</li>
<li>BusTub只支持INT和VARCHAR(n)类型，字符串使用单引号</li>
<li>Bustub使用Iterator Porcessing Model</li>
</ul>
<h3 id="Inspecting-SQL-query-plans"><a href="#Inspecting-SQL-query-plans" class="headerlink" title="Inspecting SQL query plans"></a>Inspecting SQL query plans</h3><p>BusTub支持EXPLAIN来打印SQL查询计划<br><img src="/../images/cmu15445-project3/5.png" alt="img"><br>EXPLAIN会展示query processing这一层的转换过程 Parser -&gt; Binder -&gt; Planner -&gt; Optimizer<br><br>Parser解析SQL语句生成Binder AST语法树，接着生成query plan，然后由Optimizer优化query plan生成executor树</p>
<h2 id="Task-1-Access-Method-Executors"><a href="#Task-1-Access-Method-Executors" class="headerlink" title="Task#1 Access Method Executors"></a>Task#1 Access Method Executors</h2><p>我们并不需要关心query plan是如何创建的；但有必要理解query plan的组成结构:这是棵树，每个plan节点都对应具体的算子，Bustub采用iterator procesing model，也就是Top-to-Bottom的火山模型，因此query plan的执行就是从根节点开始，将plan节点转换为对应的算子</p>
<p>Plan节点的类型如下<br><img src="/../images/cmu15445-project3/6.png" alt="img"><br>还是有必要阅读一些相关代码<br></p>
<p>表Table的元信息</p>
<blockquote>
<p>其中TableHeap代表磁盘上的一张表，是一个doubly-linked of pages</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TableInfo</span> &#123;</span><br><span class="line">  <span class="comment">/** The table schema */</span></span><br><span class="line">  Schema schema_;</span><br><span class="line">  <span class="comment">/** The table name */</span></span><br><span class="line">  <span class="type">const</span> std::string name_;</span><br><span class="line">  <span class="comment">/** An owning pointer to the table heap */</span></span><br><span class="line">  std::unique_ptr&lt;TableHeap&gt; table_;</span><br><span class="line">  <span class="comment">/** The table OID */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">table_oid_t</span> oid_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TableHeap</span> &#123;</span><br><span class="line">  <span class="type">page_id_t</span> first_page_id_&#123;INVALID_PAGE_ID&#125;;</span><br><span class="line">  <span class="type">page_id_t</span> last_page_id_&#123;INVALID_PAGE_ID&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>索引Index的元信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexInfo</span> &#123;</span><br><span class="line">  <span class="comment">/** The schema for the index key */</span></span><br><span class="line">  Schema key_schema_;</span><br><span class="line">  <span class="comment">/** The name of the index */</span></span><br><span class="line">  std::string name_;</span><br><span class="line">  <span class="comment">/** An owning pointer to the index */</span></span><br><span class="line">  std::unique_ptr&lt;Index&gt; index_;</span><br><span class="line">  <span class="comment">/** The unique OID for the index */</span></span><br><span class="line">  <span class="type">index_oid_t</span> index_oid_;</span><br><span class="line">  <span class="comment">/** The name of the table on which the index is created */</span></span><br><span class="line">  std::string table_name_;</span><br><span class="line">  <span class="comment">/** The size of the index key, in bytes */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> key_size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>catalog<br></p>
<blockquote>
<p>记录所有TableInfo和IndexInfo</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Catalog</span> &#123;</span><br><span class="line">  std::unordered_map&lt;<span class="type">table_oid_t</span>, std::unique_ptr&lt;TableInfo&gt;&gt; tables_;</span><br><span class="line">  <span class="comment">/** Map table name -&gt; table identifiers. */</span></span><br><span class="line">  std::unordered_map&lt;std::string, <span class="type">table_oid_t</span>&gt; table_names_;</span><br><span class="line">  </span><br><span class="line">  std::unordered_map&lt;<span class="type">index_oid_t</span>, std::unique_ptr&lt;IndexInfo&gt;&gt; indexes_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Map table name -&gt; index names -&gt; index identifiers. */</span></span><br><span class="line">  std::unordered_map&lt;std::string, std::unordered_map&lt;std::string, <span class="type">index_oid_t</span>&gt;&gt; index_names_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="SeqScanExecutor实现"><a href="#SeqScanExecutor实现" class="headerlink" title="SeqScanExecutor实现"></a>SeqScanExecutor实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqScanExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> SeqScanPlanNode *plan_;<span class="comment">//对应的SeqScanPlanNode</span></span><br><span class="line">  TableInfo *table_info_;<span class="comment">//扫描的table</span></span><br><span class="line">  std::unique_ptr&lt;TableIterator&gt; iterator_;<span class="comment">//TableIterator</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SeqScanExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = catalog-&gt;<span class="built_in">GetTable</span>(plan_-&gt;table_oid_);<span class="comment">//获取TableInfo</span></span><br><span class="line">  iterator_ = std::<span class="built_in">make_unique</span>&lt;TableIterator&gt;(table_info_-&gt;table_-&gt;<span class="built_in">MakeIterator</span>());<span class="comment">//获取对应Table的TableIterator</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SeqScanExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  std::pair&lt;TupleMeta, Tuple&gt; pair;</span><br><span class="line">  <span class="keyword">while</span> (!iterator_-&gt;<span class="built_in">IsEnd</span>()) &#123;<span class="comment">//如果未遍历完Table</span></span><br><span class="line">    pair = iterator_-&gt;<span class="built_in">GetTuple</span>();<span class="comment">//获取一个TupleMeta-Tuple pair</span></span><br><span class="line">    <span class="keyword">if</span> (pair.first.is_deleted_) &#123;<span class="comment">//如果该TupleMeta标记Tuple为已删除</span></span><br><span class="line">      ++(*iterator_);<span class="comment">//跳过</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (plan_-&gt;filter_predicate_) &#123;<span class="comment">//如果该算子对应的SeqScanPlanNode含有filter_predicate表达式</span></span><br><span class="line">      <span class="keyword">auto</span> res = plan_-&gt;filter_predicate_-&gt;<span class="built_in">Evaluate</span>(&amp;pair.second, table_info_-&gt;schema_);</span><br><span class="line">      <span class="keyword">if</span> (!(!res.<span class="built_in">IsNull</span>() &amp;&amp; res.<span class="built_in">GetAs</span>&lt;<span class="type">bool</span>&gt;())) &#123;<span class="comment">//如果该Tuple不满足该filter_predicate表达式</span></span><br><span class="line">        ++(*iterator_);<span class="comment">//跳过</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++(*iterator_);<span class="comment">//迭代器前进一步</span></span><br><span class="line">    *tuple = std::<span class="built_in">move</span>(pair.second);</span><br><span class="line">    *rid = tuple-&gt;<span class="built_in">GetRid</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InsertExecutor实现"><a href="#InsertExecutor实现" class="headerlink" title="InsertExecutor实现"></a>InsertExecutor实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InsertExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> InsertPlanNode *plan_;<span class="comment">//对应的InsertPlanNode</span></span><br><span class="line">  <span class="type">bool</span> successful_;<span class="comment">//是否插入成功</span></span><br><span class="line">  TableInfo *table_info_;<span class="comment">//插入的Table</span></span><br><span class="line">  std::vector&lt;IndexInfo *&gt; index_infos_;<span class="comment">//该Table对应的Index，如果Table变更，索引也需更改</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;<span class="comment">//一个孩子executor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  <span class="keyword">auto</span> cata_log = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = cata_log-&gt;<span class="built_in">GetTable</span>(plan_-&gt;table_oid_);</span><br><span class="line">  index_infos_ = cata_log-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">  successful_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">InsertExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  TupleMeta meta;</span><br><span class="line">  <span class="keyword">if</span> (successful_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  meta.insert_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  meta.delete_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  meta.is_deleted_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;<span class="comment">//从孩子executor获取tuple</span></span><br><span class="line">    <span class="keyword">auto</span> tuple_rid = table_info_-&gt;table_-&gt;<span class="built_in">InsertTuple</span>(meta, *tuple, exec_ctx_-&gt;<span class="built_in">GetLockManager</span>(), exec_ctx_-&gt;<span class="built_in">GetTransaction</span>(), table_info_-&gt;oid_);<span class="comment">//插入Table</span></span><br><span class="line">    <span class="keyword">if</span> (tuple_rid == std::<span class="literal">nullopt</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新该Table的所有索引结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;</span><br><span class="line">      <span class="keyword">auto</span> key = tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(key, *tuple_rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ++count;<span class="comment">//插入记录count++</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">emplace_back</span>(TypeId::INTEGER, count);</span><br><span class="line">  *tuple = <span class="built_in">Tuple</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());<span class="comment">//入参tuple返回插入的记录的数量</span></span><br><span class="line">  successful_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UpdateExecutor实现"><a href="#UpdateExecutor实现" class="headerlink" title="UpdateExecutor实现"></a>UpdateExecutor实现</h3><blockquote>
<p>这里实现的思路就是将旧的Tuple删除，插入新的Tuple</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpdateExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> UpdatePlanNode *plan_;<span class="comment">//对应的UpdatePlanNode</span></span><br><span class="line">  <span class="comment">/** Metadata identifying the table that should be updated */</span></span><br><span class="line">  <span class="type">const</span> TableInfo *table_info_;<span class="comment">//要update的table</span></span><br><span class="line">  <span class="comment">/** The child executor to obtain value from */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;<span class="comment">//孩子executor</span></span><br><span class="line"></span><br><span class="line">  std::vector&lt;IndexInfo *&gt; index_infos_;<span class="comment">//该Table上的所有index</span></span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> successful_;<span class="comment">//更新是否成功</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  successful_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> cata_log = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = cata_log-&gt;<span class="built_in">GetTable</span>(plan_-&gt;<span class="built_in">TableOid</span>());</span><br><span class="line">  index_infos_ = cata_log-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">UpdateExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  TupleMeta tuple_meta;</span><br><span class="line">  <span class="keyword">if</span> (successful_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tuple_meta.delete_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  tuple_meta.insert_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  <span class="keyword">auto</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;<span class="comment">//从孩子executor拿到需要更新的tuple</span></span><br><span class="line">    <span class="comment">// 删除tuple</span></span><br><span class="line">    tuple_meta.is_deleted_ = <span class="literal">true</span>;</span><br><span class="line">    table_info_-&gt;table_-&gt;<span class="built_in">UpdateTupleMeta</span>(tuple_meta, *rid);<span class="comment">//将Table中相同rid的Tuple标记为删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;<span class="comment">//将Table对应的Index中与该Tuple对应的key删除</span></span><br><span class="line">      <span class="keyword">auto</span> key = tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">DeleteEntry</span>(key, *rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的tuple</span></span><br><span class="line">    std::vector&lt;Value&gt; values;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;expresssion : plan_-&gt;target_expressions_) &#123;</span><br><span class="line">      values.<span class="built_in">emplace_back</span>(expresssion-&gt;<span class="built_in">Evaluate</span>(tuple, child_executor_-&gt;<span class="built_in">GetOutputSchema</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> new_tuple = <span class="built_in">Tuple</span>(values, &amp;child_executor_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    <span class="comment">// 插入新的tuple</span></span><br><span class="line">    tuple_meta.is_deleted_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> tuple_rid = table_info_-&gt;table_-&gt;<span class="built_in">InsertTuple</span>(tuple_meta, new_tuple, exec_ctx_-&gt;<span class="built_in">GetLockManager</span>(), exec_ctx_-&gt;<span class="built_in">GetTransaction</span>(), table_info_-&gt;oid_);</span><br><span class="line">    <span class="keyword">if</span> (tuple_rid == std::<span class="literal">nullopt</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;</span><br><span class="line">      <span class="keyword">auto</span> key = new_tuple.<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(key, *tuple_rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());<span class="comment">//Index插入key</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">emplace_back</span>(TypeId::INTEGER, count);</span><br><span class="line">  *tuple = &#123;values, &amp;<span class="built_in">GetOutputSchema</span>()&#125;;<span class="comment">//入参tuple返回update的参数个数</span></span><br><span class="line">  successful_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DeleteExecutor实现"><a href="#DeleteExecutor实现" class="headerlink" title="DeleteExecutor实现"></a>DeleteExecutor实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeleteExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> DeletePlanNode *plan_;<span class="comment">//对应的DeletePlanNode</span></span><br><span class="line">  <span class="comment">/** The child executor from which RIDs for deleted tuples are pulled */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;<span class="comment">//孩子DeleteExecutor</span></span><br><span class="line">  <span class="type">bool</span> successful_;<span class="comment">//判断删除是否成功</span></span><br><span class="line">  TableInfo *table_info_;<span class="comment">//删除的Table</span></span><br><span class="line">  std::vector&lt;IndexInfo *&gt; index_infos_;<span class="comment">//Table对应的所有Index</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  successful_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = catalog-&gt;<span class="built_in">GetTable</span>(plan_-&gt;<span class="built_in">TableOid</span>());</span><br><span class="line">  index_infos_ = catalog-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">DeleteExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  TupleMeta tuple_meta;</span><br><span class="line">  <span class="keyword">if</span> (successful_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tuple_meta.delete_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  tuple_meta.insert_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  tuple_meta.is_deleted_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">auto</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;<span class="comment">//从孩子节点获取tuple</span></span><br><span class="line">    table_info_-&gt;table_-&gt;<span class="built_in">UpdateTupleMeta</span>(tuple_meta, *rid);<span class="comment">//删除Table中对应的Tuple，标记为删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;<span class="comment">//删除该Table上所有Index中与该Tuple对应的key</span></span><br><span class="line">      <span class="keyword">auto</span> key = tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">DeleteEntry</span>(key, *rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    count++;<span class="comment">//删除计数count++</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">emplace_back</span>(TypeId::INTEGER, count);</span><br><span class="line">  *tuple = <span class="built_in">Tuple</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());<span class="comment">//入参tuple返回删除的tuple数量</span></span><br><span class="line">  successful_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IndexScanExecutor实现"><a href="#IndexScanExecutor实现" class="headerlink" title="IndexScanExecutor实现"></a>IndexScanExecutor实现</h3><p>SELECT FROM <table> ORDER BY <index column>中的ORDER BY会被转为IndexScan<br></index></table></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexScanExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> IndexScanPlanNode *plan_;<span class="comment">//对应的IndexScanPlanNode</span></span><br><span class="line">  IndexInfo *index_info_;<span class="comment">//IndexInfo</span></span><br><span class="line">  TableInfo *table_info_;<span class="comment">//TableInfo</span></span><br><span class="line">  BPlusTreeIndexForTwoIntegerColumn *index_;<span class="comment">//扫描的Index</span></span><br><span class="line">  std::unique_ptr&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt; index_iterator_;<span class="comment">//扫描的Index的IndexIterator</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexScanExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  index_info_ = catalog-&gt;<span class="built_in">GetIndex</span>(plan_-&gt;index_oid_);<span class="comment">//获取对应的Index_Info</span></span><br><span class="line">  table_info_ = catalog-&gt;<span class="built_in">GetTable</span>(index_info_-&gt;table_name_);<span class="comment">//获取对应的Table_Info</span></span><br><span class="line">  index_ = <span class="built_in">dynamic_cast</span>&lt;BPlusTreeIndexForTwoIntegerColumn *&gt;(index_info_-&gt;index_.<span class="built_in">get</span>());</span><br><span class="line">  index_iterator_ = std::<span class="built_in">make_unique</span>&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt;(index_-&gt;<span class="built_in">GetBeginIterator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">IndexScanExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!index_iterator_-&gt;<span class="built_in">IsEnd</span>()) &#123;<span class="comment">//遍历Index</span></span><br><span class="line">    <span class="keyword">auto</span> map = *(*index_iterator_);</span><br><span class="line">    *rid = map.second;<span class="comment">//拿到rid</span></span><br><span class="line">    <span class="keyword">if</span> (!table_info_-&gt;table_-&gt;<span class="built_in">GetTupleMeta</span>(*rid).is_deleted_) &#123;  <span class="comment">// 未被删除</span></span><br><span class="line">      index_iterator_-&gt;<span class="keyword">operator</span>++();</span><br><span class="line">      *tuple = table_info_-&gt;table_-&gt;<span class="built_in">GetTuple</span>(*rid).second;<span class="comment">//入参tuple返回rid指向的tuple</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index_iterator_-&gt;<span class="keyword">operator</span>++();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过SQLLogicTests#1 to #6<br><img src="/../images/cmu15445-project3/10.png" alt="img"><br><img src="/../images/cmu15445-project3/11.png" alt="img"><br><img src="/../images/cmu15445-project3/12.png" alt="img"><br><img src="/../images/cmu15445-project3/13.png" alt="img"><br><img src="/../images/cmu15445-project3/14.png" alt="img"><br><img src="/../images/cmu15445-project3/15.png" alt="img"></p>
<h2 id="Task-2-Aggregation-Join-Executors"><a href="#Task-2-Aggregation-Join-Executors" class="headerlink" title="Task#2 Aggregation &amp; Join Executors"></a>Task#2 Aggregation &amp; Join Executors</h2><h3 id="AggregationExecutor实现"><a href="#AggregationExecutor实现" class="headerlink" title="AggregationExecutor实现"></a>AggregationExecutor实现</h3><blockquote>
<p>AggregationExecutor用来支持以下的sql查询，第四条sql语句的DISTINCT相当于GROUP BY<br><br>AggregationExecutor不需要处理HAVING语句，planner会让AggregationPlanNode跟着一个FilterPlanNode<br><img src="/../images/cmu15445-project3/7.png" alt="img"></p>
</blockquote>
<p>补充完成SimpleAggregationHashTable，其中哈希表的键AggregateKey就是GROUP BY的columns<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleAggregationHashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/** The hash table is just a map from aggregate keys to aggregate values */</span></span><br><span class="line">  std::unordered_map&lt;AggregateKey, AggregateValue&gt; ht_&#123;&#125;;</span><br><span class="line">  <span class="comment">/** The aggregate expressions that we have */</span></span><br><span class="line">  <span class="type">const</span> std::vector&lt;AbstractExpressionRef&gt; &amp;agg_exprs_;</span><br><span class="line">  <span class="comment">/** The types of aggregations that we have */</span></span><br><span class="line">  <span class="type">const</span> std::vector&lt;AggregationType&gt; &amp;agg_types_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">GenerateInitialAggregateValue</span><span class="params">()</span> -&gt; AggregateValue </span>&#123;</span><br><span class="line">    std::vector&lt;Value&gt; values&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;agg_type : agg_types_) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (agg_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::CountStarAggregate:</span><br><span class="line">          <span class="comment">// Count start starts at zero.</span></span><br><span class="line">          values.<span class="built_in">emplace_back</span>(ValueFactory::<span class="built_in">GetIntegerValue</span>(<span class="number">0</span>));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::CountAggregate:</span><br><span class="line">        <span class="keyword">case</span> AggregationType::SumAggregate:</span><br><span class="line">        <span class="keyword">case</span> AggregationType::MinAggregate:</span><br><span class="line">        <span class="keyword">case</span> AggregationType::MaxAggregate:</span><br><span class="line">          <span class="comment">// Others starts at null.</span></span><br><span class="line">          values.<span class="built_in">emplace_back</span>(ValueFactory::<span class="built_in">GetNullValueByType</span>(TypeId::INTEGER));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;values&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">CombineAggregateValues</span><span class="params">(AggregateValue *result, <span class="type">const</span> AggregateValue &amp;input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; agg_exprs_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (agg_types_[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::CountStarAggregate:<span class="comment">//count(*)统计null数量</span></span><br><span class="line">          result-&gt;aggregates_[i] = &#123;INTEGER, result-&gt;aggregates_[i].<span class="built_in">GetAs</span>&lt;<span class="type">int32_t</span>&gt;() + <span class="number">1</span>&#125;;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::CountAggregate:<span class="comment">//count()不统计null数量</span></span><br><span class="line">          <span class="keyword">if</span> (input.aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result-&gt;aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = &#123;INTEGER, <span class="number">1</span>&#125;;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = &#123;INTEGER, result-&gt;aggregates_[i].<span class="built_in">GetAs</span>&lt;<span class="type">int32_t</span>&gt;() + <span class="number">1</span>&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::SumAggregate:</span><br><span class="line">          <span class="keyword">if</span> (input.aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result-&gt;aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = input.aggregates_[i];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = result-&gt;aggregates_[i].<span class="built_in">Add</span>((input.aggregates_[i]));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::MinAggregate:</span><br><span class="line">          <span class="keyword">if</span> (input.aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result-&gt;aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = input.aggregates_[i];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = result-&gt;aggregates_[i].<span class="built_in">Min</span>(input.aggregates_[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::MaxAggregate:</span><br><span class="line">          <span class="keyword">if</span> (input.aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result-&gt;aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = input.aggregates_[i];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = result-&gt;aggregates_[i].<span class="built_in">Max</span>(input.aggregates_[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">InsertCombine</span><span class="params">(<span class="type">const</span> AggregateKey &amp;agg_key, <span class="type">const</span> AggregateValue &amp;agg_val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ht_.<span class="built_in">count</span>(agg_key) == <span class="number">0</span>) &#123;</span><br><span class="line">      ht_.<span class="built_in">insert</span>(&#123;agg_key, <span class="built_in">GenerateInitialAggregateValue</span>()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CombineAggregateValues</span>(&amp;ht_[agg_key], agg_val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> AggregateKey &amp;agg_key, <span class="type">const</span> AggregateValue &amp;agg_val)</span> </span>&#123; ht_.<span class="built_in">insert</span>(&#123;agg_key, agg_val&#125;); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AggregationExecutor</span> &#123;</span><br><span class="line">  <span class="comment">// 添加数据成员</span></span><br><span class="line">  <span class="type">const</span> AggregationPlanNode *plan_;</span><br><span class="line">  <span class="comment">/** The child executor that produces tuples over which the aggregation is computed */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_;</span><br><span class="line">  <span class="comment">/** Simple aggregation hash table */</span></span><br><span class="line">  SimpleAggregationHashTable aht_;</span><br><span class="line">  <span class="comment">/** Simple aggregation hash table iterator */</span></span><br><span class="line">  std::unique_ptr&lt;SimpleAggregationHashTable::Iterator&gt; aht_iterator_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AggregationExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple tuple;</span><br><span class="line">  RID rid;</span><br><span class="line">  <span class="keyword">while</span> (child_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;<span class="comment">//遍历孩子executor中所有的tuple</span></span><br><span class="line">    <span class="comment">//构建AggregateKey 和 AggregateValue 插入哈希表</span></span><br><span class="line">    AggregateKey key = <span class="built_in">MakeAggregateKey</span>(&amp;tuple);</span><br><span class="line">    AggregateValue value = <span class="built_in">MakeAggregateValue</span>(&amp;tuple);</span><br><span class="line">    aht_.<span class="built_in">InsertCombine</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (aht_.<span class="built_in">Begin</span>() == aht_.<span class="built_in">End</span>() &amp;&amp; plan_-&gt;<span class="built_in">GetGroupBys</span>().<span class="built_in">empty</span>()) &#123;  <span class="comment">// hash表为空,</span></span><br><span class="line">    AggregateKey key;</span><br><span class="line">    aht_.<span class="built_in">Insert</span>(key, aht_.<span class="built_in">GenerateInitialAggregateValue</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  aht_iterator_ = std::<span class="built_in">make_unique</span>&lt;SimpleAggregationHashTable::Iterator&gt;(aht_.<span class="built_in">Begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">AggregationExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((*aht_iterator_) == aht_.<span class="built_in">End</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> key = aht_iterator_-&gt;<span class="built_in">Key</span>();</span><br><span class="line">  <span class="keyword">auto</span> value = aht_iterator_-&gt;<span class="built_in">Val</span>();</span><br><span class="line">  ++(*aht_iterator_);<span class="comment">//迭代器++</span></span><br><span class="line">  key.group_bys_.<span class="built_in">insert</span>(key.group_bys_.<span class="built_in">end</span>(), value.aggregates_.<span class="built_in">begin</span>(), value.aggregates_.<span class="built_in">end</span>());</span><br><span class="line">  *tuple = &#123;key.group_bys_, &amp;<span class="built_in">GetOutputSchema</span>()&#125;;<span class="comment">//key和value合并后由入参tuple返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="NestedLoopJoinExecutor实现"><a href="#NestedLoopJoinExecutor实现" class="headerlink" title="NestedLoopJoinExecutor实现"></a>NestedLoopJoinExecutor实现</h3><p>NestedLoopJoinExecutor将支持inner join和left join，使用simple nested loop join算法<br><img src="/../images/cmu15445-project3/8.png" alt="img"></p>
<h4 id="NestedLoopJoin是流水线破坏者吗？"><a href="#NestedLoopJoin是流水线破坏者吗？" class="headerlink" title="NestedLoopJoin是流水线破坏者吗？"></a>NestedLoopJoin是流水线破坏者吗？</h4><p>BusTub采用火山模型(iterator processing<br> model)执行算子。但是某些算子直到子算子提交所有元组的计算结果，才会解除阻塞。如Join、SubQueries、Ordering等，此类操作就被称为Pipeline Breaker。在Task2中，Aggregation、HashJoin都备注了是Pipeline Breaker，但NestedLoopJoin并没有这么说明，如果把它当做Pipeline Breaker，则无法通过测试，Spring2023要求NestedLoopJoin左子节点每次调用一次Next()方法,右子节点都需要Init()一次，因此并非Pipeline Breaker。这也意味着NestedLoopJoin的性能非常糟糕。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NestedLoopJoinExecutor</span> &#123; </span><br><span class="line">  <span class="type">const</span> NestedLoopJoinPlanNode *plan_;</span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; left_executor_;<span class="comment">//左孩子</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; right_executor_;<span class="comment">//右孩子</span></span><br><span class="line">  std::vector&lt;Tuple&gt; right_tuples_;</span><br><span class="line">  <span class="type">int</span> index_;</span><br><span class="line">  Tuple left_tuple_;</span><br><span class="line">  <span class="type">bool</span> is_match_;<span class="comment">//表示当前left_tuple_是否有匹配项</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NestedLoopJoinExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  left_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  right_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple right_tuple;</span><br><span class="line">  RID right_rid;</span><br><span class="line">  <span class="comment">//将右孩子的所有Tuple遍历出来放在right_tuples中</span></span><br><span class="line">  <span class="keyword">while</span> (right_executor_-&gt;<span class="built_in">Next</span>(&amp;right_tuple, &amp;right_rid)) &#123;</span><br><span class="line">    right_tuples_.<span class="built_in">emplace_back</span>(right_tuple);</span><br><span class="line">  &#125;</span><br><span class="line">  index_ = <span class="number">0</span>;</span><br><span class="line">  is_match_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">NestedLoopJoinExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  RID left_rid;</span><br><span class="line">  <span class="keyword">if</span> (index_ != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 上次右侧循环还未结束</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NestedLoop</span>(tuple, rid)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取左孩子的一个tuple存储在left_tuple_中</span></span><br><span class="line">  <span class="keyword">while</span> (left_executor_-&gt;<span class="built_in">Next</span>(&amp;left_tuple_, &amp;left_rid)) &#123;</span><br><span class="line">    right_executor_-&gt;<span class="built_in">Init</span>();  <span class="comment">// no use 单纯为了通过测试</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NestedLoop</span>(tuple, rid)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">NestedLoopJoinExecutor::NestedLoop</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (index_ &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_tuples_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (plan_-&gt;predicate_) &#123;</span><br><span class="line">      <span class="keyword">auto</span> res = plan_-&gt;predicate_-&gt;<span class="built_in">EvaluateJoin</span>(&amp;left_tuple_, left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), &amp;right_tuples_[index_], right_executor_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">      <span class="keyword">if</span> (!(!res.<span class="built_in">IsNull</span>() &amp;&amp; res.<span class="built_in">GetAs</span>&lt;<span class="type">bool</span>&gt;())) &#123;  <span class="comment">// 不符合条件</span></span><br><span class="line">        index_++;</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// 过滤</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 符合条件</span></span><br><span class="line">    <span class="built_in">MergeTuple</span>(tuple);</span><br><span class="line">    index_ = (index_ + <span class="number">1</span>) % right_tuples_.<span class="built_in">size</span>();</span><br><span class="line">    is_match_ = (index_ != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  index_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!is_match_ &amp;&amp; plan_-&gt;<span class="built_in">GetJoinType</span>() == JoinType::LEFT) &#123;</span><br><span class="line">    <span class="comment">// left join</span></span><br><span class="line">    std::vector&lt;Value&gt; values;</span><br><span class="line">    values.<span class="built_in">reserve</span>(<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(left_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">      values.<span class="built_in">emplace_back</span>(left_tuple_.<span class="built_in">GetValue</span>(&amp;left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">      values.<span class="built_in">emplace_back</span>(ValueFactory::<span class="built_in">GetNullValueByType</span>(right_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumn</span>(i).<span class="built_in">GetType</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    *tuple = &#123;values, &amp;<span class="built_in">GetOutputSchema</span>()&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  is_match_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NestedLoopJoinExecutor::MergeTuple</span><span class="params">(Tuple *tuple)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// inner join</span></span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">reserve</span>(<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(left_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(left_tuple_.<span class="built_in">GetValue</span>(&amp;left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(right_tuples_[index_].<span class="built_in">GetValue</span>(&amp;right_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">  &#125;</span><br><span class="line">  *tuple = &#123;values, &amp;<span class="built_in">GetOutputSchema</span>()&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到这里为止，通过SQLLogicTests #7 to #12<br><img src="/../images/cmu15445-project3/16.png" alt="img"><br><img src="/../images/cmu15445-project3/17.png" alt="img"><br><img src="/../images/cmu15445-project3/18.png" alt="img"><br><img src="/../images/cmu15445-project3/19.png" alt="img"><br><img src="/../images/cmu15445-project3/20.png" alt="img"><br><img src="/../images/cmu15445-project3/21.png" alt="img"></p>
<h3 id="HashJoinExecutor实现"><a href="#HashJoinExecutor实现" class="headerlink" title="HashJoinExecutor实现"></a>HashJoinExecutor实现</h3><p> 你将要为HashJoinExecutor实现inner join和left join，使用hash join算法<br> <img src="/../images/cmu15445-project3/9.png" alt="img"><br> 和NestedLoopJoin相同，HashJoin要处理inner join和left join两种情况，而这就会影响HashJoin建表的选择———对于Left join，需要在右表不存在对应匹配时，返回将右表字段用NULL填充的记录。因此对Left Join，在创建哈希表时应该选择右表。</p>
<p>实现思路：<br><br>先遍历右表的所有tuple，收集右表的HashJoinKey，加入哈希表(键值对为HashJoinKey-tuple)<br><br>然后遍历左表的所有tuple，收集左表的HashJoinKey，在哈希表中查找是否有匹配的HashJoinKey，如果匹配成功，拼接<br><br>如果匹配失败，并且是left join，左表的tuple拼接null<br><br>拼接好的结果保存在result_中，由index_下标遍历<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">HashJoinExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> HashJoinPlanNode *plan_;</span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; left_child_;</span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; right_child_;</span><br><span class="line">  std::unordered_map&lt;HashJoinKey, std::vector&lt;Tuple&gt;&gt; map_;</span><br><span class="line">  std::vector&lt;Tuple&gt; result_;</span><br><span class="line">  <span class="type">int</span> index_;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">HashJoinExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  left_child_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  right_child_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple right_tuple;</span><br><span class="line">  RID right_rid;</span><br><span class="line">  <span class="keyword">while</span> (right_child_-&gt;<span class="built_in">Next</span>(&amp;right_tuple, &amp;right_rid)) &#123;</span><br><span class="line">    HashJoinKey key;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;expression : plan_-&gt;<span class="built_in">RightJoinKeyExpressions</span>()) &#123;</span><br><span class="line">      key.column_values_.<span class="built_in">emplace_back</span>(expression-&gt;<span class="built_in">Evaluate</span>(&amp;right_tuple, right_child_-&gt;<span class="built_in">GetOutputSchema</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入哈希表</span></span><br><span class="line">    <span class="keyword">if</span> (map_.<span class="built_in">count</span>(key) != <span class="number">0</span>) &#123;</span><br><span class="line">      map_[key].<span class="built_in">emplace_back</span>(right_tuple);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map_[key] = &#123;right_tuple&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历左侧查询,得到查询结果</span></span><br><span class="line">  Tuple left_tuple;</span><br><span class="line">  RID left_rid;</span><br><span class="line">  <span class="keyword">while</span> (left_child_-&gt;<span class="built_in">Next</span>(&amp;left_tuple, &amp;left_rid)) &#123;</span><br><span class="line">    HashJoinKey key;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;expression : plan_-&gt;<span class="built_in">LeftJoinKeyExpressions</span>()) &#123;</span><br><span class="line">      key.column_values_.<span class="built_in">emplace_back</span>(expression-&gt;<span class="built_in">Evaluate</span>(&amp;left_tuple, left_child_-&gt;<span class="built_in">GetOutputSchema</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map_.<span class="built_in">count</span>(key) != <span class="number">0</span>) &#123;  <span class="comment">// 匹配成功</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : map_[key]) &#123;</span><br><span class="line">        std::vector&lt;Value&gt; values;</span><br><span class="line">        values.<span class="built_in">reserve</span>(<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(left_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">          values.<span class="built_in">emplace_back</span>(left_tuple.<span class="built_in">GetValue</span>(&amp;left_child_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">          values.<span class="built_in">emplace_back</span>(t.<span class="built_in">GetValue</span>(&amp;right_child_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">        &#125;</span><br><span class="line">        result_.<span class="built_in">emplace_back</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plan_-&gt;<span class="built_in">GetJoinType</span>() == JoinType::LEFT) &#123;  <span class="comment">// 匹配失败,但是为LEFT JOIN</span></span><br><span class="line">      std::vector&lt;Value&gt; values;</span><br><span class="line">      values.<span class="built_in">reserve</span>(<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(left_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">        values.<span class="built_in">emplace_back</span>(left_tuple.<span class="built_in">GetValue</span>(&amp;left_child_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">        values.<span class="built_in">emplace_back</span>(ValueFactory::<span class="built_in">GetNullValueByType</span>(right_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumn</span>(i).<span class="built_in">GetType</span>()));</span><br><span class="line">      &#125;</span><br><span class="line">      result_.<span class="built_in">emplace_back</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  index_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">HashJoinExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index_ &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(result_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *tuple = result_[index_];</span><br><span class="line">  index_++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optimizing-NestedLoopJoin-to-HashJoin"><a href="#Optimizing-NestedLoopJoin-to-HashJoin" class="headerlink" title="Optimizing NestedLoopJoin to HashJoin"></a>Optimizing NestedLoopJoin to HashJoin</h3><p>具体来说，当连接谓词是两列之间等条件的合取时，可以使用散列连接算法。就本项目而言，处理单个等值条件以及通过 AND 连接的两个等值条件将获得满分<br><br>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Optimizer::OptimizeNLJAsHashJoin</span><span class="params">(<span class="type">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class="line">  <span class="comment">// TODO(student): implement NestedLoopJoin -&gt; HashJoin optimizer rule</span></span><br><span class="line">  <span class="comment">// Note for 2023 Spring: You should at least support join keys of the form:</span></span><br><span class="line">  <span class="comment">// 1. &lt;column expr&gt; = &lt;column expr&gt;</span></span><br><span class="line">  <span class="comment">// 2. &lt;column expr&gt; = &lt;column expr&gt; AND &lt;column expr&gt; = &lt;column expr&gt;</span></span><br><span class="line">  std::vector&lt;AbstractPlanNodeRef&gt; children;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;child : plan-&gt;<span class="built_in">GetChildren</span>()) &#123;<span class="comment">//递归优化</span></span><br><span class="line">    children.<span class="built_in">emplace_back</span>(<span class="built_in">OptimizeNLJAsHashJoin</span>(child));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> optimized_plan = plan-&gt;<span class="built_in">CloneWithChildren</span>(std::<span class="built_in">move</span>(children));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (optimized_plan-&gt;<span class="built_in">GetType</span>() == PlanType::NestedLoopJoin) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> nlj_plan = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> NestedLoopJoinPlanNode &amp;&gt;(*optimized_plan);</span><br><span class="line">    <span class="built_in">BUSTUB_ENSURE</span>(nlj_plan.children_.<span class="built_in">size</span>() == <span class="number">2</span>, <span class="string">&quot;NLJ should have exactly 2 children.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *expr = <span class="built_in">dynamic_cast</span>&lt;ComparisonExpression *&gt;(nlj_plan.<span class="built_in">Predicate</span>().<span class="built_in">get</span>()); expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (expr-&gt;comp_type_ == ComparisonType::Equal) &#123; <span class="comment">// 如果表达式的Type为 ComparisonType::Equal</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> *left_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr-&gt;children_[<span class="number">0</span>].<span class="built_in">get</span>()); left_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">auto</span> *right_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr-&gt;children_[<span class="number">1</span>].<span class="built_in">get</span>());</span><br><span class="line">              right_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            std::vector&lt;AbstractExpressionRef&gt; left_key_expressions;</span><br><span class="line">            std::vector&lt;AbstractExpressionRef&gt; right_key_expressions;</span><br><span class="line">            <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">              left_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                  std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">              right_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                  std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">1</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">              left_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                  std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">              right_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                  std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">1</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;HashJoinPlanNode&gt;(nlj_plan.output_schema_, nlj_plan.<span class="built_in">GetLeftPlan</span>(),</span><br><span class="line">                                                      nlj_plan.<span class="built_in">GetRightPlan</span>(), std::<span class="built_in">move</span>(left_key_expressions),</span><br><span class="line">                                                      std::<span class="built_in">move</span>(right_key_expressions), nlj_plan.<span class="built_in">GetJoinType</span>());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *expr = <span class="built_in">dynamic_cast</span>&lt;LogicExpression *&gt;(nlj_plan.<span class="built_in">Predicate</span>().<span class="built_in">get</span>()); expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (expr-&gt;logic_type_ == LogicType::And) &#123;<span class="comment">//如果表达式的 Type为 LogicType::And</span></span><br><span class="line">        <span class="built_in">BUSTUB_ASSERT</span>(expr-&gt;<span class="built_in">GetChildren</span>().<span class="built_in">size</span>() == <span class="number">2</span>, <span class="string">&quot;LogicExpression has two children&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> *expr1 = <span class="built_in">dynamic_cast</span>&lt;ComparisonExpression *&gt;(expr-&gt;children_[<span class="number">0</span>].<span class="built_in">get</span>()); expr1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">auto</span> *expr2 = <span class="built_in">dynamic_cast</span>&lt;ComparisonExpression *&gt;(expr-&gt;children_[<span class="number">1</span>].<span class="built_in">get</span>()); expr2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expr1-&gt;comp_type_ == ComparisonType::Equal &amp;&amp; expr2-&gt;comp_type_ == ComparisonType::Equal) &#123; <span class="comment">// 两个子表达式的Type均为 ComparisonType::Equal</span></span><br><span class="line">              std::vector&lt;AbstractExpressionRef&gt; left_key_expressions;</span><br><span class="line">              std::vector&lt;AbstractExpressionRef&gt; right_key_expressions;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">auto</span> *left_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr1-&gt;children_[<span class="number">0</span>].<span class="built_in">get</span>());</span><br><span class="line">                  left_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">auto</span> *right_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr1-&gt;children_[<span class="number">1</span>].<span class="built_in">get</span>());</span><br><span class="line">                    right_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                    left_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                    right_key_expressions.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(</span><br><span class="line">                        <span class="number">1</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    left_key_expressions.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(</span><br><span class="line">                        <span class="number">0</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                    right_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">1</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">auto</span> *left_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr2-&gt;children_[<span class="number">0</span>].<span class="built_in">get</span>());</span><br><span class="line">                  left_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">auto</span> *right_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr2-&gt;children_[<span class="number">1</span>].<span class="built_in">get</span>());</span><br><span class="line">                    right_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                    left_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                    right_key_expressions.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(</span><br><span class="line">                        <span class="number">1</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    left_key_expressions.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(</span><br><span class="line">                        <span class="number">0</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                    right_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">1</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;HashJoinPlanNode&gt;(nlj_plan.output_schema_, nlj_plan.<span class="built_in">GetLeftPlan</span>(),</span><br><span class="line">                                                        nlj_plan.<span class="built_in">GetRightPlan</span>(), std::<span class="built_in">move</span>(left_key_expressions),</span><br><span class="line">                                                        std::<span class="built_in">move</span>(right_key_expressions), nlj_plan.<span class="built_in">GetJoinType</span>());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> optimized_plan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里为止，通过SQLLogicTests #14 to #15<br><img src="/../images/cmu15445-project3/22.png" alt="img"><br><img src="/../images/cmu15445-project3/23.png" alt="img"><br><img src="/../images/cmu15445-project3/24.png" alt="img"></p>
<h2 id="Task-3-Sort-Limit-Executors-and-Top-N-Optimization"><a href="#Task-3-Sort-Limit-Executors-and-Top-N-Optimization" class="headerlink" title="Task#3 Sort + Limit Executors and Top-N Optimization"></a>Task#3 Sort + Limit Executors and Top-N Optimization</h2><h3 id="SortExecutor实现："><a href="#SortExecutor实现：" class="headerlink" title="SortExecutor实现："></a>SortExecutor实现：</h3><p>如果查询的ORDER BY属性与索引的key不匹配，BusTub将为查询生成一个SortPlanNode<br><br>如果查询不包含排序方向(即ASC、DESC)，则排序模式将为默认(即ASC)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SortExecutor</span> &#123;</span><br><span class="line">  <span class="comment">//添加数据成员</span></span><br><span class="line">  <span class="type">const</span> SortPlanNode *plan_;</span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;</span><br><span class="line">  std::vector&lt;Tuple&gt; result_;</span><br><span class="line">  <span class="type">int</span> index_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Tuple tuple;</span><br><span class="line">  RID rid;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;<span class="comment">//遍历孩子executor的所有tuple放入result_</span></span><br><span class="line">    result_.<span class="built_in">emplace_back</span>(tuple);</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">sort</span>(result_.<span class="built_in">begin</span>(), result_.<span class="built_in">end</span>(),</span><br><span class="line">            [<span class="keyword">this</span>](<span class="type">const</span> Tuple &amp;left, <span class="type">const</span> Tuple &amp;right) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">TupleComparator</span>(left, right); &#125;);<span class="comment">//对result_进行排序</span></span><br><span class="line">  index_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SortExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index_ &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(result_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *tuple = result_[index_];</span><br><span class="line">  index_++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SortExecutor::TupleComparator</span><span class="params">(<span class="type">const</span> Tuple &amp;left, <span class="type">const</span> Tuple &amp;right)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;order_by = plan_-&gt;<span class="built_in">GetOrderBy</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : order_by) &#123;</span><br><span class="line">    <span class="keyword">auto</span> order = p.first;</span><br><span class="line">    <span class="keyword">auto</span> &amp;exp = p.second;</span><br><span class="line">    <span class="keyword">auto</span> lvalue = exp-&gt;<span class="built_in">Evaluate</span>(&amp;left, child_executor_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    <span class="keyword">auto</span> rvalue = exp-&gt;<span class="built_in">Evaluate</span>(&amp;right, child_executor_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    <span class="keyword">if</span> (order == OrderByType::DESC) &#123;</span><br><span class="line">      <span class="keyword">if</span> (lvalue.<span class="built_in">CompareGreaterThan</span>(rvalue) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lvalue.<span class="built_in">CompareLessThan</span>(rvalue) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lvalue.<span class="built_in">CompareLessThan</span>(rvalue) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lvalue.<span class="built_in">CompareGreaterThan</span>(rvalue) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">UNREACHABLE</span>(<span class="string">&quot;duplicate key is not allowed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LimitExecutor实现"><a href="#LimitExecutor实现" class="headerlink" title="LimitExecutor实现:"></a>LimitExecutor实现:</h3><p>LimitExectutor限制其子executor的输出tuple数量。如果其子executor生成的元组数量小于LimitExecutor中指定的限制，则该executor无效并生成它接受到的所有tuple</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LimitExecutor</span> &#123;</span><br><span class="line">  <span class="comment">//添加数据成员</span></span><br><span class="line">  <span class="type">const</span> LimitPlanNode *plan_;</span><br><span class="line">  <span class="comment">/** The child executor from which tuples are obtained */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;</span><br><span class="line">  <span class="type">size_t</span> num_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LimitExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  num_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LimitExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num_ &gt;= plan_-&gt;<span class="built_in">GetLimit</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;</span><br><span class="line">    num_++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-N-Optimization-Rule"><a href="#Top-N-Optimization-Rule" class="headerlink" title="Top-N Optimization Rule"></a>Top-N Optimization Rule</h3><p>用一个优先队列维护top n 条tuple</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TopNExecutor</span> &#123;</span><br><span class="line">  <span class="comment">//数据成员</span></span><br><span class="line">  <span class="type">const</span> TopNPlanNode *plan_;</span><br><span class="line">  <span class="comment">/** The child executor from which tuples are obtained */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;</span><br><span class="line">  std::priority_queue&lt;HeapKeyType&gt; heap_;<span class="comment">//一个优先队列</span></span><br><span class="line">  std::deque&lt;Tuple&gt; result_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TopNExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple tuple;</span><br><span class="line">  RID rid;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;<span class="comment">//child_executor_遍历所有的tuple</span></span><br><span class="line">    <span class="function">HeapKeyType <span class="title">key</span><span class="params">(tuple, plan_-&gt;GetOrderBy(), child_executor_.get())</span></span>;</span><br><span class="line">    heap_.<span class="built_in">emplace</span>(tuple, plan_-&gt;<span class="built_in">GetOrderBy</span>(), child_executor_.<span class="built_in">get</span>());<span class="comment">//加入优先队列中</span></span><br><span class="line">    <span class="keyword">if</span> (heap_.<span class="built_in">size</span>() &gt; plan_-&gt;<span class="built_in">GetN</span>()) &#123;<span class="comment">//保证优先队列中的size不超过N</span></span><br><span class="line">      heap_.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!heap_.<span class="built_in">empty</span>()) &#123;<span class="comment">//将heap中的tuple_都放入result_</span></span><br><span class="line">    result_.<span class="built_in">emplace_front</span>(heap_.<span class="built_in">top</span>().tuple_);</span><br><span class="line">    heap_.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TopNExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetNumInHeap</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">    *tuple = result_.<span class="built_in">front</span>();</span><br><span class="line">    result_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TopNExecutor::GetNumInHeap</span><span class="params">()</span> -&gt; <span class="type">size_t</span> </span>&#123; <span class="keyword">return</span> result_.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>到这里为止，通过SQLLogicTests #16 to #19<br><img src="/../images/cmu15445-project3/25.png" alt="img"><br><img src="/../images/cmu15445-project3/26.png" alt="img"><br><img src="/../images/cmu15445-project3/27.png" alt="img"><br><img src="/../images/cmu15445-project3/28.png" alt="img"></p>
<p>通过线上测试:<br><img src="/../images/cmu15445-project3/29.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2024/02/26/cmu15445-project2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/26/cmu15445-project2/" class="post-title-link" itemprop="url">cmu15445-project2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-26 22:16:24" itemprop="dateCreated datePublished" datetime="2024-02-26T22:16:24-08:00">2024-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-27 19:25:45" itemprop="dateModified" datetime="2024-02-27T19:25:45-08:00">2024-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15445-2023/" itemprop="url" rel="index"><span itemprop="name">cmu15445-2023</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h1><p>B+ Tree是一种自平衡树，它将数据有序地存储，并且在search、sequential access、insertions以及deletions操作的复杂度上都满足O(logn),其中sequential access的最终复杂度还与所需数据总量有关<br><img src="/../images/cmu15445-project2/1.png" alt="img"><br>以M—way B+tree为例，它的特点总结如下：</p>
<ul>
<li>每个节点最多存储M个key，有M+1个children</li>
<li>B+ Tree是perfectly balanced，即每个leaf node的深度都一样</li>
<li>除了root节点，所有节点必须至少处于半满状态，即 M&#x2F;2 - 1 &lt;&#x3D; #keys &lt;&#x3D; M - 1</li>
<li>假设每个inner node中包含k个keys，那么它必然有k + 1个children</li>
</ul>
<h1 id="B-Tree-Operations"><a href="#B-Tree-Operations" class="headerlink" title="B+ Tree Operations"></a>B+ Tree Operations</h1><p>Insert</p>
<blockquote>
<ol>
<li>找到对应的leafNode L</li>
<li>将key&#x2F;value pair按顺序插入到 L 中</li>
<li>如果L 还有足够的空间，操作结束；如果空间不足，则需要将L分裂成两个节点，同时在parent node上新增entry，若parent node也空间不足，则递归地分裂，直到root node为止</li>
</ol>
</blockquote>
<p>Max.degree &#x3D; 5时<br><br>从1插入到13的情况  <a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">BPlusTree可视化网站</a><br><img src="/../images/cmu15445-project2/2.png" alt="img"></p>
<p>Delete</p>
<blockquote>
<ol>
<li>从root开始，找到目标entry所在的leaf node L</li>
<li>删除该entry</li>
<li>如果L仍然处在半满状态，操作结束；否则先尝试从siblings那里借entries，如果失败，则将L 与相应的sibling合并</li>
<li>如果合并发生了，则可能需要递归地删除parent node中的entry</li>
</ol>
</blockquote>
<h1 id="CheckPoint-1"><a href="#CheckPoint-1" class="headerlink" title="CheckPoint#1"></a>CheckPoint#1</h1><h2 id="Task-1-B-Tree-Pages"><a href="#Task-1-B-Tree-Pages" class="headerlink" title="Task #1 B+ Tree Pages"></a>Task #1 B+ Tree Pages</h2><h3 id="class-BPlusTreePage的3个类成员"><a href="#class-BPlusTreePage的3个类成员" class="headerlink" title="class BPlusTreePage的3个类成员"></a>class BPlusTreePage的3个类成员</h3><p><img src="/../images/cmu15445-project2/3.png" alt="img"><br>GetMinSize函数实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPlusTreePage::GetMinSize</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsLeafPage</span>()) &#123;<span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">return</span> max_size_ / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (max_size_ + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="class-BPlusTreeInternalPage-public-BPlusTreePage"><a href="#class-BPlusTreeInternalPage-public-BPlusTreePage" class="headerlink" title="class BPlusTreeInternalPage : public BPlusTreePage "></a>class BPlusTreeInternalPage : public BPlusTreePage <br></h3><blockquote>
<p>一个Internal Page存储 m 个顺序 key 和 m + 1 个child pointers(其它BPlusTreePage的page_ids)<br><br>使用一个数组存储key&#x2F;page_id pairs，并且第一个key被设置为invalid，并且查找要从第二个key开始查找</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::Init</span><span class="params">(<span class="type">int</span> max_size, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetPageType</span>(IndexPageType::INTERNAL_PAGE);</span><br><span class="line">  <span class="built_in">SetMaxSize</span>(max_size);</span><br><span class="line">  <span class="built_in">SetSize</span>(size);<span class="comment">//size 默认为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::ValueIndex</span><span class="params">(<span class="type">const</span> ValueType &amp;value)</span> <span class="type">const</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">GetSize</span>(); ++i) &#123;<span class="comment">//顺序查找</span></span><br><span class="line">    <span class="keyword">if</span> (array_[i].second == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::LookUp</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> KeyComparator &amp;comparator)</span> <span class="type">const</span> -&gt; ValueType </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">GetSize</span>(); ++i) &#123;  <span class="comment">// 顺序查找</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator</span>(key, array_[i].first) &lt; <span class="number">0</span>) &#123;<span class="comment">//找到第一个大于key的array_[i].first</span></span><br><span class="line">      <span class="keyword">return</span> array_[i - <span class="number">1</span>].second;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array_[<span class="built_in">GetSize</span>() - <span class="number">1</span>].second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::Insert</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value, <span class="type">const</span> KeyComparator &amp;comparator)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetSize</span>() == <span class="built_in">GetMaxSize</span>()) &#123;<span class="comment">//已经满了返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// upper_bound</span></span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> r = <span class="built_in">GetSize</span>();</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator</span>(array_[mid].first, key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetSize</span>() - <span class="number">1</span>; i &gt;= l; --i) &#123;<span class="comment">//元素移位</span></span><br><span class="line">    array_[i + <span class="number">1</span>] = array_[i];</span><br><span class="line">  &#125;</span><br><span class="line">  array_[l] = &#123;key, value&#125;;<span class="comment">//存储插入的key-value</span></span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">1</span>);<span class="comment">//size ++</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="class-BPlusTreeLeafPage-public-BPlusTreePage"><a href="#class-BPlusTreeLeafPage-public-BPlusTreePage" class="headerlink" title="class BPlusTreeLeafPage : public BPlusTreePage"></a>class BPlusTreeLeafPage : public BPlusTreePage</h3><blockquote>
<p>一个Leaf Page存储 m 个顺序 key 和 m 个对应的value.value应该为 64-bit record_id 用于表示实际的tuple存储的地方(src&#x2F;include&#x2F;common&#x2F;rid.h)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::Init</span><span class="params">(<span class="type">int</span> max_size, <span class="type">int</span> size, <span class="type">page_id_t</span> next_page_id)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetPageType</span>(IndexPageType::LEAF_PAGE);</span><br><span class="line">  <span class="built_in">SetMaxSize</span>(max_size);</span><br><span class="line">  <span class="built_in">SetSize</span>(size);<span class="comment">//size 默认为0</span></span><br><span class="line">  <span class="built_in">SetNextPageId</span>(next_page_id);<span class="comment">//next_page_id默认为INVALID_PAGE_ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::KeyIndex</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> KeyComparator &amp;comparator, <span class="type">int</span> &amp;index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// lower_bound</span></span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> r = <span class="built_in">GetSize</span>();</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator</span>(array_[mid].first, key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  index = l;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(l != <span class="built_in">GetSize</span>() &amp;&amp; <span class="built_in">comparator</span>(<span class="built_in">KeyAt</span>(l), key) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::Insert</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value, <span class="type">const</span> KeyComparator &amp;comparator)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">KeyIndex</span>(key, comparator, pos)) &#123;  <span class="comment">// duplicate key</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//重复的key，直接返回false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetSize</span>() - <span class="number">1</span>; i &gt;= pos; --i) &#123;<span class="comment">//移动array_元素</span></span><br><span class="line">    array_[i + <span class="number">1</span>] = array_[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// insert</span></span><br><span class="line">  array_[pos] = &#123;key, value&#125;;<span class="comment">//插入key-value</span></span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">1</span>);<span class="comment">//size ++</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Class-BplusTreeHeaderPage"><a href="#Class-BplusTreeHeaderPage" class="headerlink" title="Class BplusTreeHeaderPage"></a>Class BplusTreeHeaderPage</h3><blockquote>
<p>头节点，存储了root page id，使得根节点和非根节点一样拥有父节点</p>
</blockquote>
<h2 id="Task-2a-B-Tree-Data-Structure-Insertion-Point-Search"><a href="#Task-2a-B-Tree-Data-Structure-Insertion-Point-Search" class="headerlink" title="Task #2a B+ Tree Data Structure(Insertion, Point Search)"></a>Task #2a B+ Tree Data Structure(Insertion, Point Search)</h2><p>GetRootPageId函数实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS <span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::GetRootPageId</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">page_id_t</span> </span>&#123;</span><br><span class="line">  ReadPageGuard guard = bpm_-&gt;<span class="built_in">FetchPageRead</span>(header_page_id_);</span><br><span class="line">  <span class="keyword">auto</span> page = guard.<span class="built_in">As</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">return</span> page-&gt;root_page_id_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Search操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::GetValue</span><span class="params">(<span class="type">const</span> KeyType &amp;key, std::vector&lt;ValueType&gt; *result, Transaction *txn)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Declaration of context instance.</span></span><br><span class="line">  Context ctx;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//先给header_page加读锁判断root_page是否存在，如果存在，给root_page加读锁，放入Context中</span></span><br><span class="line">    <span class="keyword">auto</span> header_page_guard = bpm_-&gt;<span class="built_in">FetchPageRead</span>(header_page_id_);</span><br><span class="line">    <span class="keyword">auto</span> header_page = header_page_guard.<span class="built_in">As</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">    <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">    ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(ctx.root_page_id_));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//查找到对应的leafPage</span></span><br><span class="line">  <span class="built_in">FindLeafPage</span>(key, Operation::Search, ctx);</span><br><span class="line">  <span class="keyword">auto</span> leaf_page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;LeafPage&gt;();</span><br><span class="line">  <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">KeyIndex</span>(key, comparator_, index)) &#123;</span><br><span class="line">    result-&gt;<span class="built_in">push_back</span>(leaf_page-&gt;<span class="built_in">ValueAt</span>(index));<span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::FindLeafPage</span><span class="params">(<span class="type">const</span> KeyType &amp;key, Operation op, Context &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Search) &#123;</span><br><span class="line">    <span class="comment">//Search的加锁策略</span></span><br><span class="line">    <span class="comment">//从root往下，不断地</span></span><br><span class="line">    <span class="comment">// - 获取child的read latch</span></span><br><span class="line">    <span class="comment">// - 释放parent的read latch</span></span><br><span class="line">    <span class="keyword">auto</span> page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> internal = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;InternalPage&gt;();</span><br><span class="line">      <span class="keyword">auto</span> next_page_id = internal-&gt;<span class="built_in">LookUp</span>(key, comparator_);</span><br><span class="line">      ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(next_page_id));</span><br><span class="line">      ctx.read_set_.<span class="built_in">pop_front</span>();</span><br><span class="line">      page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Insert || op == Operation::Remove) &#123;</span><br><span class="line">    <span class="comment">//Insert和Remove的加锁策略</span></span><br><span class="line">    <span class="comment">//从root往下，按照需要获取write latch，一旦获取到了child的write latch，检查</span></span><br><span class="line">    <span class="comment">//它是否安全，如果安全，则释放之前获取的所有write latch</span></span><br><span class="line">    <span class="keyword">auto</span> page = ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> internal = ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;InternalPage&gt;();</span><br><span class="line">      <span class="keyword">auto</span> next_page_id = internal-&gt;<span class="built_in">LookUp</span>(key, comparator_);</span><br><span class="line">      ctx.write_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageWrite</span>(next_page_id));</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">IsSafePage</span>(ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;(), op, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ctx.write_set_.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          ctx.write_set_.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      page = ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::IsSafePage</span><span class="params">(<span class="type">const</span> BPlusTreePage *tree_page, Operation op, <span class="type">bool</span> isRootPage)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Search) &#123;<span class="comment">//no use</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Insert) &#123;<span class="comment">//插入操作</span></span><br><span class="line">    <span class="comment">//若会发生上溢，表示不安全</span></span><br><span class="line">    <span class="keyword">if</span> (tree_page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">      <span class="comment">//叶子节点中，size最大为tree_page-&gt;GetMaxSize() - 1;</span></span><br><span class="line">      <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() + <span class="number">1</span> &lt; tree_page-&gt;<span class="built_in">GetMaxSize</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部节点中，size最大为tree_page-&gt;GetMaxSize()</span></span><br><span class="line">    <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() &lt; tree_page-&gt;<span class="built_in">GetMaxSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Remove) &#123;<span class="comment">//删除操作</span></span><br><span class="line">    <span class="comment">//若会发生下溢，表示不安全</span></span><br><span class="line">    <span class="keyword">if</span> (isRootPage) &#123;<span class="comment">//对RootPage进行Remove操作</span></span><br><span class="line">      <span class="keyword">if</span> (tree_page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">        <span class="comment">//如果为叶子节点，size至少为2</span></span><br><span class="line">        <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() &gt; <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果为内部节点，size至少为3</span></span><br><span class="line">      <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() &gt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() &gt; tree_page-&gt;<span class="built_in">GetMinSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Insert操作</p>
<blockquote>
<p>插入到leaf节点中，插入前，如果size &#x3D;&#x3D; max_size表示溢出，需要进行分裂<br>插入到internal节点中，插入前，如果size &#x3D;&#x3D; max_size表示溢出，需要进行分裂 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS <span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::Insert</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value, Transaction *txn)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Declaration of context instance.</span></span><br><span class="line">  Context ctx;</span><br><span class="line">  ctx.header_page_ = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(header_page_id_);<span class="comment">//先给header_page_id写锁</span></span><br><span class="line">  <span class="keyword">auto</span> header_page = ctx.header_page_-&gt;<span class="built_in">AsMut</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;  <span class="comment">// root not exist,start a new tree</span></span><br><span class="line">    <span class="keyword">auto</span> root_guard = bpm_-&gt;<span class="built_in">NewPageGuarded</span>(&amp;ctx.root_page_id_);<span class="comment">//申请root_page</span></span><br><span class="line">    header_page-&gt;root_page_id_ = ctx.root_page_id_;</span><br><span class="line">    <span class="keyword">auto</span> leaf_page = root_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line">    leaf_page-&gt;<span class="built_in">Init</span>(leaf_max_size_, <span class="number">1</span>);</span><br><span class="line">    leaf_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>] = &#123;key, value&#125;;<span class="comment">//插入key-value</span></span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">  ctx.write_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageWrite</span>(ctx.root_page_id_));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsSafePage</span>(ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;(), Operation::Insert, <span class="literal">true</span>)) &#123;<span class="comment">//如果root_page安全，释放header_page的写锁</span></span><br><span class="line">    ctx.header_page_ = std::<span class="literal">nullopt</span>;  <span class="comment">// unlock header_page</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">FindLeafPage</span>(key, Operation::Insert, ctx);</span><br><span class="line">  <span class="keyword">auto</span> &amp;leaf_page_guard = ctx.write_set_.<span class="built_in">back</span>();</span><br><span class="line">  <span class="keyword">auto</span> leaf_page = leaf_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (!leaf_page-&gt;<span class="built_in">Insert</span>(key, value, comparator_)) &#123;  <span class="comment">// duplicate key, 插入失败</span></span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">GetSize</span>() &lt; leaf_page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 叶子节点未溢出，不需要分裂</span></span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发生溢出,叶子节点分裂</span></span><br><span class="line">  <span class="keyword">auto</span> new_page_id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> new_leaf_page_guard = bpm_-&gt;<span class="built_in">NewPageGuarded</span>(&amp;new_page_id);</span><br><span class="line">  <span class="keyword">auto</span> new_leaf_page = new_leaf_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line">  std::<span class="built_in">copy</span>(leaf_page-&gt;<span class="built_in">GetArray</span>() + leaf_page-&gt;<span class="built_in">GetMinSize</span>(), leaf_page-&gt;<span class="built_in">GetArray</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">            new_leaf_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">  new_leaf_page-&gt;<span class="built_in">Init</span>(leaf_max_size_, leaf_page-&gt;<span class="built_in">GetSize</span>() - leaf_page-&gt;<span class="built_in">GetMinSize</span>(), leaf_page-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">  leaf_page-&gt;<span class="built_in">SetNextPageId</span>(new_leaf_page_guard.<span class="built_in">PageId</span>());</span><br><span class="line">  leaf_page-&gt;<span class="built_in">SetSize</span>(leaf_page-&gt;<span class="built_in">GetMinSize</span>());</span><br><span class="line">  KeyType split_key = new_leaf_page-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 将split_key插入父节点</span></span><br><span class="line">  <span class="built_in">InsertIntoParent</span>(split_key, new_leaf_page_guard.<span class="built_in">PageId</span>(), ctx, ctx.write_set_.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">  ctx.<span class="built_in">Drop</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPLUSTREE_TYPE::InsertIntoParent</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">page_id_t</span> right_child_id, Context &amp;ctx, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;  <span class="comment">// parent为header_page</span></span><br><span class="line">    <span class="comment">//创建新的root_page，并更新header_page中的root_page_id_</span></span><br><span class="line">    <span class="keyword">auto</span> new_root_page_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> new_root_page_guard = bpm_-&gt;<span class="built_in">NewPageGuarded</span>(&amp;new_root_page_id);</span><br><span class="line">    <span class="keyword">auto</span> new_root_page = new_root_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">    new_root_page-&gt;<span class="built_in">Init</span>(internal_max_size_, <span class="number">2</span>);</span><br><span class="line">    new_root_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].second = ctx.write_set_[index + <span class="number">1</span>].<span class="built_in">PageId</span>();</span><br><span class="line">    new_root_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">1</span>] = &#123;key, right_child_id&#125;;</span><br><span class="line">    <span class="keyword">auto</span> header_page = ctx.header_page_-&gt;<span class="built_in">AsMut</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">    header_page-&gt;root_page_id_ = new_root_page_id;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> parent_page = ctx.write_set_[index].<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (parent_page-&gt;<span class="built_in">Insert</span>(key, right_child_id, comparator_)) &#123;  <span class="comment">// 父节点不需要分裂</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父节点需要分裂</span></span><br><span class="line">  <span class="keyword">auto</span> new_parent_page_id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> new_parent_page_guard = bpm_-&gt;<span class="built_in">NewPageGuarded</span>(&amp;new_parent_page_id);</span><br><span class="line">  <span class="keyword">auto</span> new_parent_page = new_parent_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">auto</span> array = <span class="keyword">new</span> std::pair&lt;KeyType, <span class="type">page_id_t</span>&gt;[parent_page-&gt;<span class="built_in">GetMaxSize</span>() + <span class="number">1</span>];</span><br><span class="line">  std::<span class="built_in">copy</span>(parent_page-&gt;<span class="built_in">GetArray</span>(), parent_page-&gt;<span class="built_in">GetArray</span>() + parent_page-&gt;<span class="built_in">GetMaxSize</span>(), array);</span><br><span class="line">  <span class="comment">// upper_bound</span></span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> r = parent_page-&gt;<span class="built_in">GetMaxSize</span>();</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator_</span>(array[mid].first, key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 右移一位，腾出空间</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = parent_page-&gt;<span class="built_in">GetMaxSize</span>() - <span class="number">1</span>; i &gt;= l; --i) &#123;</span><br><span class="line">    array[i + <span class="number">1</span>] = array[i];</span><br><span class="line">  &#125;</span><br><span class="line">  array[l] = &#123;key, right_child_id&#125;;</span><br><span class="line">  std::<span class="built_in">copy</span>(array, array + parent_page-&gt;<span class="built_in">GetMinSize</span>(), parent_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">  std::<span class="built_in">copy</span>(array + parent_page-&gt;<span class="built_in">GetMinSize</span>(), array + parent_page-&gt;<span class="built_in">GetMaxSize</span>() + <span class="number">1</span>, new_parent_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">  new_parent_page-&gt;<span class="built_in">Init</span>(internal_max_size_, parent_page-&gt;<span class="built_in">GetMaxSize</span>() + <span class="number">1</span> - parent_page-&gt;<span class="built_in">GetMinSize</span>());</span><br><span class="line">  parent_page-&gt;<span class="built_in">SetSize</span>(parent_page-&gt;<span class="built_in">GetMinSize</span>());</span><br><span class="line">  <span class="keyword">delete</span>[] array;</span><br><span class="line">  <span class="built_in">InsertIntoParent</span>(new_parent_page-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>), new_parent_page_id, ctx, index - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CheckPoint#1本地测试<br><br><img src="/../images/cmu15445-project2/4.png" alt="img"><br><img src="/../images/cmu15445-project2/5.png" alt="img"></p>
<p>线上测试<br><br><img src="/../images/cmu15445-project2/6.png" alt="img"></p>
<h1 id="CheckPoint-2"><a href="#CheckPoint-2" class="headerlink" title="CheckPoint#2"></a>CheckPoint#2</h1><h2 id="Task-2b-B-Tree-Data-Structure-Deletion"><a href="#Task-2b-B-Tree-Data-Structure-Deletion" class="headerlink" title="Task #2b B+ Tree Data Structure(Deletion)"></a>Task #2b B+ Tree Data Structure(Deletion)</h2><p>Deletion操作:</p>
<blockquote>
<p>如果删除的leaf节点是root节点，那么删除后的size &#x3D;&#x3D; 0,表示下溢，需要将header_page中的root_page设置为INVALID_PAGE_ID<br><br>如果删除的leaf节点不是root节点，那么删除后的size &lt; min_size表示下溢<br><br>1.如果有右孩子<br></p>
<blockquote>
<p>2.判断是否能merge(merge_size &lt; max_size),能则merge，否则转3<br><br>3.向右孩子进行borrow<br></p>
</blockquote>
</blockquote>
<blockquote>
<p>4.如果有左孩子<br></p>
<blockquote>
<p>5.判断是否能merge(merge_size &lt; min_size),能则merge，否则转6<br><br>6.向左孩子进行borrow<br></p>
</blockquote>
</blockquote>
<blockquote>
<p>merge操作后需要删除internal节点中的entry, 与删除leaf节点中的entry十分相似<br></p>
</blockquote>
<blockquote>
<p>如果删除的internal节点是root节点，那么删除后的size&#x3D;&#x3D;1表示下溢，需要将header_page_中的root_page_id_设置为page-&gt;GetArray()[0].second<br><br>如果删除的internal节点不是root节点，那么删除后的size &lt; min_size表示下溢<br><br>1.如果有右孩子<br></p>
<blockquote>
<p>2.判断是否能merge(merge_size &lt;&#x3D; max_size),能则merge，否则转3<br><br>3.向右孩子进行borrow<br></p>
</blockquote>
</blockquote>
<blockquote>
<p>4.如果有左孩子<br></p>
<blockquote>
<p>5.判断是否能merge(merge_size &lt;&#x3D; max_size),能则merge，否则转6<br><br>6.向左孩子进行borrow<br></p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPLUSTREE_TYPE::Remove</span><span class="params">(<span class="type">const</span> KeyType &amp;key, Transaction *txn)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Declaration of context instance.</span></span><br><span class="line">  Context ctx;</span><br><span class="line">  ctx.header_page_ = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(header_page_id_);</span><br><span class="line">  <span class="keyword">auto</span> header_page = ctx.header_page_-&gt;<span class="built_in">AsMut</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;  <span class="comment">// root not exist</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">  ctx.write_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageWrite</span>(ctx.root_page_id_));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsSafePage</span>(ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;(), Operation::Remove, <span class="literal">true</span>)) &#123;</span><br><span class="line">    ctx.header_page_ = std::<span class="literal">nullopt</span>;  <span class="comment">// unlock header_page</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">FindLeafPage</span>(key, Operation::Remove, ctx);</span><br><span class="line">  <span class="keyword">auto</span> &amp;leaf_page_guard = ctx.write_set_.<span class="built_in">back</span>();</span><br><span class="line">  <span class="keyword">auto</span> leaf_page = leaf_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// key不存在</span></span><br><span class="line">  <span class="keyword">if</span> (!leaf_page-&gt;<span class="built_in">KeyIndex</span>(key, comparator_, pos)) &#123;</span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// key存在,将其从leaf中删除</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = pos + <span class="number">1</span>; i &lt; leaf_page-&gt;<span class="built_in">GetSize</span>(); ++i) &#123;</span><br><span class="line">    leaf_page-&gt;<span class="built_in">GetArray</span>()[i - <span class="number">1</span>] = leaf_page-&gt;<span class="built_in">GetArray</span>()[i];</span><br><span class="line">  &#125;</span><br><span class="line">  leaf_page-&gt;<span class="built_in">SetSize</span>(leaf_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);  <span class="comment">// 更新leaf_page的size</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">GetSize</span>() &gt;= leaf_page-&gt;<span class="built_in">GetMinSize</span>()) &#123;  <span class="comment">// 无underflow 直接返回</span></span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// underflow</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="built_in">IsRootPage</span>(leaf_page_guard.<span class="built_in">PageId</span>())) &#123;  <span class="comment">// 该叶子节点是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">GetSize</span>() == <span class="number">0</span>) &#123;               <span class="comment">// size为0</span></span><br><span class="line">      header_page-&gt;root_page_id_ = INVALID_PAGE_ID;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> &amp;parent_page_guard = ctx.write_set_[ctx.write_set_.<span class="built_in">size</span>() - <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">auto</span> parent_page = parent_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">auto</span> index = parent_page-&gt;<span class="built_in">ValueIndex</span>(leaf_page_guard.<span class="built_in">PageId</span>());</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(index != <span class="number">-1</span>, <span class="string">&quot;index must not be -1&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果有右brother</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; parent_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">page_id_t</span> right_brother_page_id = parent_page-&gt;<span class="built_in">GetArray</span>()[index + <span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">auto</span> right_brother_page_guard = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(right_brother_page_id);</span><br><span class="line">    <span class="keyword">auto</span> right_brother_page = right_brother_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge_size = right_brother_page-&gt;<span class="built_in">GetSize</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">    <span class="keyword">if</span> (merge_size &lt; leaf_page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 可以合并</span></span><br><span class="line">      <span class="comment">// merge</span></span><br><span class="line">      std::<span class="built_in">copy</span>(right_brother_page-&gt;<span class="built_in">GetArray</span>(), right_brother_page-&gt;<span class="built_in">GetArray</span>() + right_brother_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                leaf_page-&gt;<span class="built_in">GetArray</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>());</span><br><span class="line">      leaf_page-&gt;<span class="built_in">SetSize</span>(merge_size);</span><br><span class="line">      leaf_page-&gt;<span class="built_in">SetNextPageId</span>(right_brother_page-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">      <span class="built_in">RemoveFromParent</span>(index + <span class="number">1</span>, ctx, ctx.write_set_.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// borrow</span></span><br><span class="line">      leaf_page-&gt;<span class="built_in">GetArray</span>()[leaf_page-&gt;<span class="built_in">GetSize</span>()] = right_brother_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>];</span><br><span class="line">      std::<span class="built_in">copy</span>(right_brother_page-&gt;<span class="built_in">GetArray</span>() + <span class="number">1</span>, right_brother_page-&gt;<span class="built_in">GetArray</span>() + right_brother_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                right_brother_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">      leaf_page-&gt;<span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">      right_brother_page-&gt;<span class="built_in">SetSize</span>(right_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">      parent_page-&gt;<span class="built_in">SetKeyAt</span>(index + <span class="number">1</span>, right_brother_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 左brother</span></span><br><span class="line">    <span class="built_in">BUSTUB_ASSERT</span>(index - <span class="number">1</span> &gt;= <span class="number">0</span>, <span class="string">&quot;left brother must exist&quot;</span>);</span><br><span class="line">    <span class="type">page_id_t</span> left_brother_page_id = parent_page-&gt;<span class="built_in">GetArray</span>()[index - <span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">auto</span> left_brother_page_guard = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(left_brother_page_id);</span><br><span class="line">    <span class="keyword">auto</span> left_brother_page = left_brother_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge_size = left_brother_page-&gt;<span class="built_in">GetSize</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">    <span class="keyword">if</span> (merge_size &lt; left_brother_page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 可以合并</span></span><br><span class="line">      <span class="comment">// merge</span></span><br><span class="line">      std::<span class="built_in">copy</span>(leaf_page-&gt;<span class="built_in">GetArray</span>(), leaf_page-&gt;<span class="built_in">GetArray</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                left_brother_page-&gt;<span class="built_in">GetArray</span>() + left_brother_page-&gt;<span class="built_in">GetSize</span>());</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetSize</span>(merge_size);</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetNextPageId</span>(leaf_page-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">      <span class="built_in">RemoveFromParent</span>(index, ctx, ctx.write_set_.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// borrow</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = leaf_page-&gt;<span class="built_in">GetSize</span>(); i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        leaf_page-&gt;<span class="built_in">GetArray</span>()[i] = leaf_page-&gt;<span class="built_in">GetArray</span>()[i - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      leaf_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>] = left_brother_page-&gt;<span class="built_in">GetArray</span>()[left_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>];</span><br><span class="line">      leaf_page-&gt;<span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetSize</span>(left_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">      parent_page-&gt;<span class="built_in">SetKeyAt</span>(index, leaf_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.<span class="built_in">Drop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPLUSTREE_TYPE::RemoveFromParent</span><span class="params">(<span class="type">int</span> valueIndex, Context &amp;ctx, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;page_guard = ctx.write_set_[index];</span><br><span class="line">  <span class="keyword">auto</span> page = page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = valueIndex + <span class="number">1</span>; i &lt; page-&gt;<span class="built_in">GetSize</span>(); ++i) &#123;  <span class="comment">// 删除key value</span></span><br><span class="line">    page-&gt;<span class="built_in">GetArray</span>()[i - <span class="number">1</span>] = page-&gt;<span class="built_in">GetArray</span>()[i];</span><br><span class="line">  &#125;</span><br><span class="line">  page-&gt;<span class="built_in">SetSize</span>(page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);  <span class="comment">// 更新page的size</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">GetSize</span>() &gt;= page-&gt;<span class="built_in">GetMinSize</span>()) &#123;  <span class="comment">// 无underflow</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// underflow</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="built_in">IsRootPage</span>(page_guard.<span class="built_in">PageId</span>())) &#123;  <span class="comment">// 该page是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;<span class="built_in">GetSize</span>() == <span class="number">1</span>) &#123;               <span class="comment">// 根节点需要更换了</span></span><br><span class="line">      <span class="built_in">BUSTUB_ASSERT</span>(ctx.header_page_ != std::<span class="literal">nullopt</span>, <span class="string">&quot;ctx.header_page must exist&quot;</span>);</span><br><span class="line">      <span class="keyword">auto</span> header_page = ctx.header_page_-&gt;<span class="built_in">AsMut</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">      header_page-&gt;root_page_id_ = page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(index - <span class="number">1</span> &gt;= <span class="number">0</span>, <span class="string">&quot;parent_page_guard must exist&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> &amp;parent_page_guard = ctx.write_set_[index - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">auto</span> parent_page = parent_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">auto</span> pos = parent_page-&gt;<span class="built_in">ValueIndex</span>(page_guard.<span class="built_in">PageId</span>());</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(pos != <span class="number">-1</span>, <span class="string">&quot;pos must not be -1&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果有右brother</span></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; parent_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">page_id_t</span> right_brother_page_id = parent_page-&gt;<span class="built_in">GetArray</span>()[pos + <span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">auto</span> right_brother_page_guard = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(right_brother_page_id);</span><br><span class="line">    <span class="keyword">auto</span> right_brother_page = right_brother_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge_size = right_brother_page-&gt;<span class="built_in">GetSize</span>() + page-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">    <span class="keyword">if</span> (merge_size &lt;= page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 可以合并</span></span><br><span class="line">      <span class="comment">// merge</span></span><br><span class="line">      std::<span class="built_in">copy</span>(right_brother_page-&gt;<span class="built_in">GetArray</span>(), right_brother_page-&gt;<span class="built_in">GetArray</span>() + right_brother_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                page-&gt;<span class="built_in">GetArray</span>() + page-&gt;<span class="built_in">GetSize</span>());</span><br><span class="line">      page-&gt;<span class="built_in">SetSize</span>(merge_size);</span><br><span class="line">      <span class="built_in">RemoveFromParent</span>(pos + <span class="number">1</span>, ctx, index - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// borrow</span></span><br><span class="line">      page-&gt;<span class="built_in">GetArray</span>()[page-&gt;<span class="built_in">GetSize</span>()] = right_brother_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>];</span><br><span class="line">      std::<span class="built_in">copy</span>(right_brother_page-&gt;<span class="built_in">GetArray</span>() + <span class="number">1</span>, right_brother_page-&gt;<span class="built_in">GetArray</span>() + right_brother_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                right_brother_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">      page-&gt;<span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">      right_brother_page-&gt;<span class="built_in">SetSize</span>(right_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">      parent_page-&gt;<span class="built_in">SetKeyAt</span>(pos + <span class="number">1</span>, right_brother_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 左brother</span></span><br><span class="line">    <span class="built_in">BUSTUB_ASSERT</span>(pos - <span class="number">1</span> &gt;= <span class="number">0</span>, <span class="string">&quot;left brother must exist&quot;</span>);</span><br><span class="line">    <span class="type">page_id_t</span> left_brother_page_id = parent_page-&gt;<span class="built_in">GetArray</span>()[pos - <span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">auto</span> left_brother_page_guard = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(left_brother_page_id);</span><br><span class="line">    <span class="keyword">auto</span> left_brother_page = left_brother_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge_size = left_brother_page-&gt;<span class="built_in">GetSize</span>() + page-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">    <span class="keyword">if</span> (merge_size &lt;= left_brother_page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 可以合并</span></span><br><span class="line">      <span class="comment">// merge</span></span><br><span class="line">      std::<span class="built_in">copy</span>(page-&gt;<span class="built_in">GetArray</span>(), page-&gt;<span class="built_in">GetArray</span>() + page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                left_brother_page-&gt;<span class="built_in">GetArray</span>() + left_brother_page-&gt;<span class="built_in">GetSize</span>());</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetSize</span>(merge_size);</span><br><span class="line">      <span class="built_in">RemoveFromParent</span>(pos, ctx, index - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// borrow</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = page-&gt;<span class="built_in">GetSize</span>(); i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        page-&gt;<span class="built_in">GetArray</span>()[i] = page-&gt;<span class="built_in">GetArray</span>()[i - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>] = left_brother_page-&gt;<span class="built_in">GetArray</span>()[left_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>];</span><br><span class="line">      page-&gt;<span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetSize</span>(left_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">      parent_page-&gt;<span class="built_in">SetKeyAt</span>(pos, page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Task-3-Index-Iterator"><a href="#Task-3-Index-Iterator" class="headerlink" title="Task #3 Index Iterator"></a>Task #3 Index Iterator</h2><p>Index Iterator 代码实现：</p>
<blockquote>
<p>Index Iterator的实现只需要支持单线程</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">INDEXITERATOR_TYPE::IsEnd</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">bool</span> </span>&#123; <span class="keyword">return</span> read_guard_ == std::<span class="literal">nullopt</span>; &#125;</span><br><span class="line"></span><br><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">auto</span> INDEXITERATOR_TYPE::<span class="keyword">operator</span>*() -&gt; <span class="type">const</span> MappingType &amp; &#123;</span><br><span class="line">  <span class="keyword">auto</span> page = read_guard_-&gt;<span class="built_in">As</span>&lt;B_PLUS_TREE_LEAF_PAGE_TYPE&gt;();</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(page-&gt;<span class="built_in">GetSize</span>() &gt; index_, <span class="string">&quot;index_ must be valid&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> page-&gt;<span class="built_in">GetArray</span>()[index_];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">auto</span> INDEXITERATOR_TYPE::<span class="keyword">operator</span>++() -&gt; INDEXITERATOR_TYPE &amp; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsEnd</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> leaf_page = read_guard_-&gt;<span class="built_in">As</span>&lt;B_PLUS_TREE_LEAF_PAGE_TYPE&gt;();</span><br><span class="line">  <span class="keyword">if</span> (index_ + <span class="number">1</span> &lt; leaf_page-&gt;<span class="built_in">GetSize</span>()) &#123;</span><br><span class="line">    index_++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">GetNextPageId</span>() != INVALID_PAGE_ID) &#123;</span><br><span class="line">    read_guard_ = bpm_-&gt;<span class="built_in">FetchPageRead</span>(leaf_page-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">    index_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  read_guard_ = std::<span class="literal">nullopt</span>;</span><br><span class="line">  index_ = INVALID_PAGE_ID;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>==(<span class="type">const</span> IndexIterator &amp;itr) <span class="type">const</span> -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEnd</span>() &amp;&amp; itr.<span class="built_in">IsEnd</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEnd</span>() || itr.<span class="built_in">IsEnd</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> read_guard_-&gt;<span class="built_in">PageId</span>() == itr.read_guard_-&gt;<span class="built_in">PageId</span>() &amp;&amp; index_ == itr.index_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>!=(<span class="type">const</span> IndexIterator &amp;itr) <span class="type">const</span> -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == itr); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BplusTree实现Begin和End函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::Begin</span><span class="params">()</span> -&gt; INDEXITERATOR_TYPE </span>&#123;</span><br><span class="line">  Context ctx;</span><br><span class="line">  <span class="keyword">auto</span> header_page_guard = bpm_-&gt;<span class="built_in">FetchPageRead</span>(header_page_id_);</span><br><span class="line">  <span class="keyword">auto</span> header_page = header_page_guard.<span class="built_in">As</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">  ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(ctx.root_page_id_));</span><br><span class="line">  header_page_guard.<span class="built_in">Drop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">  <span class="keyword">while</span> (!page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> internal = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;InternalPage&gt;();</span><br><span class="line">    <span class="type">page_id_t</span> id = internal-&gt;<span class="built_in">ValueAt</span>(<span class="number">0</span>);</span><br><span class="line">    ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(id));</span><br><span class="line">    ctx.read_set_.<span class="built_in">pop_front</span>();</span><br><span class="line">    page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>(bpm_, std::<span class="built_in">move</span>(ctx.read_set_.<span class="built_in">back</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::Begin</span><span class="params">(<span class="type">const</span> KeyType &amp;key)</span> -&gt; INDEXITERATOR_TYPE </span>&#123;</span><br><span class="line">  Context ctx;</span><br><span class="line">  <span class="keyword">auto</span> header_page_guard = bpm_-&gt;<span class="built_in">FetchPageRead</span>(header_page_id_);</span><br><span class="line">  <span class="keyword">auto</span> header_page = header_page_guard.<span class="built_in">As</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">  ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(ctx.root_page_id_));</span><br><span class="line">  header_page_guard.<span class="built_in">Drop</span>();</span><br><span class="line">  <span class="built_in">FindLeafPage</span>(key, Operation::Search, ctx);</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;LeafPage&gt;()-&gt;<span class="built_in">KeyIndex</span>(key, comparator_, pos)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;key not exist&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>(bpm_, std::<span class="built_in">move</span>(ctx.read_set_.<span class="built_in">back</span>()), pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::End</span><span class="params">()</span> -&gt; INDEXITERATOR_TYPE </span>&#123; <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>(); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Task-4-Concurrency-Control"><a href="#Task-4-Concurrency-Control" class="headerlink" title="Task #4 Concurrency Control"></a>Task #4 Concurrency Control</h2><h3 id="Latch-Crabbing-Coupling"><a href="#Latch-Crabbing-Coupling" class="headerlink" title="Latch Crabbing&#x2F;Coupling"></a>Latch Crabbing&#x2F;Coupling<br></h3><p>Latch Crabbing 的基本思想如下：<br></p>
<ol>
<li>获取 parent 的 latch<br></li>
<li>获取 child 的 latch<br></li>
<li>如果安全，则可以释放 parent 的 latch</li>
</ol>
<p>这里的“安全”指的是，当发生更新操作时，该节点不会发生 split 或 merge 的操作，即：</p>
<ul>
<li>在插入元素时，节点未满</li>
<li>在删除元素时，节点超过半满</li>
</ul>
<p>Search<br>从 root 往下，不断地：</p>
<ul>
<li>获取 child 的 read latch</li>
<li>释放 parent 的 read latch</li>
</ul>
<p><img src="/../images/cmu15445-project2/8.png" alt="img"><br><img src="/../images/cmu15445-project2/9.png" alt="img"><br><img src="/../images/cmu15445-project2/10.png" alt="img"><br><img src="/../images/cmu15445-project2/11.png" alt="img"><br><img src="/../images/cmu15445-project2/12.png" alt="img"></p>
<p>Insert&#x2F;Delete<br><br>从 root 往下，按照需要获取 write latch，一旦获取了 child 的 write latch，检查它是否安全，如果安全，则释放之前获取的所有 write latch。<br>安全判断函数逻辑见函数IsSafePage<br></p>
<h3 id="Better-Latching-Algorithm"><a href="#Better-Latching-Algorithm" class="headerlink" title="Better Latching Algorithm"></a>Better Latching Algorithm<br></h3><ul>
<li>Search：与 Latch Crabbing 相同<br></li>
<li>Insert&#x2F;Delete:<br><ul>
<li>使用与 Search 相同的方式在查询路径上获取、释放 latch，在 leaf node 上获取 write latch<br></li>
<li>如果 leaf node 不安全，可能会引起其它节点的变动，则使用 Latch Crabbing 的策略再执行一遍<br></li>
</ul>
</li>
</ul>
<p>该方法乐观地假设整个操作只会引起 leaf node 的变化，若假设错误，则使用 Latch Crabbing 的原始方案。<br></p>
<p>CheckPoint#2本地测试<br><br><img src="/../images/cmu15445-project2/13.png" alt="img"><br><img src="/../images/cmu15445-project2/14.png" alt="img"><br><img src="/../images/cmu15445-project2/15.png" alt="img"><br><img src="/../images/cmu15445-project2/16.png" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/bpt-printer/">Bustub Tree printer</a><br></p>
<p>CheckPoint#2线上测试<br><br><img src="/../images/cmu15445-project2/7.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2024/02/26/cmu15445-project1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/26/cmu15445-project1/" class="post-title-link" itemprop="url">cmu15445-project1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-02-26 03:58:49 / Modified: 21:28:57" itemprop="dateCreated datePublished" datetime="2024-02-26T03:58:49-08:00">2024-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15445-2023/" itemprop="url" rel="index"><span itemprop="name">cmu15445-2023</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="project1的任务就是实现一个Buffer-Pool-Manager"><a href="#project1的任务就是实现一个Buffer-Pool-Manager" class="headerlink" title="project1的任务就是实现一个Buffer Pool Manager"></a>project1的任务就是实现一个Buffer Pool Manager<br></h2><p>DBMS启动时会从OS申请一片内存区域，即Buffer Pool，并将这块区域划分成大小相同的pages，为了与disk pages区别，通常称为frames，当DBMS请求一个disk page时，它首先需要被复制到Buffer Pool的一个frame中。当Buffer Pool空间不足时，需要采取某种replacement policy，淘汰已有的page。<br><img src="/../images/cmu15445-project1/1.png" alt="img"></p>
<p>question 1:<br>为什么不使用OS自带的磁盘管理模块，OS为开发者提供了mmap这样的调用，使开发者能够依赖OS自动管理数据在内外存之间的移动？</p>
<blockquote>
<p>DBMS比OS拥有更多、更充分的知识来决定数据移动的移动和数量，具体包括</p>
<ol>
<li>将dirty pages按正确的顺序写到磁盘</li>
<li>根据具体情况预获取数据</li>
<li>定制化缓存置换策略</li>
</ol>
</blockquote>
<p>同时DBMS会维护一个page table，负责记录每个page在内存中的位置，以及是否被写过(Dirty Flag),是否被引用或引用计数(Pin&#x2F;Reference Counter)等元信息，如下图所示:</p>
<p><img src="/../images/cmu15445-project1/2.png" alt="img"></p>
<p>当page table中的某page被引用时，会记录引用数(pin&#x2F;reference),表示该page正在被使用，空间不够时不应该被移除；当被请求的page不再page table中时，DBMS会申请一个latch(lock的别名)，表示该entry被占用，然后从disk中读取相关page到buffer pool，释放latch</p>
<p><img src="/../images/cmu15445-project1/3.png" alt="img"></p>
<h2 id="Buffer-Replacement-Policies"><a href="#Buffer-Replacement-Policies" class="headerlink" title="Buffer Replacement Policies"></a>Buffer Replacement Policies</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>维护每个page上一次被访问的时间戳，每次移除时间戳最早的page</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>Clock是LRU的近似策略，它不需要每个page上次被访问的时间戳，而是为每个page保存一个reference</p>
<ul>
<li>每当page被访问时，reference bit设置为1</li>
<li>每当需要移动page时，从上次访问的位置开始，按顺序轮询，每个page的reference bit，若该bit为1，则重置为0；若该bit为0，则移除该page</li>
</ul>
<h3 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h3><p>保存每个page的最后K次访问时间戳，利用这些时间戳来估计它们下次被访问的时间，通常K取1就能获得很好的效果。</p>
<h2 id="Task-1-LRU-K-Replacement-Policy"><a href="#Task-1-LRU-K-Replacement-Policy" class="headerlink" title="Task#1 LRU-K Replacement Policy"></a>Task#1 LRU-K Replacement Policy</h2><p>实现LRUKReplacer<br>实现策略:</p>
<blockquote>
<p>LRU-K算法驱逐replacer的所有frame中backward k-distance最大的frame<br><br>backward k-distance计算方式:当前时间戳与之前k次访问的时间戳之间的时间差。<br><br>历史访问次数少于k的帧被赋予+inf作为其backward k-distance,当多个frame具有+inf backward k-distance时，replacer将驱逐具有最早总体时间戳的frame<br></p>
</blockquote>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：<br></h3><p>一个LRUKNode对应一个frame</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUKNode</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/** History of last seen K timestamps of this page. Least recent timestamp stored in front. */</span></span><br><span class="line">  std::list&lt;<span class="type">size_t</span>&gt; history_;<span class="comment">//记录一批时间戳</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid_;<span class="comment">//</span></span><br><span class="line">  <span class="type">bool</span> is_evictable_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUKReplacer</span> &#123;</span><br><span class="line">  std::unordered_map&lt;<span class="type">frame_id_t</span>, LRUKNode&gt; node_store_;<span class="comment">//frame LRUKNode couple</span></span><br><span class="line">  <span class="type">size_t</span> current_timestamp_&#123;<span class="number">0</span>&#125;;<span class="comment">//当前时间戳</span></span><br><span class="line">  <span class="comment">//replacer_size_ &gt;= curr_size</span></span><br><span class="line">  <span class="type">size_t</span> curr_size_&#123;<span class="number">0</span>&#125;;<span class="comment">//curr_size为当前is_evictable被标记为true的frame数量</span></span><br><span class="line">  <span class="type">size_t</span> replacer_size_;<span class="comment">//replacer_size == num_frames</span></span><br><span class="line">  <span class="type">size_t</span> k_;</span><br><span class="line">  std::mutex latch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Evict函数</p>
<blockquote>
<p>驱逐一个frame，驱逐成功返回true，否则返回false</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LRUKReplacer::Evict</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  *frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : node_store_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.second.is_evictable_) &#123;<span class="comment">//通过Judge函数选择backward k-distance中最大的frame</span></span><br><span class="line">      <span class="keyword">if</span> (*frame_id == <span class="number">-1</span> || <span class="built_in">Judge</span>(p.second, node_store_[*frame_id])) &#123;</span><br><span class="line">        *frame_id = p.second.fid_;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (*frame_id != <span class="number">-1</span>) &#123;</span><br><span class="line">    node_store_.<span class="built_in">erase</span>(*frame_id);</span><br><span class="line">    --curr_size_;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Judge函数实现如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lhs的backward k-distance大于rhs的backward k-distance 返回true 否则返回false</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Judge</span><span class="params">(<span class="type">const</span> LRUKNode &amp;lhs, <span class="type">const</span> LRUKNode &amp;rhs)</span> <span class="type">const</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rhs.history_.<span class="built_in">size</span>() == k_ &amp;&amp; lhs.history_.<span class="built_in">size</span>() &lt; k_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rhs.history_.<span class="built_in">size</span>() &lt; k_ &amp;&amp; lhs.history_.<span class="built_in">size</span>() == k_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较最早的时间戳,若lhs的时间戳更小，则返回true 否则返回false</span></span><br><span class="line">    <span class="keyword">return</span> lhs.history_.<span class="built_in">back</span>() &lt; rhs.history_.<span class="built_in">back</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>RecordAccess函数</p>
<blockquote>
<ol>
<li>如果访问的frame_id大于等于replacer_size抛出异常</li>
<li>否则，对该frame对应的LRUKNode添加时间戳，并且保证history_列表长度不超过k_</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::RecordAccess</span><span class="params">(<span class="type">frame_id_t</span> frame_id, [[maybe_unused]] AccessType access_type)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (frame_id &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(replacer_size_)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;frame_id is larger than or equal to replacer_size_&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node_store_.<span class="built_in">count</span>(frame_id) == <span class="number">0</span>) &#123;</span><br><span class="line">    node_store_[frame_id] = <span class="built_in">LRUKNode</span>();</span><br><span class="line">    node_store_[frame_id].fid_ = frame_id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> &amp;node = node_store_[frame_id];</span><br><span class="line">  node.history_.<span class="built_in">push_front</span>(current_timestamp_++);</span><br><span class="line">  <span class="keyword">while</span> (node.history_.<span class="built_in">size</span>() &gt; k_) &#123;</span><br><span class="line">    node.history_.<span class="built_in">pop_back</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SetEvictable函数</p>
<blockquote>
<p>将某个frame的is_evictable标记为set_evictable,如果该frame未被占用，抛出异常<br>false-&gt;true   curr_size_++<br>true-&gt;false   curr_size_–</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::SetEvictable</span><span class="params">(<span class="type">frame_id_t</span> frame_id, <span class="type">bool</span> set_evictable)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (node_store_.<span class="built_in">count</span>(frame_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;frame_id should be used&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!node_store_[frame_id].is_evictable_ &amp;&amp; set_evictable) &#123;  <span class="comment">// false -&gt; true</span></span><br><span class="line">    curr_size_++;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node_store_[frame_id].is_evictable_ &amp;&amp; !set_evictable) &#123;  <span class="comment">// true -&gt; false</span></span><br><span class="line">    curr_size_--;</span><br><span class="line">  &#125;</span><br><span class="line">  node_store_[frame_id].is_evictable_ = set_evictable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Remove函数</p>
<blockquote>
<p>如果删除的frame不存在直接返回<br>如果删除的frame的is_evictable_未被设置为true，抛出异常<br>删除frame，–curr_size_</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::Remove</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (node_store_.<span class="built_in">count</span>(frame_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!node_store_[frame_id].is_evictable_) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;Remove a non-evictable frame&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  node_store_.<span class="built_in">erase</span>(frame_id);</span><br><span class="line">  --curr_size_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>task1本地测试：<br><img src="/../images/cmu15445-project1/5.png" alt="img"></p>
<h2 id="Task-2-Buffer-Pool-Manager"><a href="#Task-2-Buffer-Pool-Manager" class="headerlink" title="Task#2 -Buffer Pool Manager"></a>Task#2 -Buffer Pool Manager</h2><p>完成LRU-K替换策略之后，接下来需要实现Buffer Pool的基本功能。对于DBMS来说，Buffer Pool可以隐藏内存和磁盘交互的细节，包括脏页面写回磁盘的过程。</p>
<p>Page</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">  <span class="type">char</span> *data_;<span class="comment">//4096字节</span></span><br><span class="line">  <span class="type">page_id_t</span> page_id;<span class="comment">//physical page id</span></span><br><span class="line">  <span class="type">int</span> pin_count_;<span class="comment">//该Page对象的引用计数</span></span><br><span class="line">  <span class="type">bool</span> is_dirty_;<span class="comment">//脏位</span></span><br><span class="line">  ReaderWriterLatch rwlatch_;<span class="comment">//读写锁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BufferPoolManager</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BufferPoolManager</span> &#123;</span><br><span class="line">    <span class="comment">/** Number of pages in the buffer pool. */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> pool_size_;</span><br><span class="line">  <span class="comment">/** The next page id to be allocated  */</span></span><br><span class="line">  std::atomic&lt;<span class="type">page_id_t</span>&gt; next_page_id_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Array of buffer pool pages. */</span></span><br><span class="line">  Page *pages_;</span><br><span class="line">  <span class="comment">/** Pointer to the disk manager. */</span></span><br><span class="line">  DiskManager *disk_manager_ __attribute__((__unused__));</span><br><span class="line">  <span class="comment">/** Pointer to the log manager. Please ignore this for P1. */</span></span><br><span class="line">  LogManager *log_manager_ __attribute__((__unused__));</span><br><span class="line">  <span class="comment">/** Page table for keeping track of buffer pool pages. */</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_;</span><br><span class="line">  <span class="comment">/** Replacer to find unpinned pages for replacement. */</span></span><br><span class="line">  std::unique_ptr&lt;LRUKReplacer&gt; replacer_;</span><br><span class="line">  <span class="comment">/** List of free frames that don&#x27;t have any pages on them. */</span></span><br><span class="line">  std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;</span><br><span class="line">  <span class="comment">/** This latch protects shared data structures. We recommend updating this comment to describe what it protects. */</span></span><br><span class="line">  std::mutex latch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BufferPoolManager初始化时，分配pool_size_个Page对象，LRUKReplacer的num_frame也设置为pool_size_</p>
<h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：<br></h3><p>NewPage函数实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::NewPage</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> -&gt; Page * </span>&#123;</span><br><span class="line">  <span class="type">frame_id_t</span> free_frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">//获取一个空闲的frame</span></span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;<span class="comment">//存在空的frame</span></span><br><span class="line">    free_frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//不存在空的frame</span></span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Evict</span>(&amp;free_frame_id)) &#123;<span class="comment">//通过LRUKReplacer得到一个空闲的frame</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pages_[free_frame_id].<span class="built_in">IsDirty</span>()) &#123;<span class="comment">//如果被驱逐的frame对应的page为脏页，需要进行写回操作</span></span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[free_frame_id].page_id_, pages_[free_frame_id].data_);</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_.<span class="built_in">erase</span>(pages_[free_frame_id].page_id_);<span class="comment">//将page_table_中该frame对应的page_id_删除</span></span><br><span class="line">    pages_[free_frame_id].<span class="built_in">ResetMemory</span>();<span class="comment">//重置该改frame对应的内存</span></span><br><span class="line">  &#125;</span><br><span class="line">  *page_id = <span class="built_in">AllocatePage</span>();</span><br><span class="line">  pages_[free_frame_id].page_id_ = *page_id;</span><br><span class="line">  pages_[free_frame_id].pin_count_ = <span class="number">1</span>;</span><br><span class="line">  pages_[free_frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  page_table_[*page_id] = free_frame_id;</span><br><span class="line"></span><br><span class="line">  replacer_-&gt;<span class="built_in">RecordAccess</span>(free_frame_id);</span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(free_frame_id, <span class="literal">false</span>);  <span class="comment">// no use</span></span><br><span class="line">  <span class="keyword">return</span> pages_ + free_frame_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FetchPage函数实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPage</span><span class="params">(<span class="type">page_id_t</span> page_id, [[maybe_unused]] AccessType access_type)</span> -&gt; Page * </span>&#123;</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(page_id != INVALID_PAGE_ID, <span class="string">&quot;page_id is equal to INVALID_PAGE_ID&quot;</span>);</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) != <span class="number">0</span>) &#123;<span class="comment">//如果page_table_中存在该page_id</span></span><br><span class="line">    pages_[page_table_[page_id]].pin_count_++;<span class="comment">//该page的引用计数增加</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">RecordAccess</span>(page_table_[page_id]);<span class="comment">//增加该page对应的frame的访问时间戳</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(page_table_[page_id], <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> pages_ + page_table_[page_id];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> free_frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//获取一个空闲的frame</span></span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    free_frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Evict</span>(&amp;free_frame_id)) &#123;<span class="comment">//通过LRUKReplacer得到一个空闲的frame</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pages_[free_frame_id].<span class="built_in">IsDirty</span>()) &#123;<span class="comment">//如果被驱逐的frame对应的page为脏页，需要进行写回操作</span></span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[free_frame_id].page_id_, pages_[free_frame_id].data_);</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_.<span class="built_in">erase</span>(pages_[free_frame_id].page_id_);<span class="comment">//将page_table_中该frame对应的page_id_删除</span></span><br><span class="line">    pages_[free_frame_id].<span class="built_in">ResetMemory</span>();<span class="comment">//重置该改frame对应的内存</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pages_[free_frame_id].page_id_ = page_id;</span><br><span class="line">  pages_[free_frame_id].pin_count_ = <span class="number">1</span>;</span><br><span class="line">  pages_[free_frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  page_table_[page_id] = free_frame_id;</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, pages_[free_frame_id].data_);<span class="comment">//读取该page_id对应的物理页</span></span><br><span class="line"></span><br><span class="line">  replacer_-&gt;<span class="built_in">RecordAccess</span>(free_frame_id);<span class="comment">//增加该frame的访问时间戳</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(free_frame_id, <span class="literal">false</span>);  <span class="comment">// no use</span></span><br><span class="line">  <span class="keyword">return</span> pages_ + free_frame_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UnpinPage函数实现：<br><br>需要注意的是入参is_dirty不能破坏已经置为脏的状态，这里用 | 运算符来实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::UnpinPage</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty, [[maybe_unused]] AccessType access_type)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = page_table_[page_id];</span><br><span class="line">  <span class="keyword">if</span> (pages_[frame_id].pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (--pages_[frame_id].pin_count_ == <span class="number">0</span>) &#123;<span class="comment">//引用计数减为0时，将该frame设置为evictable</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pages_[frame_id].is_dirty_ |= is_dirty;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FlushPage函数实现:<br><br>强制将page_id对应的Page的内容写回磁盘，并将该Page对应脏位置为false</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FlushPage</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = page_table_[page_id];</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, pages_[frame_id].data_);</span><br><span class="line">  pages_[frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FlushAllPages函数实现:<br>写回所有在内存中的Page</p>
<p>DeletePage函数实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::DeletePage</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = page_table_[page_id];</span><br><span class="line">  <span class="keyword">if</span> (pages_[frame_id].pin_count_ != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//只有当该page_id对应的Page的引用计数为0时可以进行删除</span></span><br><span class="line">  page_table_.<span class="built_in">erase</span>(page_id);<span class="comment">//page_table_删除该page_id</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">true</span>);<span class="comment">//replacer驱逐该frame</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">Remove</span>(frame_id);</span><br><span class="line">  free_list_.<span class="built_in">push_back</span>(frame_id);<span class="comment">//将该frame加入free_list</span></span><br><span class="line">  <span class="comment">//该Page初始化</span></span><br><span class="line">  pages_[frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  pages_[frame_id].page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  pages_[frame_id].<span class="built_in">ResetMemory</span>();</span><br><span class="line">  <span class="built_in">DeallocatePage</span>(page_id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>task2本地测试:<br><img src="/../images/cmu15445-project1/6.png" alt="img"></p>
<h2 id="Task-3-Read-Write-Page-Guards"><a href="#Task-3-Read-Write-Page-Guards" class="headerlink" title="Task#3 Read&#x2F;Write Page Guards"></a>Task#3 Read&#x2F;Write Page Guards</h2><p>FetchPage和NewPage函数返回指向pages的指针，并且pages已经被pinned，并且当一个page不再需要时，要调用UnpinPage。另一方面，如果忘记调用UnPinPage，该Page将永远不会被evict。于是PageGuard就派上用场了</p>
<p>BasicPageGuard<br>思路：BasicPageGuard析构时调用Page的UnpinPage函数，并且BasicPageGuard中保存变量is_dirty_,调用AsMut或GetDataMut函数时将is_dirty_设置为true</p>
<p>WritePageGuard和ReadPageGuard<br>思路：与BasicPageGuard思路相似，析构函数调用UnpinPage多了一步释放Page的写锁和读锁</p>
<p>FetchPageBasic、FetchPageRead、FetchPageWrite和NewPageGuarded的实现代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageBasic</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; BasicPageGuard </span>&#123; <span class="keyword">return</span> &#123;<span class="keyword">this</span>, <span class="built_in">FetchPage</span>(page_id)&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageRead</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; ReadPageGuard </span>&#123;</span><br><span class="line">  Page *page = <span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (page != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    page-&gt;<span class="built_in">RLatch</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, page&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageWrite</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; WritePageGuard </span>&#123;</span><br><span class="line">  Page *page = <span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (page != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, page&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::NewPageGuarded</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> -&gt; BasicPageGuard </span>&#123; <span class="keyword">return</span> &#123;<span class="keyword">this</span>, <span class="built_in">NewPage</span>(page_id)&#125;; &#125;</span><br></pre></td></tr></table></figure>
<p>task3本地测试：<br><img src="/../images/cmu15445-project1/7.png" alt="img"></p>
<p>测试通过截图：<br><img src="/../images/cmu15445-project1/4.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2024/02/22/cmu15445-project0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/22/cmu15445-project0/" class="post-title-link" itemprop="url">cmu15445-project0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-22 02:15:27" itemprop="dateCreated datePublished" datetime="2024-02-22T02:15:27-08:00">2024-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-26 03:53:04" itemprop="dateModified" datetime="2024-02-26T03:53:04-08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15445-2023/" itemprop="url" rel="index"><span itemprop="name">cmu15445-2023</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TASK-1-Copy-On-Write-Trie"><a href="#TASK-1-Copy-On-Write-Trie" class="headerlink" title="TASK 1 Copy-On-Write Trie"></a>TASK 1 Copy-On-Write Trie</h2><p>COW Trie在每次插入和删除时不会改变原有节点，而是对该节点的副本进行修改后，依次为其父节点创建修改后的副本，最后返回一个新的根节点。<br>此外，删除操作中，如果回溯路径上的某节点无值，且不存在子节点，还需要删除该节点</p>
<hr>
<p>插入(“ad”, 2),创建了一个新的Node2<br><img src="/../images/cmu15445-project0/2.png" alt="img"></p>
<hr>
<p>插入(“b”, 3)<br><img src="/../images/cmu15445-project0/1.png" alt="img"></p>
<hr>
<p>插入(“a”, “abc”) 删除(“ab”, 1)<br><br>注意删除操作后需要清除所有不需要的节点</p>
<p><img src="/../images/cmu15445-project0/3.png" alt="img"></p>
<p>Get函数实现</p>
<blockquote>
<p>从root节点遍历Tire树，<br>如果key不存在返回nullptr，<br>如果key存在，但是对应的Node无value或者value的类型不匹配，返回nullptr<br>其它情况，返回value</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the value associated with the given key.</span></span><br><span class="line"><span class="comment">// 1. If the key is not in the trie, return nullptr.</span></span><br><span class="line"><span class="comment">// 2. If the key is in the trie but the type is mismatched, return nullptr.</span></span><br><span class="line"><span class="comment">// 3. Otherwise, return the value.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Get</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> T * </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; <span class="title">ptr</span><span class="params">(root_)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> ch : key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr-&gt;children_.<span class="built_in">count</span>(ch) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = ptr-&gt;children_.<span class="built_in">at</span>(ch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!ptr-&gt;is_value_node_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> p = std::dynamic_pointer_cast&lt;<span class="type">const</span> TrieNodeWithValue&lt;T&gt;&gt;(ptr);</span><br><span class="line">  <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p-&gt;value_.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Put</span><span class="params">(std::string_view key, T value)</span> <span class="type">const</span> -&gt; Trie </span>&#123;</span><br><span class="line">  <span class="comment">// Note that `T` might be a non-copyable type. Always use `std::move` when creating `shared_ptr` on that value.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// You should walk through the trie and create new nodes if necessary. If the node corresponding to the key already</span></span><br><span class="line">  <span class="comment">// exists, you should create a new `TrieNodeWithValue`.</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; <span class="title">new_root</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">  std::map&lt;<span class="type">char</span>, std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;&gt; children;</span><br><span class="line">  <span class="keyword">if</span> (key.<span class="built_in">length</span>() == <span class="number">0</span>) &#123;<span class="comment">//key长度为0，表示在root节点put value</span></span><br><span class="line">    <span class="keyword">if</span> (root_) &#123;</span><br><span class="line">      children = root_-&gt;children_;</span><br><span class="line">    &#125;</span><br><span class="line">    new_root = std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;T&gt;&gt;(children, std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value)));<span class="comment">//创建一个新的root节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Trie</span>(new_root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;TrieNode&gt;&gt; stack;</span><br><span class="line">  <span class="keyword">if</span> (root_) &#123;</span><br><span class="line">    stack.<span class="built_in">push_back</span>(root_-&gt;<span class="built_in">Clone</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    stack.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;TrieNode&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">ptr</span><span class="params">(root_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int64_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(key.<span class="built_in">length</span>() - <span class="number">1</span>); ++i) &#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;TrieNode&gt; <span class="title">tmp_ptr</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (ptr &amp;&amp; ptr-&gt;children_.<span class="built_in">count</span>(key[i]) == <span class="number">1</span>) &#123;</span><br><span class="line">      ptr = ptr-&gt;children_.<span class="built_in">at</span>(key[i]);</span><br><span class="line">      tmp_ptr = ptr-&gt;<span class="built_in">Clone</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp_ptr = std::<span class="built_in">make_unique</span>&lt;TrieNode&gt;();</span><br><span class="line">      ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(tmp_ptr));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> value_ptr = std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">  <span class="keyword">if</span> (ptr &amp;&amp; ptr-&gt;children_.<span class="built_in">count</span>(key.<span class="built_in">back</span>())) &#123;</span><br><span class="line">    ptr = ptr-&gt;children_.<span class="built_in">at</span>(key.<span class="built_in">back</span>());</span><br><span class="line">    children = ptr-&gt;children_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> value_node = std::make_unique&lt;TrieNodeWithValue&lt;T&gt;&gt;(children, std::<span class="built_in">move</span>(value_ptr));</span><br><span class="line">  stack.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(value_node));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int64_t</span> i = key.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp_ptr = std::<span class="built_in">move</span>(stack.<span class="built_in">back</span>());</span><br><span class="line">    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">    stack.<span class="built_in">back</span>()-&gt;children_[key[i]] = std::<span class="built_in">move</span>(tmp_ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  new_root = std::<span class="built_in">move</span>(stack.<span class="built_in">back</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Trie</span>(new_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="TASK-2-Concurrent-Key-Value-Store"><a href="#TASK-2-Concurrent-Key-Value-Store" class="headerlink" title="TASK 2 Concurrent Key-Value Store"></a>TASK 2 Concurrent Key-Value Store</h2><blockquote>
<p>concurrent Key-Value store需要支持 <strong>多个读者和一个写者</strong> 工作的情况<br>也就是当一个写者在创建一个新的root的时候，读者可以在old root进行读操作<br>Tire_store.cpp文件<br></p>
</blockquote>
<p>读操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TrieStore::Get</span><span class="params">(std::string_view key)</span> -&gt; std::optional&lt;ValueGuard&lt;T&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Pseudo-code:</span></span><br><span class="line">  <span class="comment">// (1) Take the root lock, get the root, and release the root lock. Don&#x27;t lookup the value in the</span></span><br><span class="line">  <span class="comment">//     trie while holding the root lock.</span></span><br><span class="line">  <span class="comment">// (2) Lookup the value in the trie.</span></span><br><span class="line">  <span class="comment">// (3) If the value is found, return a ValueGuard object that holds a reference to the value and the</span></span><br><span class="line">  <span class="comment">//     root. Otherwise, return std::nullopt.</span></span><br><span class="line">  Trie root;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root = root_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> T *val = root.<span class="built_in">Get</span>&lt;T&gt;(key);</span><br><span class="line">  <span class="keyword">if</span> (!val) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ValueGuard</span>&lt;T&gt;(root, *val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Put</span><span class="params">(std::string_view key, T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span></span><br><span class="line">  <span class="comment">// The logic should be somehow similar to `TrieStore::Get`.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(write_lock_)</span></span>;</span><br><span class="line">  Trie root;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root = root_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Trie new_root = root.<span class="built_in">Put</span>&lt;T&gt;(key, std::<span class="built_in">move</span>(value));</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root_ = new_root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Remove</span><span class="params">(std::string_view key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span></span><br><span class="line">  <span class="comment">// The logic should be somehow similar to `TrieStore::Get`.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(write_lock_)</span></span>;</span><br><span class="line">  Trie root;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root = root_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Trie new_root = root.<span class="built_in">Remove</span>(key);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root_ = new_root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="TASK-3-Debugging"><a href="#TASK-3-Debugging" class="headerlink" title="TASK 3 Debugging"></a>TASK 3 Debugging</h2><p>skip…….</p>
<h2 id="TASK-4-SQL-String-Functions"><a href="#TASK-4-SQL-String-Functions" class="headerlink" title="TASK 4 SQL String Functions"></a>TASK 4 SQL String Functions</h2><p>实现Upper方法和Lower方法<br>src&#x2F;include&#x2F;execution&#x2F;string_expression.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Compute</span><span class="params">(<span class="type">const</span> std::string &amp;val)</span> <span class="type">const</span> -&gt; std::string </span>&#123;</span><br><span class="line">    <span class="comment">// TODO(student): implement upper / lower.</span></span><br><span class="line">    std::string res;</span><br><span class="line">    res.<span class="built_in">resize</span>(val.<span class="built_in">length</span>());</span><br><span class="line">    <span class="keyword">switch</span> (expr_type_) &#123;</span><br><span class="line">      <span class="keyword">case</span> StringExpressionType::Lower:</span><br><span class="line">        std::<span class="built_in">transform</span>(val.<span class="built_in">begin</span>(), val.<span class="built_in">end</span>(), res.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> StringExpressionType::Upper:</span><br><span class="line">        std::<span class="built_in">transform</span>(val.<span class="built_in">begin</span>(), val.<span class="built_in">end</span>(), res.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:<br><br><img src="/../images/cmu15445-project0/4.png" alt="img"></p>
<p>测试通过截图：<br><br><img src="/../images/cmu15445-project0/5.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2023/12/28/DILI-A-Distribution-Driven-Learned-Index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/28/DILI-A-Distribution-Driven-Learned-Index/" class="post-title-link" itemprop="url">DILI-A-Distribution-Driven-Learned-Index</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-28 07:07:45" itemprop="dateCreated datePublished" datetime="2023-12-28T07:07:45-08:00">2023-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-25 23:45:34" itemprop="dateModified" datetime="2024-02-25T23:45:34-08:00">2024-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learned-Index/" itemprop="url" rel="index"><span itemprop="name">Learned Index</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>需要有一批数据用于批量加载构建初始数据，不支持从0开始构建（一个key一个key插入），支持读写操作。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一棵树中查找一个key，包含两部分；找到包含key的leaf node，leaf node的local search<br>查找性能取决于leaf node的深度和线性回归模型的accuracy</p>
<h2 id="方法和结果"><a href="#方法和结果" class="headerlink" title="方法和结果"></a>方法和结果</h2><p>提出一种two-phase bulk loading算法，先构建一棵BU（bottom-up）-Tree，它的node布局由greedy merging 算法（考虑了leaf node的深度和线性回归模型的accuracy）决定，接着根据BU-Tree的node布局构建DILI.<br>BU-Tree中internal node的range并不是被它的child平分<br>DILI与LIPP相比，每个leaf node的keys分布更接近线性，发生冲突的概率更低<br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/1.png" alt="img"></p>
<p>Search without Optimization<br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/2.png" alt="img"></p>
<p>Building BU-Tree<br>难点：确定nh的大小和nh - 1个breakpoints<br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/3.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/4.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/5.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/6.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/7.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/8.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/9.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/10.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/11.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/12.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/13.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2023/12/07/cmake-generator-error-under-windows-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/07/cmake-generator-error-under-windows-system/" class="post-title-link" itemprop="url">cmake-generator-error-under-windows-system</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-07 00:22:51" itemprop="dateCreated datePublished" datetime="2023-12-07T00:22:51-08:00">2023-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-25 23:45:34" itemprop="dateModified" datetime="2024-02-25T23:45:34-08:00">2024-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmake/" itemprop="url" rel="index"><span itemprop="name">cmake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.安装windows版本cmake（配置环境变量）<br>2.安装windows版本mingw（配置环境变量）<br>3.创建工程目录<br>执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -G &quot;MinGW Makefiles&quot; -D &quot;CMAKE_MAKE_PROGRAM:PATH=your path to make.exe&quot;</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dcrmg/article/details/103918543">https://blog.csdn.net/dcrmg/article/details/103918543</a><br><a target="_blank" rel="noopener" href="https://codeantenna.com/a/ELzh11ElWs">https://codeantenna.com/a/ELzh11ElWs</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2023/12/05/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/05/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/" class="post-title-link" itemprop="url">SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-05 22:02:09" itemprop="dateCreated datePublished" datetime="2023-12-05T22:02:09-08:00">2023-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-25 23:45:34" itemprop="dateModified" datetime="2024-02-25T23:45:34-08:00">2024-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learned-Index/" itemprop="url" rel="index"><span itemprop="name">Learned Index</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>SALI: A Scalable Adaptive Learned Index Framework based on<br>Probability Models<br>一个基于概率模型的可进化学习索引框架</p>
<h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>LI：只读<br>可写：<br>1.基于缓冲区的策略（插入时放入缓冲区，到达一个阈值后进行合并操作）<br>XIndex、FINEdex<br>2.基于模型的策略（就地插入）<br>ALEX（在插入冲突中，映射的slot已经被占用，通过移动来尝试重新组织节点）、<br>LIPP（利用链接方案，为相应的时隙创建一个新节点，将最后一英里问题转化为子树遍历问题）</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/1.png" alt="img"><br>上述的索引结构都不能以高并发性进行扩展</p>
<p>并发数较少的时候，与基于模型的策略（ALEX+、LIPP+）相比，基于缓冲区策略（XIndex、FINEdex）的索引表现出较差的基本性能和较差的扩展性；并且随着并发数的提高，“最后一英里问题”搜索会迅速饱和内存带宽，从而成为系统的瓶颈（ALEX+必须为此操作获取粗粒度写锁，线程数量增加时，越来越多的线程被阻塞）</p>
<p>LIPP+没有最后一英里问题，但是它需要在每个节点中维护统计信息，如访问计数和冲突计数（以触发节点再训练，防止性能下降）。这些节点计数器在线程之间造成高争用。</p>
<h2 id="难点与分析过程"><a href="#难点与分析过程" class="headerlink" title="难点与分析过程"></a>难点与分析过程</h2><p>我们需要设计一个满足如下要求的可扩展学习索引<br>1.Efficient Concurrency高效并发：<br>为了实现高效的插入性能，索引必须跟踪统计信息，这些信息反映了由于新的插入而导致的索引结构随时间的退化（这些信息对于触发节点再训练至关重要），但是节点计数器在线程之间会造成高争用，需要一种轻量级方法<br>2.Adaptive ability适应能力<br>与均匀工作负载相比，学习索引在倾斜插入工作负载下表现出次优性能。因此，学习索引需要有自适应能力以保证其在并发场景的鲁棒性。此外，学习的索引缺乏用于查找操作的优化策略。在偏斜的工作负载下，学习索引尚未充分利用显著降低索引空间成本的机会。</p>
<p>3.Low overheads of basic performance基本性能的低开销<br>(1)Efficient lookup<br>实现高查找性能，通常取决于最大限度地减少查找的预测错误<br>(2)Efficient insert<br>采用基于模型的策略，而不是基于缓冲区的策略，通过在每个节点中保留间隙，可以显著提高学习索引的插入性能</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>提出SALI<br>1.利用LIPP+结构（使用细粒度锁）<br>2.除了模型重训练以外定义一组节点进化策略，以允许学习到的索引自适应于不同的工作负载倾斜（建议对具有不同读写热度的节点应用不同的进化策略）<br>3.用轻量级概率模型取代了现有学习索引中的每个节点的统计信息，以消除统计信息维护的可扩展性瓶颈</p>
<p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/2.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/3.png" alt="img"></p>
<p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/4.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/5.png" alt="img"></p>
<p>进化策略：<br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/6.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/7.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/8.png" alt="img"></p>
<p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/9.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/10.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/11.png" alt="img"></p>
<p>概率模型：<br>为了确保最佳性能，学习索引必须监控退化统计信息，以便在必要时启动调整；另外，进化策略需要额外的统计信息。<br>基本概念：模拟信息积累时利用概率</p>
<p>例子：<br>1.当模拟指定时间段内插入key的累积数量时，我们设计一个基于插入率和插入时间的概率模型<br>2.几何分布可以用来模拟信息的累计（插入冲突等）</p>
<p>触发insert evolution的条件</p>
<p>Condition1：评估一个节点及其子树中新key插入的频率<br>该节点容纳足够数量的新插入的key<br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/12.png" alt="img"></p>
<p>n.current_num:是指在当前插入操作结束时节点中包含的key的数量<br>n.build_num:是指上一次执行完进化策略后节点中的key的数量<br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/13.png" alt="img"></p>
<p>Condition2：节点内冲突的升级（判断节点是否恶化）<br>Node必须由足够的新插入的key<br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/14.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/15.png" alt="img"></p>
<p><strong>先计算Pconflict是否被触发，如果触发，再判断Pacc是否被触发，如果两个条件都被触发，执行进化策略</strong></p>
<p>触发lookup evolution的条件<br>Phl<br>还需要考虑以下两个条件<br>Condition1:<br>再很长的一段时间内，节点上的查找操作没有触发进化策略</p>
<p>Condition2:<br>节点累计数据的速率并不慢</p>
<p>For condition1：如果一个节点的最后一次进化操作是由hot lookup触发的，这意味着自那以后没有插入操作触发该节点进化，即该节点没有严重恶化，并且新插入key的数量可能很少，可以将Phl调整到一个更小的值</p>
<p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/16.png" alt="img"></p>
<p>For condition2：引入Pacc，如果自上次进化操作以来插入了大量新的key，则表明可能需要进行新一轮的进化操作</p>
<p>每个线程维护一个skip_counter，每次查找操作，skip_counter加1，10次查找操作后，执行一次伯努利实验来判断Phl是否被触发。如果Phl被触发，判断Pacc是否也被触发，如果触发，执行进化策略。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2023/12/05/NFL-Robust-Learned-Index-via-Distribution-Transformation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/05/NFL-Robust-Learned-Index-via-Distribution-Transformation/" class="post-title-link" itemprop="url">NFL-Robust-Learned-Index-via-Distribution-Transformation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-05 21:37:11" itemprop="dateCreated datePublished" datetime="2023-12-05T21:37:11-08:00">2023-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-25 23:45:34" itemprop="dateModified" datetime="2024-02-25T23:45:34-08:00">2024-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learned-Index/" itemprop="url" rel="index"><span itemprop="name">Learned Index</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>只读负载</li>
<li>读写负载，但是数据分布变化不大（即CDF随着key的插入删除变化较小）</li>
</ul>
<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>之前的学习索引通过设计更好的启发式方法来划分key空间，使得每一份被分割的sub key空间可以更好地被线性模型拟合。<br>缺点：</p>
<ul>
<li>为了达到这个目的，学习索引必须构建更深的层次结构，从而产生更多的遍历时间和预测数量<br>（类似于用一个分段线性函数去拟合数据分布CDF）。</li>
</ul>
<h2 id="难点和分析过程："><a href="#难点和分析过程：" class="headerlink" title="难点和分析过程："></a>难点和分析过程：</h2><p>本文提出了学习索引NFL（包括两个结构Normalizing Flow 和 Learned Index ）</p>
<p><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/1.jpg" alt="img"><br>思想： 先用分布转换模型将复杂key分布转换为近似均匀的分布，然后利用转换的key构建学习索引</p>
<p><strong>难点</strong></p>
<p>（1）Efficacy of Normalizing flow:</p>
<ul>
<li>由于key的数字数据特征有限，分布转换模型表现不佳</li>
<li>均匀分布很难作为训练目标（我们设计了一个具有丰富特征空间的分布转换模型和一个易于操作的训练目标）</li>
</ul>
<p>（2）Efficiency of normalizing flow</p>
<ul>
<li>分布转化必须是高效的在线步骤，这样就限制了NF的复杂性。但是直接减少参数数量标准化流程可能会降低转换质量（这样会导致学习索引需要更深的层次结构和更多的模型来近似CDF），（我们设计了一套效率优化方案，并且保证NF的功效）</li>
</ul>
<p>（3）Lack of proper indexes for transformed keys：</p>
<ul>
<li>numerica NF的转换使线性模型拟合地更好，学习索引应该以新的视角重新思考。（我们提出了After-Flow Learned Index（AFLI），充分利用转换后的key）</li>
</ul>
<p><strong>方法</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/1.jpg" alt="img"><br>以下两个是评价模型转换质量的指标<br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/2.jpg" alt="img"></p>
<p>Tail conflict degree：</p>
<p>Numerical Normalizing Flow:<br>Feature Space Expansion:现有的NF大多用在cv和nlp领域，用于处理高纬的图片和文本，这些数据都有丰富的特征。然而keys都是数值数据，含有的特征较少。<br>使用Algorithm 3.1分布转换算法（对keys的数值特征进行扩展）<br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/3.jpg" alt="img"></p>
<p>特征扩展的时间复杂度为O（n x d）</p>
<p><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/4.png" alt="img"></p>
<p>Structure of AFLI：<br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/5.jpg" alt="img"></p>
<p><strong>Model node:</strong><br>Empty Slot：unused slot<br>Data Slot：key payload<br>Bucket Pointer: 指向一个bucket<br>Node Pointer：指向一个model node或者dense node<br><strong>Bucket:</strong><br>a short data array.它的size由tail conflict degree决定，但将保持在预设阈值范围内。我们提供两种桶，线性桶（默认）和有序桶</p>
<p><strong>Dense node：</strong><br>Also a data array，比bucket大一点，但是比Model node小很多，是一个ordered and gapped array, gap的最大值由tail conflict degree</p>
<p><strong>Analysis:</strong><br>当索引无法建立模型节点时，因为节点中的所有键都太近（即拟合线性模型的斜率为0），索引会分配一个dense array</p>
<p><strong>Queries:</strong><br>（1）从root node开始查找，如果是model node，先用linear model预测position，判断它的类型，如果是empty slot，表示不存在；如果是data slot，比较是否是相同的key；如果是bucket pointer，在bucket中查找；如果是node pointer，递归操作<br>（2）如果node是dense node，使用二分查找查找这个结果。</p>
<p><strong>Insertions:</strong><br>（1）如果key-payload pair被插入model node，先用linear model预测position</p>
<ul>
<li>如果是empty slot，直接存储key-payload</li>
<li>如果是data slot，表明发生冲突，创建一个bucket来存储这两个key</li>
<li>如果是bucket pointer或者node pointer，插入key-payload到bucket或者child node中<br>（2）插入到bucket中时，将key-payload会直接被加到sorted data的末尾；如果bucket是一个ordered mode，将会执行一次插入排序。<br>（3）插入到dense node中时，先在array上执行二分查找，如果那个position是一个empty slot，我们会直接插入key-payload pair；，否则会移动到最近的empty slot再插入。</li>
</ul>
<p>如果bucket或者dense node没有empty slots，我们尽量通过一个modeling operation将它转换为model node<br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/6.jpg" alt="img"></p>
<p><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/7.jpg" alt="img"><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/8.jpg" alt="img"></p>
<p>我们首先一个使用线性回归创建线性模型（Line 1）<br>如果slope 为0（所有key被映射到一个相同的position），我们为创建一个dense node（Line 2 - 4）<br>否则如果我们成功创建一个linear model，就计算model node所有位置的conflict degree（Line 6）<br>然后我们遍历所有预测的位置，决定每个pos的entry type。如果conflict degree为1，我们直接在data slot存储该key；如果conflict degree大于1但是比bucket的tail confict degree小，存储在一个bucket中（Line 14 - 17）；<br>否则，如果某个position的confict degree比bucket的tail conflict degree大，找到下一个conflict degree也大于tail conflict degree的position或者到末尾，并将经过的position的key都收集起来，并分配一个新的节点来处理它们（第18 - 21行）<br>BulkLoad：首先计算tail conflict degree. The returned result is the root node.<br>Update: lookup + in-place update<br>Delete</p>
<h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><p><strong>数据集：</strong><br>选取了7个不同的数据集进行评估<br>（Key的类型为double     payload的类型是int64）</p>
<p>对每种类型的数据集构建了四种类型的工作负载</p>
<p>每种工作负载包括 批量加载和运行阶段<br>我们使用批量加载操作来加载数据集的50%的key；在运行阶段，根据不同的操作比率生成请求</p>
<ul>
<li>只读</li>
<li>读80% 写20%</li>
<li>写 20% 读80%</li>
<li>只写</li>
</ul>
<p>将NFL与LIPP、ALEX、PGM-index、B-Tree、an efficient B-Tree对比</p>
<p><strong>平均吞吐量</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/9.jpg" alt="img"></p>
<ul>
<li>只读：NFL与LIPP、ALEX、PGM、B-Tree相比，平均吞吐量分别提高了2.34倍、2.46倍、3.82倍、7.45倍；对于具有大冲突程度的工作负载（即LLT和FB），可以分别实现比LIPP、ALEX高2.41x和3.70x的吞吐量。</li>
<li>重读：与LIPP、ALEX、PGM、B-Tree相比，NFL在吞吐量上分别提高72.22%、101.05%、611.48%、389.45%</li>
<li>重写：与LIPP、ALEX、PGM、B-Tree相比，NFL在吞吐量上分别提高29.10%、39.28%、50.88%、162.92%</li>
<li>只写：与LIPP、ALEX、B-Tree相比，NFL在吞吐量上分别提高22.65%、28.30%和131.58%</li>
</ul>
<p><strong>延迟</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/10.jpg" alt="img"></p>
<ul>
<li>只读：与LIPP、ALEX、PGM index、B-Tree相比，NFL可以将延迟分别降低58.68%、32.89%、62.73%和80.77%</li>
<li>读写：与LIPP、ALEX、PGM index和B-Tree相比，NFL可以将延迟分别降低26.64%、45.05%、59.49%、65.31%</li>
<li>只写：与LIPP、ALEX、B-Tree相比，NFL可以将延迟减少2.26%、27.92%、50.48%</li>
</ul>
<p><strong>批量加载时间</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/11.jpg" alt="img"></p>
<p>与LIPP、ALEX、B-Tree相比，NFL需要2.25倍、0.86倍、2.81倍的大容量加载时间，其中77%的时间是用来转换key的</p>
<p><strong>索引大小：</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/12.jpg" alt="img"><br>NFL的指数大小分别是ALEX和PGM的2.26倍和3.1倍；然而，NFL的大小仅为LIPP大小的0.51</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2023/10/10/Updatable-Learned-Index-with-Precise-Positions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/10/Updatable-Learned-Index-with-Precise-Positions/" class="post-title-link" itemprop="url">Updatable-Learned-Index-with-Precise-Positions</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-10 04:13:07" itemprop="dateCreated datePublished" datetime="2023-10-10T04:13:07-07:00">2023-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-25 23:45:34" itemprop="dateModified" datetime="2024-02-25T23:45:34-08:00">2024-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learned-Index/" itemprop="url" rel="index"><span itemprop="name">Learned Index</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>读写负载</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Learned Index：只能在只读数据集上查找，无法处理索引结构中必不可少的更新操作<br>ALEX和PGM：它们对更新的支持是以查找操作的额外搜索为代价的；并且这些索引的更新操作也会导致大量元素的移动</p>
<p>需要一种索引可以解决“最后一英里问题”</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>每个Node包含一个model、一个entries array、一个bit数组，<br>每个bit表示array中一个entry的类型，<br>类型有<br>NULL（空entry），<br>DATA(entry包含一个键值对，如果键值对太大，保存一个指向payload的指针)，<br>NODE（该entry指向下一层中的一个子节点，将一个新元素插入DATA entry时，创建一个子节点保存这两个entry，该entry指向这个新的节点）</p>
<p>三种类型的entry的大小都为16byte，其中DATA类型的entry由8byte的key和8byte的payload组成<br>对于第i个entry，bit数组的第2<em>i位表示该entry是不是NULL,第2</em>i + 1位表示entry的type</p>
<p>LIPP不区分leaf node和internal node<br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/1.jpg" alt="img"><br>各种操作的算法：<br>FMCD算法：</p>
<blockquote>
<p>给定一组key和数组长度L，计算最小的冲突度T及相应的linear model</p>
</blockquote>
<p><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/2.jpg" alt="img"><br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/3.jpg" alt="img"><br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/4.jpg" alt="img"><br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/5.jpg" alt="img"><br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/6.jpg" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="jingtao8a"
      src="/images/iverson.jpg">
  <p class="site-author-name" itemprop="name">jingtao8a</p>
  <div class="site-description" itemprop="description">this is life, full of ups and down</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jingtao8a</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
