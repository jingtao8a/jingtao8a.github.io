<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jingtao8a.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Query Processing ModelOLAP与OLTP数据库  OLAP数据库架构将数据读取优先于数据写入操作。可以快速地对大量数据执行复杂的查询 OLTP数据库架构将数据写入优先于数据读取操作。它针对写入密集型工作负载进行了优化  example:以一家大型零售公司为例。该公司有一个庞大的数据库，用于跟踪销售、库存、客户数据等  使用OLTP数据库实时处理交易、更新库存水平和管理客户账户">
<meta property="og:type" content="article">
<meta property="og:title" content="cmu15445-project3">
<meta property="og:url" content="http://jingtao8a.github.io/2024/02/27/cmu15445-project3/index.html">
<meta property="og:site_name" content="jingtao8a&#39;s blog">
<meta property="og:description" content="Query Processing ModelOLAP与OLTP数据库  OLAP数据库架构将数据读取优先于数据写入操作。可以快速地对大量数据执行复杂的查询 OLTP数据库架构将数据写入优先于数据读取操作。它针对写入密集型工作负载进行了优化  example:以一家大型零售公司为例。该公司有一个庞大的数据库，用于跟踪销售、库存、客户数据等  使用OLTP数据库实时处理交易、更新库存水平和管理客户账户">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/1.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/2.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/3.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/4.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/5.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/6.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/10.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/11.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/12.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/13.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/14.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/15.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/7.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/8.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/16.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/17.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/18.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/19.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/20.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/21.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/9.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/22.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/23.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/24.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/25.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/26.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/27.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/28.png">
<meta property="og:image" content="http://jingtao8a.github.io/images/cmu15445-project3/29.png">
<meta property="article:published_time" content="2024-02-28T03:38:43.000Z">
<meta property="article:modified_time" content="2024-02-29T12:03:10.801Z">
<meta property="article:author" content="jingtao8a">
<meta property="article:tag" content="cmu15445—2023">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jingtao8a.github.io/images/cmu15445-project3/1.png">

<link rel="canonical" href="http://jingtao8a.github.io/2024/02/27/cmu15445-project3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>cmu15445-project3 | jingtao8a's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">jingtao8a's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2024/02/27/cmu15445-project3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          cmu15445-project3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-27 19:38:43" itemprop="dateCreated datePublished" datetime="2024-02-27T19:38:43-08:00">2024-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-29 04:03:10" itemprop="dateModified" datetime="2024-02-29T04:03:10-08:00">2024-02-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15445-2023/" itemprop="url" rel="index"><span itemprop="name">cmu15445-2023</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Query-Processing-Model"><a href="#Query-Processing-Model" class="headerlink" title="Query Processing Model"></a>Query Processing Model</h2><p>OLAP与OLTP数据库</p>
<ul>
<li>OLAP数据库架构将数据读取优先于数据写入操作。可以快速地对大量数据执行复杂的查询</li>
<li>OLTP数据库架构将数据写入优先于数据读取操作。它针对写入密集型工作负载进行了优化</li>
</ul>
<p>example:<br><br>以一家大型零售公司为例。该公司有一个庞大的数据库，用于跟踪销售、库存、客户数据等</p>
<ul>
<li>使用OLTP数据库实时处理交易、更新库存水平和管理客户账户</li>
<li>使用OLAP数据库来分析有关销售趋势、库存水平、客户人口统计等</li>
</ul>
<hr>
<p>DBMS的Processing Model定义了系统如何执行一个query plan,目前主要有三种模型</p>
<ul>
<li>Iterator Model</li>
<li>Materialization Model</li>
<li>Vectorized&#x2F;Batch Model</li>
</ul>
<h3 id="Iterator-Model"><a href="#Iterator-Model" class="headerlink" title="Iterator Model"></a>Iterator Model</h3><p>query plan 中的每步 operator 都实现一个 next 函数，每次调用时，operator 返回一个 tuple 或者 null，后者表示数据已经遍历完毕。operator 本身实现一个循环，每次调用其 child operators 的 next 函数，从它们那边获取下一条数据供自己操作，这样整个 query plan 就被从上至下地串联起来，它也称为 Volcano&#x2F;Pipeline Model：<br><img src="/../images/cmu15445-project3/1.png" alt="img"><br>Iterator 几乎被用在每个 DBMS 中，包括 sqlite、MySQL、PostgreSQL 等等，其它需要注意的是:</p>
<ul>
<li>有些 operators 会等待 children 返回所有 tuples 后才执行，如 Joins, Subqueries 和 Order By</li>
<li>Output Control 在 Iterator Model 中比较容易，如 Limit，只按需调用 next 即可</li>
</ul>
<h3 id="Materialization-Model"><a href="#Materialization-Model" class="headerlink" title="Materialization Model"></a>Materialization Model</h3><p>每个 operator 处理完所有输入后，将所有结果一次性输出，DBMS 会将一些参数传递到 operator 中防止处理过多的数据，这是一种从下至上的思路，示意如下：<br><img src="/../images/cmu15445-project3/2.png" alt="img"><br>materialization model：</p>
<ul>
<li>更适合 OLTP 场景，因为后者通常指需要处理少量的 tuples，这样能减少不必要的执行、调度成本</li>
<li>不太适合会产生大量中间结果的 OLAP 查询</li>
</ul>
<h3 id="Vectorization-Model"><a href="#Vectorization-Model" class="headerlink" title="Vectorization Model"></a>Vectorization Model</h3><p>Vectorization Model 是 Iterator 与 Materialization Model 折衷的一种模型：</p>
<ul>
<li>每个 operator 实现一个 next 函数，但每次 next 调用返回一批 tuples，而不是单个 tuple</li>
<li>operator 内部的循环每次也是一批一批 tuples 地处理</li>
<li>batch 的大小可以根据需要改变（hardware、query properties)<br><br><img src="/../images/cmu15445-project3/3.png" alt="img"></li>
</ul>
<p>vectorization model 是 OLAP 查询的理想模型:</p>
<ul>
<li>极大地减少每个 operator 的调用次数</li>
<li>允许 operators 使用 vectorized instructions (SIMD) 来批量处理 tuples</li>
</ul>
<h2 id="BACKGROUND：QUERY-PROCESSING"><a href="#BACKGROUND：QUERY-PROCESSING" class="headerlink" title="BACKGROUND：QUERY PROCESSING"></a>BACKGROUND：QUERY PROCESSING</h2><p>BusTub架构如下<br><img src="/../images/cmu15445-project3/4.png" alt="img"></p>
<h3 id="note"><a href="#note" class="headerlink" title="note:"></a>note:</h3><ul>
<li>BusTub只支持SQL的一个小子集，可以通过tests&#x2F;sql中的SQLLogicTest文件来查看它所支持的SQL语句</li>
<li>如果你使用Clion来运行Bustub shell，添加–disable-tty参数</li>
<li>SQL语句使用;结尾</li>
<li>BusTub只支持INT和VARCHAR(n)类型，字符串使用单引号</li>
<li>Bustub使用Iterator Porcessing Model</li>
</ul>
<h3 id="Inspecting-SQL-query-plans"><a href="#Inspecting-SQL-query-plans" class="headerlink" title="Inspecting SQL query plans"></a>Inspecting SQL query plans</h3><p>BusTub支持EXPLAIN来打印SQL查询计划<br><img src="/../images/cmu15445-project3/5.png" alt="img"><br>EXPLAIN会展示query processing这一层的转换过程 Parser -&gt; Binder -&gt; Planner -&gt; Optimizer<br><br>Parser解析SQL语句生成Binder AST语法树，接着生成query plan，然后由Optimizer优化query plan生成executor树</p>
<h2 id="Task-1-Access-Method-Executors"><a href="#Task-1-Access-Method-Executors" class="headerlink" title="Task#1 Access Method Executors"></a>Task#1 Access Method Executors</h2><p>我们并不需要关心query plan是如何创建的；但有必要理解query plan的组成结构:这是棵树，每个plan节点都对应具体的算子，Bustub采用iterator procesing model，也就是Top-to-Bottom的火山模型，因此query plan的执行就是从根节点开始，将plan节点转换为对应的算子</p>
<p>Plan节点的类型如下<br><img src="/../images/cmu15445-project3/6.png" alt="img"><br>还是有必要阅读一些相关代码<br></p>
<p>表Table的元信息</p>
<blockquote>
<p>其中TableHeap代表磁盘上的一张表，是一个doubly-linked of pages</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TableInfo</span> &#123;</span><br><span class="line">  <span class="comment">/** The table schema */</span></span><br><span class="line">  Schema schema_;</span><br><span class="line">  <span class="comment">/** The table name */</span></span><br><span class="line">  <span class="type">const</span> std::string name_;</span><br><span class="line">  <span class="comment">/** An owning pointer to the table heap */</span></span><br><span class="line">  std::unique_ptr&lt;TableHeap&gt; table_;</span><br><span class="line">  <span class="comment">/** The table OID */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">table_oid_t</span> oid_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TableHeap</span> &#123;</span><br><span class="line">  <span class="type">page_id_t</span> first_page_id_&#123;INVALID_PAGE_ID&#125;;</span><br><span class="line">  <span class="type">page_id_t</span> last_page_id_&#123;INVALID_PAGE_ID&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>索引Index的元信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexInfo</span> &#123;</span><br><span class="line">  <span class="comment">/** The schema for the index key */</span></span><br><span class="line">  Schema key_schema_;</span><br><span class="line">  <span class="comment">/** The name of the index */</span></span><br><span class="line">  std::string name_;</span><br><span class="line">  <span class="comment">/** An owning pointer to the index */</span></span><br><span class="line">  std::unique_ptr&lt;Index&gt; index_;</span><br><span class="line">  <span class="comment">/** The unique OID for the index */</span></span><br><span class="line">  <span class="type">index_oid_t</span> index_oid_;</span><br><span class="line">  <span class="comment">/** The name of the table on which the index is created */</span></span><br><span class="line">  std::string table_name_;</span><br><span class="line">  <span class="comment">/** The size of the index key, in bytes */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> key_size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>catalog<br></p>
<blockquote>
<p>记录所有TableInfo和IndexInfo</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Catalog</span> &#123;</span><br><span class="line">  std::unordered_map&lt;<span class="type">table_oid_t</span>, std::unique_ptr&lt;TableInfo&gt;&gt; tables_;</span><br><span class="line">  <span class="comment">/** Map table name -&gt; table identifiers. */</span></span><br><span class="line">  std::unordered_map&lt;std::string, <span class="type">table_oid_t</span>&gt; table_names_;</span><br><span class="line">  </span><br><span class="line">  std::unordered_map&lt;<span class="type">index_oid_t</span>, std::unique_ptr&lt;IndexInfo&gt;&gt; indexes_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Map table name -&gt; index names -&gt; index identifiers. */</span></span><br><span class="line">  std::unordered_map&lt;std::string, std::unordered_map&lt;std::string, <span class="type">index_oid_t</span>&gt;&gt; index_names_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="SeqScanExecutor实现"><a href="#SeqScanExecutor实现" class="headerlink" title="SeqScanExecutor实现"></a>SeqScanExecutor实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqScanExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> SeqScanPlanNode *plan_;<span class="comment">//对应的SeqScanPlanNode</span></span><br><span class="line">  TableInfo *table_info_;<span class="comment">//扫描的table</span></span><br><span class="line">  std::unique_ptr&lt;TableIterator&gt; iterator_;<span class="comment">//TableIterator</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SeqScanExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = catalog-&gt;<span class="built_in">GetTable</span>(plan_-&gt;table_oid_);<span class="comment">//获取TableInfo</span></span><br><span class="line">  iterator_ = std::<span class="built_in">make_unique</span>&lt;TableIterator&gt;(table_info_-&gt;table_-&gt;<span class="built_in">MakeIterator</span>());<span class="comment">//获取对应Table的TableIterator</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SeqScanExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  std::pair&lt;TupleMeta, Tuple&gt; pair;</span><br><span class="line">  <span class="keyword">while</span> (!iterator_-&gt;<span class="built_in">IsEnd</span>()) &#123;<span class="comment">//如果未遍历完Table</span></span><br><span class="line">    pair = iterator_-&gt;<span class="built_in">GetTuple</span>();<span class="comment">//获取一个TupleMeta-Tuple pair</span></span><br><span class="line">    <span class="keyword">if</span> (pair.first.is_deleted_) &#123;<span class="comment">//如果该TupleMeta标记Tuple为已删除</span></span><br><span class="line">      ++(*iterator_);<span class="comment">//跳过</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (plan_-&gt;filter_predicate_) &#123;<span class="comment">//如果该算子对应的SeqScanPlanNode含有filter_predicate表达式</span></span><br><span class="line">      <span class="keyword">auto</span> res = plan_-&gt;filter_predicate_-&gt;<span class="built_in">Evaluate</span>(&amp;pair.second, table_info_-&gt;schema_);</span><br><span class="line">      <span class="keyword">if</span> (!(!res.<span class="built_in">IsNull</span>() &amp;&amp; res.<span class="built_in">GetAs</span>&lt;<span class="type">bool</span>&gt;())) &#123;<span class="comment">//如果该Tuple不满足该filter_predicate表达式</span></span><br><span class="line">        ++(*iterator_);<span class="comment">//跳过</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++(*iterator_);<span class="comment">//迭代器前进一步</span></span><br><span class="line">    *tuple = std::<span class="built_in">move</span>(pair.second);</span><br><span class="line">    *rid = tuple-&gt;<span class="built_in">GetRid</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InsertExecutor实现"><a href="#InsertExecutor实现" class="headerlink" title="InsertExecutor实现"></a>InsertExecutor实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InsertExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> InsertPlanNode *plan_;<span class="comment">//对应的InsertPlanNode</span></span><br><span class="line">  <span class="type">bool</span> successful_;<span class="comment">//是否插入成功</span></span><br><span class="line">  TableInfo *table_info_;<span class="comment">//插入的Table</span></span><br><span class="line">  std::vector&lt;IndexInfo *&gt; index_infos_;<span class="comment">//该Table对应的Index，如果Table变更，索引也需更改</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;<span class="comment">//一个孩子executor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  <span class="keyword">auto</span> cata_log = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = cata_log-&gt;<span class="built_in">GetTable</span>(plan_-&gt;table_oid_);</span><br><span class="line">  index_infos_ = cata_log-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">  successful_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">InsertExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  TupleMeta meta;</span><br><span class="line">  <span class="keyword">if</span> (successful_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  meta.insert_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  meta.delete_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  meta.is_deleted_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;<span class="comment">//从孩子executor获取tuple</span></span><br><span class="line">    <span class="keyword">auto</span> tuple_rid = table_info_-&gt;table_-&gt;<span class="built_in">InsertTuple</span>(meta, *tuple, exec_ctx_-&gt;<span class="built_in">GetLockManager</span>(), exec_ctx_-&gt;<span class="built_in">GetTransaction</span>(), table_info_-&gt;oid_);<span class="comment">//插入Table</span></span><br><span class="line">    <span class="keyword">if</span> (tuple_rid == std::<span class="literal">nullopt</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新该Table的所有索引结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;</span><br><span class="line">      <span class="keyword">auto</span> key = tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(key, *tuple_rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ++count;<span class="comment">//插入记录count++</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">emplace_back</span>(TypeId::INTEGER, count);</span><br><span class="line">  *tuple = <span class="built_in">Tuple</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());<span class="comment">//入参tuple返回插入的记录的数量</span></span><br><span class="line">  successful_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UpdateExecutor实现"><a href="#UpdateExecutor实现" class="headerlink" title="UpdateExecutor实现"></a>UpdateExecutor实现</h3><blockquote>
<p>这里实现的思路就是将旧的Tuple删除，插入新的Tuple</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpdateExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> UpdatePlanNode *plan_;<span class="comment">//对应的UpdatePlanNode</span></span><br><span class="line">  <span class="comment">/** Metadata identifying the table that should be updated */</span></span><br><span class="line">  <span class="type">const</span> TableInfo *table_info_;<span class="comment">//要update的table</span></span><br><span class="line">  <span class="comment">/** The child executor to obtain value from */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;<span class="comment">//孩子executor</span></span><br><span class="line"></span><br><span class="line">  std::vector&lt;IndexInfo *&gt; index_infos_;<span class="comment">//该Table上的所有index</span></span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> successful_;<span class="comment">//更新是否成功</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  successful_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> cata_log = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = cata_log-&gt;<span class="built_in">GetTable</span>(plan_-&gt;<span class="built_in">TableOid</span>());</span><br><span class="line">  index_infos_ = cata_log-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">UpdateExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  TupleMeta tuple_meta;</span><br><span class="line">  <span class="keyword">if</span> (successful_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tuple_meta.delete_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  tuple_meta.insert_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  <span class="keyword">auto</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;<span class="comment">//从孩子executor拿到需要更新的tuple</span></span><br><span class="line">    <span class="comment">// 删除tuple</span></span><br><span class="line">    tuple_meta.is_deleted_ = <span class="literal">true</span>;</span><br><span class="line">    table_info_-&gt;table_-&gt;<span class="built_in">UpdateTupleMeta</span>(tuple_meta, *rid);<span class="comment">//将Table中相同rid的Tuple标记为删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;<span class="comment">//将Table对应的Index中与该Tuple对应的key删除</span></span><br><span class="line">      <span class="keyword">auto</span> key = tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">DeleteEntry</span>(key, *rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的tuple</span></span><br><span class="line">    std::vector&lt;Value&gt; values;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;expresssion : plan_-&gt;target_expressions_) &#123;</span><br><span class="line">      values.<span class="built_in">emplace_back</span>(expresssion-&gt;<span class="built_in">Evaluate</span>(tuple, child_executor_-&gt;<span class="built_in">GetOutputSchema</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> new_tuple = <span class="built_in">Tuple</span>(values, &amp;child_executor_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    <span class="comment">// 插入新的tuple</span></span><br><span class="line">    tuple_meta.is_deleted_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> tuple_rid = table_info_-&gt;table_-&gt;<span class="built_in">InsertTuple</span>(tuple_meta, new_tuple, exec_ctx_-&gt;<span class="built_in">GetLockManager</span>(), exec_ctx_-&gt;<span class="built_in">GetTransaction</span>(), table_info_-&gt;oid_);</span><br><span class="line">    <span class="keyword">if</span> (tuple_rid == std::<span class="literal">nullopt</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;</span><br><span class="line">      <span class="keyword">auto</span> key = new_tuple.<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(key, *tuple_rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());<span class="comment">//Index插入key</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">emplace_back</span>(TypeId::INTEGER, count);</span><br><span class="line">  *tuple = &#123;values, &amp;<span class="built_in">GetOutputSchema</span>()&#125;;<span class="comment">//入参tuple返回update的参数个数</span></span><br><span class="line">  successful_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DeleteExecutor实现"><a href="#DeleteExecutor实现" class="headerlink" title="DeleteExecutor实现"></a>DeleteExecutor实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeleteExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> DeletePlanNode *plan_;<span class="comment">//对应的DeletePlanNode</span></span><br><span class="line">  <span class="comment">/** The child executor from which RIDs for deleted tuples are pulled */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;<span class="comment">//孩子DeleteExecutor</span></span><br><span class="line">  <span class="type">bool</span> successful_;<span class="comment">//判断删除是否成功</span></span><br><span class="line">  TableInfo *table_info_;<span class="comment">//删除的Table</span></span><br><span class="line">  std::vector&lt;IndexInfo *&gt; index_infos_;<span class="comment">//Table对应的所有Index</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  successful_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  table_info_ = catalog-&gt;<span class="built_in">GetTable</span>(plan_-&gt;<span class="built_in">TableOid</span>());</span><br><span class="line">  index_infos_ = catalog-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">DeleteExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  TupleMeta tuple_meta;</span><br><span class="line">  <span class="keyword">if</span> (successful_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tuple_meta.delete_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  tuple_meta.insert_txn_id_ = INVALID_TXN_ID;</span><br><span class="line">  tuple_meta.is_deleted_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">auto</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;<span class="comment">//从孩子节点获取tuple</span></span><br><span class="line">    table_info_-&gt;table_-&gt;<span class="built_in">UpdateTupleMeta</span>(tuple_meta, *rid);<span class="comment">//删除Table中对应的Tuple，标记为删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index_info : index_infos_) &#123;<span class="comment">//删除该Table上所有Index中与该Tuple对应的key</span></span><br><span class="line">      <span class="keyword">auto</span> key = tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index_info-&gt;key_schema_, index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">      index_info-&gt;index_-&gt;<span class="built_in">DeleteEntry</span>(key, *rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    count++;<span class="comment">//删除计数count++</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">emplace_back</span>(TypeId::INTEGER, count);</span><br><span class="line">  *tuple = <span class="built_in">Tuple</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());<span class="comment">//入参tuple返回删除的tuple数量</span></span><br><span class="line">  successful_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IndexScanExecutor实现"><a href="#IndexScanExecutor实现" class="headerlink" title="IndexScanExecutor实现"></a>IndexScanExecutor实现</h3><p>SELECT FROM <table> ORDER BY <index column>中的ORDER BY会被转为IndexScan<br></index></table></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexScanExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> IndexScanPlanNode *plan_;<span class="comment">//对应的IndexScanPlanNode</span></span><br><span class="line">  IndexInfo *index_info_;<span class="comment">//IndexInfo</span></span><br><span class="line">  TableInfo *table_info_;<span class="comment">//TableInfo</span></span><br><span class="line">  BPlusTreeIndexForTwoIntegerColumn *index_;<span class="comment">//扫描的Index</span></span><br><span class="line">  std::unique_ptr&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt; index_iterator_;<span class="comment">//扫描的Index的IndexIterator</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IndexScanExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> catalog = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>();</span><br><span class="line">  index_info_ = catalog-&gt;<span class="built_in">GetIndex</span>(plan_-&gt;index_oid_);<span class="comment">//获取对应的Index_Info</span></span><br><span class="line">  table_info_ = catalog-&gt;<span class="built_in">GetTable</span>(index_info_-&gt;table_name_);<span class="comment">//获取对应的Table_Info</span></span><br><span class="line">  index_ = <span class="built_in">dynamic_cast</span>&lt;BPlusTreeIndexForTwoIntegerColumn *&gt;(index_info_-&gt;index_.<span class="built_in">get</span>());</span><br><span class="line">  index_iterator_ = std::<span class="built_in">make_unique</span>&lt;BPlusTreeIndexIteratorForTwoIntegerColumn&gt;(index_-&gt;<span class="built_in">GetBeginIterator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">IndexScanExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!index_iterator_-&gt;<span class="built_in">IsEnd</span>()) &#123;<span class="comment">//遍历Index</span></span><br><span class="line">    <span class="keyword">auto</span> map = *(*index_iterator_);</span><br><span class="line">    *rid = map.second;<span class="comment">//拿到rid</span></span><br><span class="line">    <span class="keyword">if</span> (!table_info_-&gt;table_-&gt;<span class="built_in">GetTupleMeta</span>(*rid).is_deleted_) &#123;  <span class="comment">// 未被删除</span></span><br><span class="line">      index_iterator_-&gt;<span class="keyword">operator</span>++();</span><br><span class="line">      *tuple = table_info_-&gt;table_-&gt;<span class="built_in">GetTuple</span>(*rid).second;<span class="comment">//入参tuple返回rid指向的tuple</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index_iterator_-&gt;<span class="keyword">operator</span>++();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过SQLLogicTests#1 to #6<br><img src="/../images/cmu15445-project3/10.png" alt="img"><br><img src="/../images/cmu15445-project3/11.png" alt="img"><br><img src="/../images/cmu15445-project3/12.png" alt="img"><br><img src="/../images/cmu15445-project3/13.png" alt="img"><br><img src="/../images/cmu15445-project3/14.png" alt="img"><br><img src="/../images/cmu15445-project3/15.png" alt="img"></p>
<h2 id="Task-2-Aggregation-Join-Executors"><a href="#Task-2-Aggregation-Join-Executors" class="headerlink" title="Task#2 Aggregation &amp; Join Executors"></a>Task#2 Aggregation &amp; Join Executors</h2><h3 id="AggregationExecutor实现"><a href="#AggregationExecutor实现" class="headerlink" title="AggregationExecutor实现"></a>AggregationExecutor实现</h3><blockquote>
<p>AggregationExecutor用来支持以下的sql查询，第四条sql语句的DISTINCT相当于GROUP BY<br><br>AggregationExecutor不需要处理HAVING语句，planner会让AggregationPlanNode跟着一个FilterPlanNode<br><img src="/../images/cmu15445-project3/7.png" alt="img"></p>
</blockquote>
<p>补充完成SimpleAggregationHashTable，其中哈希表的键AggregateKey就是GROUP BY的columns<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleAggregationHashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/** The hash table is just a map from aggregate keys to aggregate values */</span></span><br><span class="line">  std::unordered_map&lt;AggregateKey, AggregateValue&gt; ht_&#123;&#125;;</span><br><span class="line">  <span class="comment">/** The aggregate expressions that we have */</span></span><br><span class="line">  <span class="type">const</span> std::vector&lt;AbstractExpressionRef&gt; &amp;agg_exprs_;</span><br><span class="line">  <span class="comment">/** The types of aggregations that we have */</span></span><br><span class="line">  <span class="type">const</span> std::vector&lt;AggregationType&gt; &amp;agg_types_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">GenerateInitialAggregateValue</span><span class="params">()</span> -&gt; AggregateValue </span>&#123;</span><br><span class="line">    std::vector&lt;Value&gt; values&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;agg_type : agg_types_) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (agg_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::CountStarAggregate:</span><br><span class="line">          <span class="comment">// Count start starts at zero.</span></span><br><span class="line">          values.<span class="built_in">emplace_back</span>(ValueFactory::<span class="built_in">GetIntegerValue</span>(<span class="number">0</span>));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::CountAggregate:</span><br><span class="line">        <span class="keyword">case</span> AggregationType::SumAggregate:</span><br><span class="line">        <span class="keyword">case</span> AggregationType::MinAggregate:</span><br><span class="line">        <span class="keyword">case</span> AggregationType::MaxAggregate:</span><br><span class="line">          <span class="comment">// Others starts at null.</span></span><br><span class="line">          values.<span class="built_in">emplace_back</span>(ValueFactory::<span class="built_in">GetNullValueByType</span>(TypeId::INTEGER));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;values&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">CombineAggregateValues</span><span class="params">(AggregateValue *result, <span class="type">const</span> AggregateValue &amp;input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; agg_exprs_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (agg_types_[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::CountStarAggregate:<span class="comment">//count(*)统计null数量</span></span><br><span class="line">          result-&gt;aggregates_[i] = &#123;INTEGER, result-&gt;aggregates_[i].<span class="built_in">GetAs</span>&lt;<span class="type">int32_t</span>&gt;() + <span class="number">1</span>&#125;;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::CountAggregate:<span class="comment">//count()不统计null数量</span></span><br><span class="line">          <span class="keyword">if</span> (input.aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result-&gt;aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = &#123;INTEGER, <span class="number">1</span>&#125;;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = &#123;INTEGER, result-&gt;aggregates_[i].<span class="built_in">GetAs</span>&lt;<span class="type">int32_t</span>&gt;() + <span class="number">1</span>&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::SumAggregate:</span><br><span class="line">          <span class="keyword">if</span> (input.aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result-&gt;aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = input.aggregates_[i];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = result-&gt;aggregates_[i].<span class="built_in">Add</span>((input.aggregates_[i]));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::MinAggregate:</span><br><span class="line">          <span class="keyword">if</span> (input.aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result-&gt;aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = input.aggregates_[i];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = result-&gt;aggregates_[i].<span class="built_in">Min</span>(input.aggregates_[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AggregationType::MaxAggregate:</span><br><span class="line">          <span class="keyword">if</span> (input.aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result-&gt;aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = input.aggregates_[i];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;aggregates_[i] = result-&gt;aggregates_[i].<span class="built_in">Max</span>(input.aggregates_[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">InsertCombine</span><span class="params">(<span class="type">const</span> AggregateKey &amp;agg_key, <span class="type">const</span> AggregateValue &amp;agg_val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ht_.<span class="built_in">count</span>(agg_key) == <span class="number">0</span>) &#123;</span><br><span class="line">      ht_.<span class="built_in">insert</span>(&#123;agg_key, <span class="built_in">GenerateInitialAggregateValue</span>()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CombineAggregateValues</span>(&amp;ht_[agg_key], agg_val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> AggregateKey &amp;agg_key, <span class="type">const</span> AggregateValue &amp;agg_val)</span> </span>&#123; ht_.<span class="built_in">insert</span>(&#123;agg_key, agg_val&#125;); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AggregationExecutor</span> &#123;</span><br><span class="line">  <span class="comment">// 添加数据成员</span></span><br><span class="line">  <span class="type">const</span> AggregationPlanNode *plan_;</span><br><span class="line">  <span class="comment">/** The child executor that produces tuples over which the aggregation is computed */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_;</span><br><span class="line">  <span class="comment">/** Simple aggregation hash table */</span></span><br><span class="line">  SimpleAggregationHashTable aht_;</span><br><span class="line">  <span class="comment">/** Simple aggregation hash table iterator */</span></span><br><span class="line">  std::unique_ptr&lt;SimpleAggregationHashTable::Iterator&gt; aht_iterator_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AggregationExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple tuple;</span><br><span class="line">  RID rid;</span><br><span class="line">  <span class="keyword">while</span> (child_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;<span class="comment">//遍历孩子executor中所有的tuple</span></span><br><span class="line">    <span class="comment">//构建AggregateKey 和 AggregateValue 插入哈希表</span></span><br><span class="line">    AggregateKey key = <span class="built_in">MakeAggregateKey</span>(&amp;tuple);</span><br><span class="line">    AggregateValue value = <span class="built_in">MakeAggregateValue</span>(&amp;tuple);</span><br><span class="line">    aht_.<span class="built_in">InsertCombine</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (aht_.<span class="built_in">Begin</span>() == aht_.<span class="built_in">End</span>() &amp;&amp; plan_-&gt;<span class="built_in">GetGroupBys</span>().<span class="built_in">empty</span>()) &#123;  <span class="comment">// hash表为空,</span></span><br><span class="line">    AggregateKey key;</span><br><span class="line">    aht_.<span class="built_in">Insert</span>(key, aht_.<span class="built_in">GenerateInitialAggregateValue</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  aht_iterator_ = std::<span class="built_in">make_unique</span>&lt;SimpleAggregationHashTable::Iterator&gt;(aht_.<span class="built_in">Begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">AggregationExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((*aht_iterator_) == aht_.<span class="built_in">End</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> key = aht_iterator_-&gt;<span class="built_in">Key</span>();</span><br><span class="line">  <span class="keyword">auto</span> value = aht_iterator_-&gt;<span class="built_in">Val</span>();</span><br><span class="line">  ++(*aht_iterator_);<span class="comment">//迭代器++</span></span><br><span class="line">  key.group_bys_.<span class="built_in">insert</span>(key.group_bys_.<span class="built_in">end</span>(), value.aggregates_.<span class="built_in">begin</span>(), value.aggregates_.<span class="built_in">end</span>());</span><br><span class="line">  *tuple = &#123;key.group_bys_, &amp;<span class="built_in">GetOutputSchema</span>()&#125;;<span class="comment">//key和value合并后由入参tuple返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="NestedLoopJoinExecutor实现"><a href="#NestedLoopJoinExecutor实现" class="headerlink" title="NestedLoopJoinExecutor实现"></a>NestedLoopJoinExecutor实现</h3><p>NestedLoopJoinExecutor将支持inner join和left join，使用simple nested loop join算法<br><img src="/../images/cmu15445-project3/8.png" alt="img"></p>
<h4 id="NestedLoopJoin是流水线破坏者吗？"><a href="#NestedLoopJoin是流水线破坏者吗？" class="headerlink" title="NestedLoopJoin是流水线破坏者吗？"></a>NestedLoopJoin是流水线破坏者吗？</h4><p>BusTub采用火山模型(iterator processing<br> model)执行算子。但是某些算子直到子算子提交所有元组的计算结果，才会解除阻塞。如Join、SubQueries、Ordering等，此类操作就被称为Pipeline Breaker。在Task2中，Aggregation、HashJoin都备注了是Pipeline Breaker，但NestedLoopJoin并没有这么说明，如果把它当做Pipeline Breaker，则无法通过测试，Spring2023要求NestedLoopJoin左子节点每次调用一次Next()方法,右子节点都需要Init()一次，因此并非Pipeline Breaker。这也意味着NestedLoopJoin的性能非常糟糕。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NestedLoopJoinExecutor</span> &#123; </span><br><span class="line">  <span class="type">const</span> NestedLoopJoinPlanNode *plan_;</span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; left_executor_;<span class="comment">//左孩子</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; right_executor_;<span class="comment">//右孩子</span></span><br><span class="line">  std::vector&lt;Tuple&gt; right_tuples_;</span><br><span class="line">  <span class="type">int</span> index_;</span><br><span class="line">  Tuple left_tuple_;</span><br><span class="line">  <span class="type">bool</span> is_match_;<span class="comment">//表示当前left_tuple_是否有匹配项</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NestedLoopJoinExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  left_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  right_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple right_tuple;</span><br><span class="line">  RID right_rid;</span><br><span class="line">  <span class="comment">//将右孩子的所有Tuple遍历出来放在right_tuples中</span></span><br><span class="line">  <span class="keyword">while</span> (right_executor_-&gt;<span class="built_in">Next</span>(&amp;right_tuple, &amp;right_rid)) &#123;</span><br><span class="line">    right_tuples_.<span class="built_in">emplace_back</span>(right_tuple);</span><br><span class="line">  &#125;</span><br><span class="line">  index_ = <span class="number">0</span>;</span><br><span class="line">  is_match_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">NestedLoopJoinExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  RID left_rid;</span><br><span class="line">  <span class="keyword">if</span> (index_ != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 上次右侧循环还未结束</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NestedLoop</span>(tuple, rid)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取左孩子的一个tuple存储在left_tuple_中</span></span><br><span class="line">  <span class="keyword">while</span> (left_executor_-&gt;<span class="built_in">Next</span>(&amp;left_tuple_, &amp;left_rid)) &#123;</span><br><span class="line">    right_executor_-&gt;<span class="built_in">Init</span>();  <span class="comment">// no use 单纯为了通过测试</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NestedLoop</span>(tuple, rid)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">NestedLoopJoinExecutor::NestedLoop</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (index_ &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_tuples_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (plan_-&gt;predicate_) &#123;</span><br><span class="line">      <span class="keyword">auto</span> res = plan_-&gt;predicate_-&gt;<span class="built_in">EvaluateJoin</span>(&amp;left_tuple_, left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), &amp;right_tuples_[index_], right_executor_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">      <span class="keyword">if</span> (!(!res.<span class="built_in">IsNull</span>() &amp;&amp; res.<span class="built_in">GetAs</span>&lt;<span class="type">bool</span>&gt;())) &#123;  <span class="comment">// 不符合条件</span></span><br><span class="line">        index_++;</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// 过滤</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 符合条件</span></span><br><span class="line">    <span class="built_in">MergeTuple</span>(tuple);</span><br><span class="line">    index_ = (index_ + <span class="number">1</span>) % right_tuples_.<span class="built_in">size</span>();</span><br><span class="line">    is_match_ = (index_ != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  index_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!is_match_ &amp;&amp; plan_-&gt;<span class="built_in">GetJoinType</span>() == JoinType::LEFT) &#123;</span><br><span class="line">    <span class="comment">// left join</span></span><br><span class="line">    std::vector&lt;Value&gt; values;</span><br><span class="line">    values.<span class="built_in">reserve</span>(<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(left_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">      values.<span class="built_in">emplace_back</span>(left_tuple_.<span class="built_in">GetValue</span>(&amp;left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">      values.<span class="built_in">emplace_back</span>(ValueFactory::<span class="built_in">GetNullValueByType</span>(right_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumn</span>(i).<span class="built_in">GetType</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    *tuple = &#123;values, &amp;<span class="built_in">GetOutputSchema</span>()&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  is_match_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NestedLoopJoinExecutor::MergeTuple</span><span class="params">(Tuple *tuple)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// inner join</span></span><br><span class="line">  std::vector&lt;Value&gt; values;</span><br><span class="line">  values.<span class="built_in">reserve</span>(<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(left_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(left_tuple_.<span class="built_in">GetValue</span>(&amp;left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_executor_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(right_tuples_[index_].<span class="built_in">GetValue</span>(&amp;right_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">  &#125;</span><br><span class="line">  *tuple = &#123;values, &amp;<span class="built_in">GetOutputSchema</span>()&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到这里为止，通过SQLLogicTests #7 to #12<br><img src="/../images/cmu15445-project3/16.png" alt="img"><br><img src="/../images/cmu15445-project3/17.png" alt="img"><br><img src="/../images/cmu15445-project3/18.png" alt="img"><br><img src="/../images/cmu15445-project3/19.png" alt="img"><br><img src="/../images/cmu15445-project3/20.png" alt="img"><br><img src="/../images/cmu15445-project3/21.png" alt="img"></p>
<h3 id="HashJoinExecutor实现"><a href="#HashJoinExecutor实现" class="headerlink" title="HashJoinExecutor实现"></a>HashJoinExecutor实现</h3><p> 你将要为HashJoinExecutor实现inner join和left join，使用hash join算法<br> <img src="/../images/cmu15445-project3/9.png" alt="img"><br> 和NestedLoopJoin相同，HashJoin要处理inner join和left join两种情况，而这就会影响HashJoin建表的选择———对于Left join，需要在右表不存在对应匹配时，返回将右表字段用NULL填充的记录。因此对Left Join，在创建哈希表时应该选择右表。</p>
<p>实现思路：<br><br>先遍历右表的所有tuple，收集右表的HashJoinKey，加入哈希表(键值对为HashJoinKey-tuple)<br><br>然后遍历左表的所有tuple，收集左表的HashJoinKey，在哈希表中查找是否有匹配的HashJoinKey，如果匹配成功，拼接<br><br>如果匹配失败，并且是left join，左表的tuple拼接null<br><br>拼接好的结果保存在result_中，由index_下标遍历<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">HashJoinExecutor</span> &#123;</span><br><span class="line">  <span class="type">const</span> HashJoinPlanNode *plan_;</span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; left_child_;</span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; right_child_;</span><br><span class="line">  std::unordered_map&lt;HashJoinKey, std::vector&lt;Tuple&gt;&gt; map_;</span><br><span class="line">  std::vector&lt;Tuple&gt; result_;</span><br><span class="line">  <span class="type">int</span> index_;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">HashJoinExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  left_child_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  right_child_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple right_tuple;</span><br><span class="line">  RID right_rid;</span><br><span class="line">  <span class="keyword">while</span> (right_child_-&gt;<span class="built_in">Next</span>(&amp;right_tuple, &amp;right_rid)) &#123;</span><br><span class="line">    HashJoinKey key;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;expression : plan_-&gt;<span class="built_in">RightJoinKeyExpressions</span>()) &#123;</span><br><span class="line">      key.column_values_.<span class="built_in">emplace_back</span>(expression-&gt;<span class="built_in">Evaluate</span>(&amp;right_tuple, right_child_-&gt;<span class="built_in">GetOutputSchema</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入哈希表</span></span><br><span class="line">    <span class="keyword">if</span> (map_.<span class="built_in">count</span>(key) != <span class="number">0</span>) &#123;</span><br><span class="line">      map_[key].<span class="built_in">emplace_back</span>(right_tuple);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map_[key] = &#123;right_tuple&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历左侧查询,得到查询结果</span></span><br><span class="line">  Tuple left_tuple;</span><br><span class="line">  RID left_rid;</span><br><span class="line">  <span class="keyword">while</span> (left_child_-&gt;<span class="built_in">Next</span>(&amp;left_tuple, &amp;left_rid)) &#123;</span><br><span class="line">    HashJoinKey key;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;expression : plan_-&gt;<span class="built_in">LeftJoinKeyExpressions</span>()) &#123;</span><br><span class="line">      key.column_values_.<span class="built_in">emplace_back</span>(expression-&gt;<span class="built_in">Evaluate</span>(&amp;left_tuple, left_child_-&gt;<span class="built_in">GetOutputSchema</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map_.<span class="built_in">count</span>(key) != <span class="number">0</span>) &#123;  <span class="comment">// 匹配成功</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : map_[key]) &#123;</span><br><span class="line">        std::vector&lt;Value&gt; values;</span><br><span class="line">        values.<span class="built_in">reserve</span>(<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(left_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">          values.<span class="built_in">emplace_back</span>(left_tuple.<span class="built_in">GetValue</span>(&amp;left_child_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">          values.<span class="built_in">emplace_back</span>(t.<span class="built_in">GetValue</span>(&amp;right_child_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">        &#125;</span><br><span class="line">        result_.<span class="built_in">emplace_back</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plan_-&gt;<span class="built_in">GetJoinType</span>() == JoinType::LEFT) &#123;  <span class="comment">// 匹配失败,但是为LEFT JOIN</span></span><br><span class="line">      std::vector&lt;Value&gt; values;</span><br><span class="line">      values.<span class="built_in">reserve</span>(<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(left_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">        values.<span class="built_in">emplace_back</span>(left_tuple.<span class="built_in">GetValue</span>(&amp;left_child_-&gt;<span class="built_in">GetOutputSchema</span>(), i));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(right_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>()); ++i) &#123;</span><br><span class="line">        values.<span class="built_in">emplace_back</span>(ValueFactory::<span class="built_in">GetNullValueByType</span>(right_child_-&gt;<span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumn</span>(i).<span class="built_in">GetType</span>()));</span><br><span class="line">      &#125;</span><br><span class="line">      result_.<span class="built_in">emplace_back</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  index_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">HashJoinExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index_ &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(result_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *tuple = result_[index_];</span><br><span class="line">  index_++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optimizing-NestedLoopJoin-to-HashJoin"><a href="#Optimizing-NestedLoopJoin-to-HashJoin" class="headerlink" title="Optimizing NestedLoopJoin to HashJoin"></a>Optimizing NestedLoopJoin to HashJoin</h3><p>具体来说，当连接谓词是两列之间等条件的合取时，可以使用散列连接算法。就本项目而言，处理单个等值条件以及通过 AND 连接的两个等值条件将获得满分<br><br>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Optimizer::OptimizeNLJAsHashJoin</span><span class="params">(<span class="type">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class="line">  <span class="comment">// TODO(student): implement NestedLoopJoin -&gt; HashJoin optimizer rule</span></span><br><span class="line">  <span class="comment">// Note for 2023 Spring: You should at least support join keys of the form:</span></span><br><span class="line">  <span class="comment">// 1. &lt;column expr&gt; = &lt;column expr&gt;</span></span><br><span class="line">  <span class="comment">// 2. &lt;column expr&gt; = &lt;column expr&gt; AND &lt;column expr&gt; = &lt;column expr&gt;</span></span><br><span class="line">  std::vector&lt;AbstractPlanNodeRef&gt; children;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;child : plan-&gt;<span class="built_in">GetChildren</span>()) &#123;<span class="comment">//递归优化</span></span><br><span class="line">    children.<span class="built_in">emplace_back</span>(<span class="built_in">OptimizeNLJAsHashJoin</span>(child));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> optimized_plan = plan-&gt;<span class="built_in">CloneWithChildren</span>(std::<span class="built_in">move</span>(children));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (optimized_plan-&gt;<span class="built_in">GetType</span>() == PlanType::NestedLoopJoin) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> nlj_plan = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> NestedLoopJoinPlanNode &amp;&gt;(*optimized_plan);</span><br><span class="line">    <span class="built_in">BUSTUB_ENSURE</span>(nlj_plan.children_.<span class="built_in">size</span>() == <span class="number">2</span>, <span class="string">&quot;NLJ should have exactly 2 children.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *expr = <span class="built_in">dynamic_cast</span>&lt;ComparisonExpression *&gt;(nlj_plan.<span class="built_in">Predicate</span>().<span class="built_in">get</span>()); expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (expr-&gt;comp_type_ == ComparisonType::Equal) &#123; <span class="comment">// 如果表达式的Type为 ComparisonType::Equal</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> *left_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr-&gt;children_[<span class="number">0</span>].<span class="built_in">get</span>()); left_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">auto</span> *right_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr-&gt;children_[<span class="number">1</span>].<span class="built_in">get</span>());</span><br><span class="line">              right_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            std::vector&lt;AbstractExpressionRef&gt; left_key_expressions;</span><br><span class="line">            std::vector&lt;AbstractExpressionRef&gt; right_key_expressions;</span><br><span class="line">            <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">              left_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                  std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">              right_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                  std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">1</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">              left_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                  std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">              right_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                  std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">1</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;HashJoinPlanNode&gt;(nlj_plan.output_schema_, nlj_plan.<span class="built_in">GetLeftPlan</span>(),</span><br><span class="line">                                                      nlj_plan.<span class="built_in">GetRightPlan</span>(), std::<span class="built_in">move</span>(left_key_expressions),</span><br><span class="line">                                                      std::<span class="built_in">move</span>(right_key_expressions), nlj_plan.<span class="built_in">GetJoinType</span>());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *expr = <span class="built_in">dynamic_cast</span>&lt;LogicExpression *&gt;(nlj_plan.<span class="built_in">Predicate</span>().<span class="built_in">get</span>()); expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (expr-&gt;logic_type_ == LogicType::And) &#123;<span class="comment">//如果表达式的 Type为 LogicType::And</span></span><br><span class="line">        <span class="built_in">BUSTUB_ASSERT</span>(expr-&gt;<span class="built_in">GetChildren</span>().<span class="built_in">size</span>() == <span class="number">2</span>, <span class="string">&quot;LogicExpression has two children&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> *expr1 = <span class="built_in">dynamic_cast</span>&lt;ComparisonExpression *&gt;(expr-&gt;children_[<span class="number">0</span>].<span class="built_in">get</span>()); expr1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">auto</span> *expr2 = <span class="built_in">dynamic_cast</span>&lt;ComparisonExpression *&gt;(expr-&gt;children_[<span class="number">1</span>].<span class="built_in">get</span>()); expr2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expr1-&gt;comp_type_ == ComparisonType::Equal &amp;&amp; expr2-&gt;comp_type_ == ComparisonType::Equal) &#123; <span class="comment">// 两个子表达式的Type均为 ComparisonType::Equal</span></span><br><span class="line">              std::vector&lt;AbstractExpressionRef&gt; left_key_expressions;</span><br><span class="line">              std::vector&lt;AbstractExpressionRef&gt; right_key_expressions;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">auto</span> *left_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr1-&gt;children_[<span class="number">0</span>].<span class="built_in">get</span>());</span><br><span class="line">                  left_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">auto</span> *right_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr1-&gt;children_[<span class="number">1</span>].<span class="built_in">get</span>());</span><br><span class="line">                    right_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                    left_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                    right_key_expressions.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(</span><br><span class="line">                        <span class="number">1</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    left_key_expressions.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(</span><br><span class="line">                        <span class="number">0</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                    right_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">1</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">auto</span> *left_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr2-&gt;children_[<span class="number">0</span>].<span class="built_in">get</span>());</span><br><span class="line">                  left_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">auto</span> *right_expr = <span class="built_in">dynamic_cast</span>&lt;ColumnValueExpression *&gt;(expr2-&gt;children_[<span class="number">1</span>].<span class="built_in">get</span>());</span><br><span class="line">                    right_expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                    left_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">0</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                    right_key_expressions.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(</span><br><span class="line">                        <span class="number">1</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">1</span> &amp;&amp; right_expr-&gt;<span class="built_in">GetTupleIdx</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    left_key_expressions.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(</span><br><span class="line">                        <span class="number">0</span>, right_expr-&gt;<span class="built_in">GetColIdx</span>(), right_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                    right_key_expressions.<span class="built_in">emplace_back</span>(</span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;ColumnValueExpression&gt;(<span class="number">1</span>, left_expr-&gt;<span class="built_in">GetColIdx</span>(), left_expr-&gt;<span class="built_in">GetReturnType</span>()));</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;HashJoinPlanNode&gt;(nlj_plan.output_schema_, nlj_plan.<span class="built_in">GetLeftPlan</span>(),</span><br><span class="line">                                                        nlj_plan.<span class="built_in">GetRightPlan</span>(), std::<span class="built_in">move</span>(left_key_expressions),</span><br><span class="line">                                                        std::<span class="built_in">move</span>(right_key_expressions), nlj_plan.<span class="built_in">GetJoinType</span>());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> optimized_plan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里为止，通过SQLLogicTests #14 to #15<br><img src="/../images/cmu15445-project3/22.png" alt="img"><br><img src="/../images/cmu15445-project3/23.png" alt="img"><br><img src="/../images/cmu15445-project3/24.png" alt="img"></p>
<h2 id="Task-3-Sort-Limit-Executors-and-Top-N-Optimization"><a href="#Task-3-Sort-Limit-Executors-and-Top-N-Optimization" class="headerlink" title="Task#3 Sort + Limit Executors and Top-N Optimization"></a>Task#3 Sort + Limit Executors and Top-N Optimization</h2><h3 id="SortExecutor实现："><a href="#SortExecutor实现：" class="headerlink" title="SortExecutor实现："></a>SortExecutor实现：</h3><p>如果查询的ORDER BY属性与索引的key不匹配，BusTub将为查询生成一个SortPlanNode<br><br>如果查询不包含排序方向(即ASC、DESC)，则排序模式将为默认(即ASC)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SortExecutor</span> &#123;</span><br><span class="line">  <span class="comment">//添加数据成员</span></span><br><span class="line">  <span class="type">const</span> SortPlanNode *plan_;</span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;</span><br><span class="line">  std::vector&lt;Tuple&gt; result_;</span><br><span class="line">  <span class="type">int</span> index_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Tuple tuple;</span><br><span class="line">  RID rid;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;<span class="comment">//遍历孩子executor的所有tuple放入result_</span></span><br><span class="line">    result_.<span class="built_in">emplace_back</span>(tuple);</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">sort</span>(result_.<span class="built_in">begin</span>(), result_.<span class="built_in">end</span>(),</span><br><span class="line">            [<span class="keyword">this</span>](<span class="type">const</span> Tuple &amp;left, <span class="type">const</span> Tuple &amp;right) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">TupleComparator</span>(left, right); &#125;);<span class="comment">//对result_进行排序</span></span><br><span class="line">  index_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SortExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index_ &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(result_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *tuple = result_[index_];</span><br><span class="line">  index_++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SortExecutor::TupleComparator</span><span class="params">(<span class="type">const</span> Tuple &amp;left, <span class="type">const</span> Tuple &amp;right)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;order_by = plan_-&gt;<span class="built_in">GetOrderBy</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : order_by) &#123;</span><br><span class="line">    <span class="keyword">auto</span> order = p.first;</span><br><span class="line">    <span class="keyword">auto</span> &amp;exp = p.second;</span><br><span class="line">    <span class="keyword">auto</span> lvalue = exp-&gt;<span class="built_in">Evaluate</span>(&amp;left, child_executor_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    <span class="keyword">auto</span> rvalue = exp-&gt;<span class="built_in">Evaluate</span>(&amp;right, child_executor_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">    <span class="keyword">if</span> (order == OrderByType::DESC) &#123;</span><br><span class="line">      <span class="keyword">if</span> (lvalue.<span class="built_in">CompareGreaterThan</span>(rvalue) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lvalue.<span class="built_in">CompareLessThan</span>(rvalue) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lvalue.<span class="built_in">CompareLessThan</span>(rvalue) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lvalue.<span class="built_in">CompareGreaterThan</span>(rvalue) == CmpBool::CmpTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">UNREACHABLE</span>(<span class="string">&quot;duplicate key is not allowed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LimitExecutor实现"><a href="#LimitExecutor实现" class="headerlink" title="LimitExecutor实现:"></a>LimitExecutor实现:</h3><p>LimitExectutor限制其子executor的输出tuple数量。如果其子executor生成的元组数量小于LimitExecutor中指定的限制，则该executor无效并生成它接受到的所有tuple</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LimitExecutor</span> &#123;</span><br><span class="line">  <span class="comment">//添加数据成员</span></span><br><span class="line">  <span class="type">const</span> LimitPlanNode *plan_;</span><br><span class="line">  <span class="comment">/** The child executor from which tuples are obtained */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;</span><br><span class="line">  <span class="type">size_t</span> num_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LimitExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  num_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LimitExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num_ &gt;= plan_-&gt;<span class="built_in">GetLimit</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (child_executor_-&gt;<span class="built_in">Next</span>(tuple, rid)) &#123;</span><br><span class="line">    num_++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-N-Optimization-Rule"><a href="#Top-N-Optimization-Rule" class="headerlink" title="Top-N Optimization Rule"></a>Top-N Optimization Rule</h3><p>用一个优先队列维护top n 条tuple</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TopNExecutor</span> &#123;</span><br><span class="line">  <span class="comment">//数据成员</span></span><br><span class="line">  <span class="type">const</span> TopNPlanNode *plan_;</span><br><span class="line">  <span class="comment">/** The child executor from which tuples are obtained */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;</span><br><span class="line">  std::priority_queue&lt;HeapKeyType&gt; heap_;<span class="comment">//一个优先队列</span></span><br><span class="line">  std::deque&lt;Tuple&gt; result_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TopNExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line">  Tuple tuple;</span><br><span class="line">  RID rid;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;<span class="comment">//child_executor_遍历所有的tuple</span></span><br><span class="line">    <span class="function">HeapKeyType <span class="title">key</span><span class="params">(tuple, plan_-&gt;GetOrderBy(), child_executor_.get())</span></span>;</span><br><span class="line">    heap_.<span class="built_in">emplace</span>(tuple, plan_-&gt;<span class="built_in">GetOrderBy</span>(), child_executor_.<span class="built_in">get</span>());<span class="comment">//加入优先队列中</span></span><br><span class="line">    <span class="keyword">if</span> (heap_.<span class="built_in">size</span>() &gt; plan_-&gt;<span class="built_in">GetN</span>()) &#123;<span class="comment">//保证优先队列中的size不超过N</span></span><br><span class="line">      heap_.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!heap_.<span class="built_in">empty</span>()) &#123;<span class="comment">//将heap中的tuple_都放入result_</span></span><br><span class="line">    result_.<span class="built_in">emplace_front</span>(heap_.<span class="built_in">top</span>().tuple_);</span><br><span class="line">    heap_.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TopNExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetNumInHeap</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">    *tuple = result_.<span class="built_in">front</span>();</span><br><span class="line">    result_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TopNExecutor::GetNumInHeap</span><span class="params">()</span> -&gt; <span class="type">size_t</span> </span>&#123; <span class="keyword">return</span> result_.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>到这里为止，通过SQLLogicTests #16 to #19<br><img src="/../images/cmu15445-project3/25.png" alt="img"><br><img src="/../images/cmu15445-project3/26.png" alt="img"><br><img src="/../images/cmu15445-project3/27.png" alt="img"><br><img src="/../images/cmu15445-project3/28.png" alt="img"></p>
<p>通过线上测试:<br><img src="/../images/cmu15445-project3/29.png" alt="img"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/cmu15445%E2%80%942023/" rel="tag"># cmu15445—2023</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/02/26/cmu15445-project2/" rel="prev" title="cmu15445-project2">
      <i class="fa fa-chevron-left"></i> cmu15445-project2
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/02/28/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5/" rel="next" title="ssh免密登录失败">
      ssh免密登录失败 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Query-Processing-Model"><span class="nav-number">1.</span> <span class="nav-text">Query Processing Model</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator-Model"><span class="nav-number">1.1.</span> <span class="nav-text">Iterator Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Materialization-Model"><span class="nav-number">1.2.</span> <span class="nav-text">Materialization Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vectorization-Model"><span class="nav-number">1.3.</span> <span class="nav-text">Vectorization Model</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BACKGROUND%EF%BC%9AQUERY-PROCESSING"><span class="nav-number">2.</span> <span class="nav-text">BACKGROUND：QUERY PROCESSING</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#note"><span class="nav-number">2.1.</span> <span class="nav-text">note:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inspecting-SQL-query-plans"><span class="nav-number">2.2.</span> <span class="nav-text">Inspecting SQL query plans</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Task-1-Access-Method-Executors"><span class="nav-number">3.</span> <span class="nav-text">Task#1 Access Method Executors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SeqScanExecutor%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.</span> <span class="nav-text">SeqScanExecutor实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InsertExecutor%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.2.</span> <span class="nav-text">InsertExecutor实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UpdateExecutor%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.</span> <span class="nav-text">UpdateExecutor实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DeleteExecutor%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.4.</span> <span class="nav-text">DeleteExecutor实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IndexScanExecutor%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.5.</span> <span class="nav-text">IndexScanExecutor实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Task-2-Aggregation-Join-Executors"><span class="nav-number">4.</span> <span class="nav-text">Task#2 Aggregation &amp; Join Executors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AggregationExecutor%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.1.</span> <span class="nav-text">AggregationExecutor实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NestedLoopJoinExecutor%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.</span> <span class="nav-text">NestedLoopJoinExecutor实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NestedLoopJoin%E6%98%AF%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%A0%B4%E5%9D%8F%E8%80%85%E5%90%97%EF%BC%9F"><span class="nav-number">4.2.1.</span> <span class="nav-text">NestedLoopJoin是流水线破坏者吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashJoinExecutor%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.3.</span> <span class="nav-text">HashJoinExecutor实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optimizing-NestedLoopJoin-to-HashJoin"><span class="nav-number">4.4.</span> <span class="nav-text">Optimizing NestedLoopJoin to HashJoin</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Task-3-Sort-Limit-Executors-and-Top-N-Optimization"><span class="nav-number">5.</span> <span class="nav-text">Task#3 Sort + Limit Executors and Top-N Optimization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SortExecutor%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">5.1.</span> <span class="nav-text">SortExecutor实现：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LimitExecutor%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.2.</span> <span class="nav-text">LimitExecutor实现:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-N-Optimization-Rule"><span class="nav-number">5.3.</span> <span class="nav-text">Top-N Optimization Rule</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="jingtao8a"
      src="/images/iverson.jpg">
  <p class="site-author-name" itemprop="name">jingtao8a</p>
  <div class="site-description" itemprop="description">this is life, full of ups and down</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jingtao8a</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
