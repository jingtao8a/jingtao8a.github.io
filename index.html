<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jingtao8a.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="this is life, full of ups and down">
<meta property="og:type" content="website">
<meta property="og:title" content="jingtao8a&#39;s blog">
<meta property="og:url" content="http://jingtao8a.github.io/index.html">
<meta property="og:site_name" content="jingtao8a&#39;s blog">
<meta property="og:description" content="this is life, full of ups and down">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="jingtao8a">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://jingtao8a.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>jingtao8a's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">jingtao8a's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2024/02/26/cmu15445-project2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/26/cmu15445-project2/" class="post-title-link" itemprop="url">cmu15445-project2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-26 22:16:24" itemprop="dateCreated datePublished" datetime="2024-02-26T22:16:24-08:00">2024-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-27 03:08:56" itemprop="dateModified" datetime="2024-02-27T03:08:56-08:00">2024-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15445-2023/" itemprop="url" rel="index"><span itemprop="name">cmu15445-2023</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h1><p>B+ Tree是一种自平衡树，它将数据有序地存储，并且在search、sequential access、insertions以及deletions操作的复杂度上都满足O(logn),其中sequential access的最终复杂度还与所需数据总量有关<br><img src="/../images/cmu15445-project2/1.png" alt="img"><br>以M—way B+tree为例，它的特点总结如下：</p>
<ul>
<li>每个节点最多存储M个key，有M+1个children</li>
<li>B+ Tree是perfectly balanced，即每个leaf node的深度都一样</li>
<li>除了root节点，所有节点必须至少处于半满状态，即 M&#x2F;2 - 1 &lt;&#x3D; #keys &lt;&#x3D; M - 1</li>
<li>假设每个inner node中包含k个keys，那么它必然有k + 1个children</li>
</ul>
<h1 id="B-Tree-Operations"><a href="#B-Tree-Operations" class="headerlink" title="B+ Tree Operations"></a>B+ Tree Operations</h1><p>Insert</p>
<blockquote>
<ol>
<li>找到对应的leafNode L</li>
<li>将key&#x2F;value pair按顺序插入到 L 中</li>
<li>如果L 还有足够的空间，操作结束；如果空间不足，则需要将L分裂成两个节点，同时在parent node上新增entry，若parent node也空间不足，则递归地分裂，直到root node为止</li>
</ol>
</blockquote>
<p>Max.degree &#x3D; 5时<br><br>从1插入到13的情况  <a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">BPlusTree可视化网站</a><br><img src="/../images/cmu15445-project2/2.png" alt="img"></p>
<p>Delete</p>
<blockquote>
<ol>
<li>从root开始，找到目标entry所在的leaf node L</li>
<li>删除该entry</li>
<li>如果L仍然处在半满状态，操作结束；否则先尝试从siblings那里借entries，如果失败，则将L 与相应的sibling合并</li>
<li>如果合并发生了，则可能需要递归地删除parent node中的entry</li>
</ol>
</blockquote>
<h1 id="CheckPoint-1"><a href="#CheckPoint-1" class="headerlink" title="CheckPoint#1"></a>CheckPoint#1</h1><h2 id="Task-1-B-Tree-Pages"><a href="#Task-1-B-Tree-Pages" class="headerlink" title="Task #1 B+ Tree Pages"></a>Task #1 B+ Tree Pages</h2><h3 id="class-BPlusTreePage的3个类成员"><a href="#class-BPlusTreePage的3个类成员" class="headerlink" title="class BPlusTreePage的3个类成员"></a>class BPlusTreePage的3个类成员</h3><p><img src="/../images/cmu15445-project2/3.png" alt="img"><br>GetMinSize函数实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPlusTreePage::GetMinSize</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsLeafPage</span>()) &#123;<span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">return</span> max_size_ / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (max_size_ + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="class-BPlusTreeInternalPage-public-BPlusTreePage"><a href="#class-BPlusTreeInternalPage-public-BPlusTreePage" class="headerlink" title="class BPlusTreeInternalPage : public BPlusTreePage "></a>class BPlusTreeInternalPage : public BPlusTreePage <br></h3><blockquote>
<p>一个Internal Page存储 m 个顺序 key 和 m + 1 个child pointers(其它BPlusTreePage的page_ids)<br><br>使用一个数组存储key&#x2F;page_id pairs，并且第一个key被设置为invalid，并且查找要从第二个key开始查找</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::Init</span><span class="params">(<span class="type">int</span> max_size, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetPageType</span>(IndexPageType::INTERNAL_PAGE);</span><br><span class="line">  <span class="built_in">SetMaxSize</span>(max_size);</span><br><span class="line">  <span class="built_in">SetSize</span>(size);<span class="comment">//size 默认为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::ValueIndex</span><span class="params">(<span class="type">const</span> ValueType &amp;value)</span> <span class="type">const</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">GetSize</span>(); ++i) &#123;<span class="comment">//顺序查找</span></span><br><span class="line">    <span class="keyword">if</span> (array_[i].second == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::LookUp</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> KeyComparator &amp;comparator)</span> <span class="type">const</span> -&gt; ValueType </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">GetSize</span>(); ++i) &#123;  <span class="comment">// 顺序查找</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator</span>(key, array_[i].first) &lt; <span class="number">0</span>) &#123;<span class="comment">//找到第一个大于key的array_[i].first</span></span><br><span class="line">      <span class="keyword">return</span> array_[i - <span class="number">1</span>].second;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array_[<span class="built_in">GetSize</span>() - <span class="number">1</span>].second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::Insert</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value, <span class="type">const</span> KeyComparator &amp;comparator)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetSize</span>() == <span class="built_in">GetMaxSize</span>()) &#123;<span class="comment">//已经满了返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// upper_bound</span></span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> r = <span class="built_in">GetSize</span>();</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator</span>(array_[mid].first, key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetSize</span>() - <span class="number">1</span>; i &gt;= l; --i) &#123;<span class="comment">//元素移位</span></span><br><span class="line">    array_[i + <span class="number">1</span>] = array_[i];</span><br><span class="line">  &#125;</span><br><span class="line">  array_[l] = &#123;key, value&#125;;<span class="comment">//存储插入的key-value</span></span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">1</span>);<span class="comment">//size ++</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="class-BPlusTreeLeafPage-public-BPlusTreePage"><a href="#class-BPlusTreeLeafPage-public-BPlusTreePage" class="headerlink" title="class BPlusTreeLeafPage : public BPlusTreePage"></a>class BPlusTreeLeafPage : public BPlusTreePage</h3><blockquote>
<p>一个Leaf Page存储 m 个顺序 key 和 m 个对应的value.value应该为 64-bit record_id 用于表示实际的tuple存储的地方(src&#x2F;include&#x2F;common&#x2F;rid.h)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::Init</span><span class="params">(<span class="type">int</span> max_size, <span class="type">int</span> size, <span class="type">page_id_t</span> next_page_id)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetPageType</span>(IndexPageType::LEAF_PAGE);</span><br><span class="line">  <span class="built_in">SetMaxSize</span>(max_size);</span><br><span class="line">  <span class="built_in">SetSize</span>(size);<span class="comment">//size 默认为0</span></span><br><span class="line">  <span class="built_in">SetNextPageId</span>(next_page_id);<span class="comment">//next_page_id默认为INVALID_PAGE_ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::KeyIndex</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> KeyComparator &amp;comparator, <span class="type">int</span> &amp;index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// lower_bound</span></span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> r = <span class="built_in">GetSize</span>();</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator</span>(array_[mid].first, key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  index = l;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(l != <span class="built_in">GetSize</span>() &amp;&amp; <span class="built_in">comparator</span>(<span class="built_in">KeyAt</span>(l), key) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::Insert</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value, <span class="type">const</span> KeyComparator &amp;comparator)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">KeyIndex</span>(key, comparator, pos)) &#123;  <span class="comment">// duplicate key</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//重复的key，直接返回false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetSize</span>() - <span class="number">1</span>; i &gt;= pos; --i) &#123;<span class="comment">//移动array_元素</span></span><br><span class="line">    array_[i + <span class="number">1</span>] = array_[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// insert</span></span><br><span class="line">  array_[pos] = &#123;key, value&#125;;<span class="comment">//插入key-value</span></span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">1</span>);<span class="comment">//size ++</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Class-BplusTreeHeaderPage"><a href="#Class-BplusTreeHeaderPage" class="headerlink" title="Class BplusTreeHeaderPage"></a>Class BplusTreeHeaderPage</h3><blockquote>
<p>头节点，存储了root page id，使得根节点和非根节点一样拥有父节点</p>
</blockquote>
<h2 id="Task-2a-B-Tree-Data-Structure-Insertion-Point-Search"><a href="#Task-2a-B-Tree-Data-Structure-Insertion-Point-Search" class="headerlink" title="Task #2a B+ Tree Data Structure(Insertion, Point Search)"></a>Task #2a B+ Tree Data Structure(Insertion, Point Search)</h2><p>GetRootPageId函数实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS <span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::GetRootPageId</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">page_id_t</span> </span>&#123;</span><br><span class="line">  ReadPageGuard guard = bpm_-&gt;<span class="built_in">FetchPageRead</span>(header_page_id_);</span><br><span class="line">  <span class="keyword">auto</span> page = guard.<span class="built_in">As</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">return</span> page-&gt;root_page_id_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Search操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::GetValue</span><span class="params">(<span class="type">const</span> KeyType &amp;key, std::vector&lt;ValueType&gt; *result, Transaction *txn)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Declaration of context instance.</span></span><br><span class="line">  Context ctx;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//先给header_page加读锁判断root_page是否存在，如果存在，给root_page加读锁，放入Context中</span></span><br><span class="line">    <span class="keyword">auto</span> header_page_guard = bpm_-&gt;<span class="built_in">FetchPageRead</span>(header_page_id_);</span><br><span class="line">    <span class="keyword">auto</span> header_page = header_page_guard.<span class="built_in">As</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">    <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">    ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(ctx.root_page_id_));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//查找到对应的leafPage</span></span><br><span class="line">  <span class="built_in">FindLeafPage</span>(key, Operation::Search, ctx);</span><br><span class="line">  <span class="keyword">auto</span> leaf_page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;LeafPage&gt;();</span><br><span class="line">  <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">KeyIndex</span>(key, comparator_, index)) &#123;</span><br><span class="line">    result-&gt;<span class="built_in">push_back</span>(leaf_page-&gt;<span class="built_in">ValueAt</span>(index));<span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::FindLeafPage</span><span class="params">(<span class="type">const</span> KeyType &amp;key, Operation op, Context &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Search) &#123;</span><br><span class="line">    <span class="comment">//Search的加锁策略</span></span><br><span class="line">    <span class="comment">//从root往下，不断地</span></span><br><span class="line">    <span class="comment">// - 获取child的read latch</span></span><br><span class="line">    <span class="comment">// - 释放parent的read latch</span></span><br><span class="line">    <span class="keyword">auto</span> page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> internal = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;InternalPage&gt;();</span><br><span class="line">      <span class="keyword">auto</span> next_page_id = internal-&gt;<span class="built_in">LookUp</span>(key, comparator_);</span><br><span class="line">      ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(next_page_id));</span><br><span class="line">      ctx.read_set_.<span class="built_in">pop_front</span>();</span><br><span class="line">      page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Insert || op == Operation::Remove) &#123;</span><br><span class="line">    <span class="comment">//Insert和Remove的加锁策略</span></span><br><span class="line">    <span class="comment">//从root往下，按照需要获取write latch，一旦获取到了child的write latch，检查</span></span><br><span class="line">    <span class="comment">//它是否安全，如果安全，则释放之前获取的所有write latch</span></span><br><span class="line">    <span class="keyword">auto</span> page = ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> internal = ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;InternalPage&gt;();</span><br><span class="line">      <span class="keyword">auto</span> next_page_id = internal-&gt;<span class="built_in">LookUp</span>(key, comparator_);</span><br><span class="line">      ctx.write_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageWrite</span>(next_page_id));</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">IsSafePage</span>(ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;(), op, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ctx.write_set_.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          ctx.write_set_.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      page = ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::IsSafePage</span><span class="params">(<span class="type">const</span> BPlusTreePage *tree_page, Operation op, <span class="type">bool</span> isRootPage)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Search) &#123;<span class="comment">//no use</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Insert) &#123;<span class="comment">//插入操作</span></span><br><span class="line">    <span class="comment">//若会发生上溢，表示不安全</span></span><br><span class="line">    <span class="keyword">if</span> (tree_page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">      <span class="comment">//叶子节点中，size最大为tree_page-&gt;GetMaxSize() - 1;</span></span><br><span class="line">      <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() + <span class="number">1</span> &lt; tree_page-&gt;<span class="built_in">GetMaxSize</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部节点中，size最大为tree_page-&gt;GetMaxSize()</span></span><br><span class="line">    <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() &lt; tree_page-&gt;<span class="built_in">GetMaxSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (op == Operation::Remove) &#123;<span class="comment">//删除操作</span></span><br><span class="line">    <span class="comment">//若会发生下溢，表示不安全</span></span><br><span class="line">    <span class="keyword">if</span> (isRootPage) &#123;<span class="comment">//对RootPage进行Remove操作</span></span><br><span class="line">      <span class="keyword">if</span> (tree_page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">        <span class="comment">//如果为叶子节点，size至少为2</span></span><br><span class="line">        <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() &gt; <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果为内部节点，size至少为3</span></span><br><span class="line">      <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() &gt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree_page-&gt;<span class="built_in">GetSize</span>() &gt; tree_page-&gt;<span class="built_in">GetMinSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Insert操作</p>
<blockquote>
<p>插入到leaf节点中，插入前，如果size &#x3D;&#x3D; max_size表示溢出，需要进行分裂<br>插入到internal节点中，插入前，如果size &#x3D;&#x3D; max_size表示溢出，需要进行分裂 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS <span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::Insert</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value, Transaction *txn)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Declaration of context instance.</span></span><br><span class="line">  Context ctx;</span><br><span class="line">  ctx.header_page_ = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(header_page_id_);<span class="comment">//先给header_page_id写锁</span></span><br><span class="line">  <span class="keyword">auto</span> header_page = ctx.header_page_-&gt;<span class="built_in">AsMut</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;  <span class="comment">// root not exist,start a new tree</span></span><br><span class="line">    <span class="keyword">auto</span> root_guard = bpm_-&gt;<span class="built_in">NewPageGuarded</span>(&amp;ctx.root_page_id_);<span class="comment">//申请root_page</span></span><br><span class="line">    header_page-&gt;root_page_id_ = ctx.root_page_id_;</span><br><span class="line">    <span class="keyword">auto</span> leaf_page = root_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line">    leaf_page-&gt;<span class="built_in">Init</span>(leaf_max_size_, <span class="number">1</span>);</span><br><span class="line">    leaf_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>] = &#123;key, value&#125;;<span class="comment">//插入key-value</span></span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">  ctx.write_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageWrite</span>(ctx.root_page_id_));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsSafePage</span>(ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;(), Operation::Insert, <span class="literal">true</span>)) &#123;<span class="comment">//如果root_page安全，释放header_page的写锁</span></span><br><span class="line">    ctx.header_page_ = std::<span class="literal">nullopt</span>;  <span class="comment">// unlock header_page</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">FindLeafPage</span>(key, Operation::Insert, ctx);</span><br><span class="line">  <span class="keyword">auto</span> &amp;leaf_page_guard = ctx.write_set_.<span class="built_in">back</span>();</span><br><span class="line">  <span class="keyword">auto</span> leaf_page = leaf_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (!leaf_page-&gt;<span class="built_in">Insert</span>(key, value, comparator_)) &#123;  <span class="comment">// duplicate key, 插入失败</span></span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">GetSize</span>() &lt; leaf_page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 叶子节点未溢出，不需要分裂</span></span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发生溢出,叶子节点分裂</span></span><br><span class="line">  <span class="keyword">auto</span> new_page_id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> new_leaf_page_guard = bpm_-&gt;<span class="built_in">NewPageGuarded</span>(&amp;new_page_id);</span><br><span class="line">  <span class="keyword">auto</span> new_leaf_page = new_leaf_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line">  std::<span class="built_in">copy</span>(leaf_page-&gt;<span class="built_in">GetArray</span>() + leaf_page-&gt;<span class="built_in">GetMinSize</span>(), leaf_page-&gt;<span class="built_in">GetArray</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">            new_leaf_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">  new_leaf_page-&gt;<span class="built_in">Init</span>(leaf_max_size_, leaf_page-&gt;<span class="built_in">GetSize</span>() - leaf_page-&gt;<span class="built_in">GetMinSize</span>(), leaf_page-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">  leaf_page-&gt;<span class="built_in">SetNextPageId</span>(new_leaf_page_guard.<span class="built_in">PageId</span>());</span><br><span class="line">  leaf_page-&gt;<span class="built_in">SetSize</span>(leaf_page-&gt;<span class="built_in">GetMinSize</span>());</span><br><span class="line">  KeyType split_key = new_leaf_page-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 将split_key插入父节点</span></span><br><span class="line">  <span class="built_in">InsertIntoParent</span>(split_key, new_leaf_page_guard.<span class="built_in">PageId</span>(), ctx, ctx.write_set_.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">  ctx.<span class="built_in">Drop</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPLUSTREE_TYPE::InsertIntoParent</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">page_id_t</span> right_child_id, Context &amp;ctx, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;  <span class="comment">// parent为header_page</span></span><br><span class="line">    <span class="comment">//创建新的root_page，并更新header_page中的root_page_id_</span></span><br><span class="line">    <span class="keyword">auto</span> new_root_page_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> new_root_page_guard = bpm_-&gt;<span class="built_in">NewPageGuarded</span>(&amp;new_root_page_id);</span><br><span class="line">    <span class="keyword">auto</span> new_root_page = new_root_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">    new_root_page-&gt;<span class="built_in">Init</span>(internal_max_size_, <span class="number">2</span>);</span><br><span class="line">    new_root_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].second = ctx.write_set_[index + <span class="number">1</span>].<span class="built_in">PageId</span>();</span><br><span class="line">    new_root_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">1</span>] = &#123;key, right_child_id&#125;;</span><br><span class="line">    <span class="keyword">auto</span> header_page = ctx.header_page_-&gt;<span class="built_in">AsMut</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">    header_page-&gt;root_page_id_ = new_root_page_id;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> parent_page = ctx.write_set_[index].<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (parent_page-&gt;<span class="built_in">Insert</span>(key, right_child_id, comparator_)) &#123;  <span class="comment">// 父节点不需要分裂</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父节点需要分裂</span></span><br><span class="line">  <span class="keyword">auto</span> new_parent_page_id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> new_parent_page_guard = bpm_-&gt;<span class="built_in">NewPageGuarded</span>(&amp;new_parent_page_id);</span><br><span class="line">  <span class="keyword">auto</span> new_parent_page = new_parent_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">auto</span> array = <span class="keyword">new</span> std::pair&lt;KeyType, <span class="type">page_id_t</span>&gt;[parent_page-&gt;<span class="built_in">GetMaxSize</span>() + <span class="number">1</span>];</span><br><span class="line">  std::<span class="built_in">copy</span>(parent_page-&gt;<span class="built_in">GetArray</span>(), parent_page-&gt;<span class="built_in">GetArray</span>() + parent_page-&gt;<span class="built_in">GetMaxSize</span>(), array);</span><br><span class="line">  <span class="comment">// upper_bound</span></span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> r = parent_page-&gt;<span class="built_in">GetMaxSize</span>();</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator_</span>(array[mid].first, key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 右移一位，腾出空间</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = parent_page-&gt;<span class="built_in">GetMaxSize</span>() - <span class="number">1</span>; i &gt;= l; --i) &#123;</span><br><span class="line">    array[i + <span class="number">1</span>] = array[i];</span><br><span class="line">  &#125;</span><br><span class="line">  array[l] = &#123;key, right_child_id&#125;;</span><br><span class="line">  std::<span class="built_in">copy</span>(array, array + parent_page-&gt;<span class="built_in">GetMinSize</span>(), parent_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">  std::<span class="built_in">copy</span>(array + parent_page-&gt;<span class="built_in">GetMinSize</span>(), array + parent_page-&gt;<span class="built_in">GetMaxSize</span>() + <span class="number">1</span>, new_parent_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">  new_parent_page-&gt;<span class="built_in">Init</span>(internal_max_size_, parent_page-&gt;<span class="built_in">GetMaxSize</span>() + <span class="number">1</span> - parent_page-&gt;<span class="built_in">GetMinSize</span>());</span><br><span class="line">  parent_page-&gt;<span class="built_in">SetSize</span>(parent_page-&gt;<span class="built_in">GetMinSize</span>());</span><br><span class="line">  <span class="keyword">delete</span>[] array;</span><br><span class="line">  <span class="built_in">InsertIntoParent</span>(new_parent_page-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>), new_parent_page_id, ctx, index - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CheckPoint#1本地测试<br><br><img src="/../images/cmu15445-project2/4.png" alt="img"><br><img src="/../images/cmu15445-project2/5.png" alt="img"></p>
<p>线上测试<br><br><img src="/../images/cmu15445-project2/6.png" alt="img"></p>
<h1 id="CheckPoint-2"><a href="#CheckPoint-2" class="headerlink" title="CheckPoint#2"></a>CheckPoint#2</h1><h2 id="Task-2b-B-Tree-Data-Structure-Deletion"><a href="#Task-2b-B-Tree-Data-Structure-Deletion" class="headerlink" title="Task #2b B+ Tree Data Structure(Deletion)"></a>Task #2b B+ Tree Data Structure(Deletion)</h2><p>Deletion操作:</p>
<blockquote>
<p>如果删除的leaf节点是root节点，那么删除后的size &#x3D;&#x3D; 0,表示下溢，需要将header_page中的root_page设置为INVALID_PAGE_ID<br><br>如果删除的leaf节点不是root节点，那么删除后的size &lt; min_size表示下溢<br><br>1.如果有右孩子<br></p>
<blockquote>
<p>2.判断是否能merge(merge_size &lt; max_size),能则merge，否则转3<br><br>3.向右孩子进行borrow<br></p>
</blockquote>
</blockquote>
<blockquote>
<p>4.如果有左孩子<br></p>
<blockquote>
<p>5.判断是否能merge(merge_size &lt; min_size),能则merge，否则转6<br><br>6.向左孩子进行borrow<br></p>
</blockquote>
</blockquote>
<blockquote>
<p>merge操作后需要删除internal节点中的entry, 与删除leaf节点中的entry十分相似<br></p>
</blockquote>
<blockquote>
<p>如果删除的internal节点是root节点，那么删除后的size&#x3D;&#x3D;1表示下溢，需要将header_page_中的root_page_id_设置为page-&gt;GetArray()[0].second<br><br>如果删除的internal节点不是root节点，那么删除后的size &lt; min_size表示下溢<br><br>1.如果有右孩子<br></p>
<blockquote>
<p>2.判断是否能merge(merge_size &lt;&#x3D; max_size),能则merge，否则转3<br><br>3.向右孩子进行borrow<br></p>
</blockquote>
</blockquote>
<blockquote>
<p>4.如果有左孩子<br></p>
<blockquote>
<p>5.判断是否能merge(merge_size &lt;&#x3D; max_size),能则merge，否则转6<br><br>6.向左孩子进行borrow<br></p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPLUSTREE_TYPE::Remove</span><span class="params">(<span class="type">const</span> KeyType &amp;key, Transaction *txn)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Declaration of context instance.</span></span><br><span class="line">  Context ctx;</span><br><span class="line">  ctx.header_page_ = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(header_page_id_);</span><br><span class="line">  <span class="keyword">auto</span> header_page = ctx.header_page_-&gt;<span class="built_in">AsMut</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;  <span class="comment">// root not exist</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">  ctx.write_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageWrite</span>(ctx.root_page_id_));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsSafePage</span>(ctx.write_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;(), Operation::Remove, <span class="literal">true</span>)) &#123;</span><br><span class="line">    ctx.header_page_ = std::<span class="literal">nullopt</span>;  <span class="comment">// unlock header_page</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">FindLeafPage</span>(key, Operation::Remove, ctx);</span><br><span class="line">  <span class="keyword">auto</span> &amp;leaf_page_guard = ctx.write_set_.<span class="built_in">back</span>();</span><br><span class="line">  <span class="keyword">auto</span> leaf_page = leaf_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// key不存在</span></span><br><span class="line">  <span class="keyword">if</span> (!leaf_page-&gt;<span class="built_in">KeyIndex</span>(key, comparator_, pos)) &#123;</span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// key存在,将其从leaf中删除</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = pos + <span class="number">1</span>; i &lt; leaf_page-&gt;<span class="built_in">GetSize</span>(); ++i) &#123;</span><br><span class="line">    leaf_page-&gt;<span class="built_in">GetArray</span>()[i - <span class="number">1</span>] = leaf_page-&gt;<span class="built_in">GetArray</span>()[i];</span><br><span class="line">  &#125;</span><br><span class="line">  leaf_page-&gt;<span class="built_in">SetSize</span>(leaf_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);  <span class="comment">// 更新leaf_page的size</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">GetSize</span>() &gt;= leaf_page-&gt;<span class="built_in">GetMinSize</span>()) &#123;  <span class="comment">// 无underflow 直接返回</span></span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// underflow</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="built_in">IsRootPage</span>(leaf_page_guard.<span class="built_in">PageId</span>())) &#123;  <span class="comment">// 该叶子节点是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">GetSize</span>() == <span class="number">0</span>) &#123;               <span class="comment">// size为0</span></span><br><span class="line">      header_page-&gt;root_page_id_ = INVALID_PAGE_ID;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.<span class="built_in">Drop</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> &amp;parent_page_guard = ctx.write_set_[ctx.write_set_.<span class="built_in">size</span>() - <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">auto</span> parent_page = parent_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">auto</span> index = parent_page-&gt;<span class="built_in">ValueIndex</span>(leaf_page_guard.<span class="built_in">PageId</span>());</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(index != <span class="number">-1</span>, <span class="string">&quot;index must not be -1&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果有右brother</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; parent_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">page_id_t</span> right_brother_page_id = parent_page-&gt;<span class="built_in">GetArray</span>()[index + <span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">auto</span> right_brother_page_guard = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(right_brother_page_id);</span><br><span class="line">    <span class="keyword">auto</span> right_brother_page = right_brother_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge_size = right_brother_page-&gt;<span class="built_in">GetSize</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">    <span class="keyword">if</span> (merge_size &lt; leaf_page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 可以合并</span></span><br><span class="line">      <span class="comment">// merge</span></span><br><span class="line">      std::<span class="built_in">copy</span>(right_brother_page-&gt;<span class="built_in">GetArray</span>(), right_brother_page-&gt;<span class="built_in">GetArray</span>() + right_brother_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                leaf_page-&gt;<span class="built_in">GetArray</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>());</span><br><span class="line">      leaf_page-&gt;<span class="built_in">SetSize</span>(merge_size);</span><br><span class="line">      leaf_page-&gt;<span class="built_in">SetNextPageId</span>(right_brother_page-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">      <span class="built_in">RemoveFromParent</span>(index + <span class="number">1</span>, ctx, ctx.write_set_.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// borrow</span></span><br><span class="line">      leaf_page-&gt;<span class="built_in">GetArray</span>()[leaf_page-&gt;<span class="built_in">GetSize</span>()] = right_brother_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>];</span><br><span class="line">      std::<span class="built_in">copy</span>(right_brother_page-&gt;<span class="built_in">GetArray</span>() + <span class="number">1</span>, right_brother_page-&gt;<span class="built_in">GetArray</span>() + right_brother_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                right_brother_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">      leaf_page-&gt;<span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">      right_brother_page-&gt;<span class="built_in">SetSize</span>(right_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">      parent_page-&gt;<span class="built_in">SetKeyAt</span>(index + <span class="number">1</span>, right_brother_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 左brother</span></span><br><span class="line">    <span class="built_in">BUSTUB_ASSERT</span>(index - <span class="number">1</span> &gt;= <span class="number">0</span>, <span class="string">&quot;left brother must exist&quot;</span>);</span><br><span class="line">    <span class="type">page_id_t</span> left_brother_page_id = parent_page-&gt;<span class="built_in">GetArray</span>()[index - <span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">auto</span> left_brother_page_guard = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(left_brother_page_id);</span><br><span class="line">    <span class="keyword">auto</span> left_brother_page = left_brother_page_guard.<span class="built_in">AsMut</span>&lt;LeafPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge_size = left_brother_page-&gt;<span class="built_in">GetSize</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">    <span class="keyword">if</span> (merge_size &lt; left_brother_page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 可以合并</span></span><br><span class="line">      <span class="comment">// merge</span></span><br><span class="line">      std::<span class="built_in">copy</span>(leaf_page-&gt;<span class="built_in">GetArray</span>(), leaf_page-&gt;<span class="built_in">GetArray</span>() + leaf_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                left_brother_page-&gt;<span class="built_in">GetArray</span>() + left_brother_page-&gt;<span class="built_in">GetSize</span>());</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetSize</span>(merge_size);</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetNextPageId</span>(leaf_page-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">      <span class="built_in">RemoveFromParent</span>(index, ctx, ctx.write_set_.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// borrow</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = leaf_page-&gt;<span class="built_in">GetSize</span>(); i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        leaf_page-&gt;<span class="built_in">GetArray</span>()[i] = leaf_page-&gt;<span class="built_in">GetArray</span>()[i - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      leaf_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>] = left_brother_page-&gt;<span class="built_in">GetArray</span>()[left_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>];</span><br><span class="line">      leaf_page-&gt;<span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetSize</span>(left_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">      parent_page-&gt;<span class="built_in">SetKeyAt</span>(index, leaf_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.<span class="built_in">Drop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPLUSTREE_TYPE::RemoveFromParent</span><span class="params">(<span class="type">int</span> valueIndex, Context &amp;ctx, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;page_guard = ctx.write_set_[index];</span><br><span class="line">  <span class="keyword">auto</span> page = page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = valueIndex + <span class="number">1</span>; i &lt; page-&gt;<span class="built_in">GetSize</span>(); ++i) &#123;  <span class="comment">// 删除key value</span></span><br><span class="line">    page-&gt;<span class="built_in">GetArray</span>()[i - <span class="number">1</span>] = page-&gt;<span class="built_in">GetArray</span>()[i];</span><br><span class="line">  &#125;</span><br><span class="line">  page-&gt;<span class="built_in">SetSize</span>(page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);  <span class="comment">// 更新page的size</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">GetSize</span>() &gt;= page-&gt;<span class="built_in">GetMinSize</span>()) &#123;  <span class="comment">// 无underflow</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// underflow</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="built_in">IsRootPage</span>(page_guard.<span class="built_in">PageId</span>())) &#123;  <span class="comment">// 该page是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;<span class="built_in">GetSize</span>() == <span class="number">1</span>) &#123;               <span class="comment">// 根节点需要更换了</span></span><br><span class="line">      <span class="built_in">BUSTUB_ASSERT</span>(ctx.header_page_ != std::<span class="literal">nullopt</span>, <span class="string">&quot;ctx.header_page must exist&quot;</span>);</span><br><span class="line">      <span class="keyword">auto</span> header_page = ctx.header_page_-&gt;<span class="built_in">AsMut</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">      header_page-&gt;root_page_id_ = page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(index - <span class="number">1</span> &gt;= <span class="number">0</span>, <span class="string">&quot;parent_page_guard must exist&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> &amp;parent_page_guard = ctx.write_set_[index - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">auto</span> parent_page = parent_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line">  <span class="keyword">auto</span> pos = parent_page-&gt;<span class="built_in">ValueIndex</span>(page_guard.<span class="built_in">PageId</span>());</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(pos != <span class="number">-1</span>, <span class="string">&quot;pos must not be -1&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果有右brother</span></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; parent_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">page_id_t</span> right_brother_page_id = parent_page-&gt;<span class="built_in">GetArray</span>()[pos + <span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">auto</span> right_brother_page_guard = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(right_brother_page_id);</span><br><span class="line">    <span class="keyword">auto</span> right_brother_page = right_brother_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge_size = right_brother_page-&gt;<span class="built_in">GetSize</span>() + page-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">    <span class="keyword">if</span> (merge_size &lt;= page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 可以合并</span></span><br><span class="line">      <span class="comment">// merge</span></span><br><span class="line">      std::<span class="built_in">copy</span>(right_brother_page-&gt;<span class="built_in">GetArray</span>(), right_brother_page-&gt;<span class="built_in">GetArray</span>() + right_brother_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                page-&gt;<span class="built_in">GetArray</span>() + page-&gt;<span class="built_in">GetSize</span>());</span><br><span class="line">      page-&gt;<span class="built_in">SetSize</span>(merge_size);</span><br><span class="line">      <span class="built_in">RemoveFromParent</span>(pos + <span class="number">1</span>, ctx, index - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// borrow</span></span><br><span class="line">      page-&gt;<span class="built_in">GetArray</span>()[page-&gt;<span class="built_in">GetSize</span>()] = right_brother_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>];</span><br><span class="line">      std::<span class="built_in">copy</span>(right_brother_page-&gt;<span class="built_in">GetArray</span>() + <span class="number">1</span>, right_brother_page-&gt;<span class="built_in">GetArray</span>() + right_brother_page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                right_brother_page-&gt;<span class="built_in">GetArray</span>());</span><br><span class="line">      page-&gt;<span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">      right_brother_page-&gt;<span class="built_in">SetSize</span>(right_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">      parent_page-&gt;<span class="built_in">SetKeyAt</span>(pos + <span class="number">1</span>, right_brother_page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 左brother</span></span><br><span class="line">    <span class="built_in">BUSTUB_ASSERT</span>(pos - <span class="number">1</span> &gt;= <span class="number">0</span>, <span class="string">&quot;left brother must exist&quot;</span>);</span><br><span class="line">    <span class="type">page_id_t</span> left_brother_page_id = parent_page-&gt;<span class="built_in">GetArray</span>()[pos - <span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">auto</span> left_brother_page_guard = bpm_-&gt;<span class="built_in">FetchPageWrite</span>(left_brother_page_id);</span><br><span class="line">    <span class="keyword">auto</span> left_brother_page = left_brother_page_guard.<span class="built_in">AsMut</span>&lt;InternalPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge_size = left_brother_page-&gt;<span class="built_in">GetSize</span>() + page-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">    <span class="keyword">if</span> (merge_size &lt;= left_brother_page-&gt;<span class="built_in">GetMaxSize</span>()) &#123;  <span class="comment">// 可以合并</span></span><br><span class="line">      <span class="comment">// merge</span></span><br><span class="line">      std::<span class="built_in">copy</span>(page-&gt;<span class="built_in">GetArray</span>(), page-&gt;<span class="built_in">GetArray</span>() + page-&gt;<span class="built_in">GetSize</span>(),</span><br><span class="line">                left_brother_page-&gt;<span class="built_in">GetArray</span>() + left_brother_page-&gt;<span class="built_in">GetSize</span>());</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetSize</span>(merge_size);</span><br><span class="line">      <span class="built_in">RemoveFromParent</span>(pos, ctx, index - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// borrow</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = page-&gt;<span class="built_in">GetSize</span>(); i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        page-&gt;<span class="built_in">GetArray</span>()[i] = page-&gt;<span class="built_in">GetArray</span>()[i - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>] = left_brother_page-&gt;<span class="built_in">GetArray</span>()[left_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>];</span><br><span class="line">      page-&gt;<span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">      left_brother_page-&gt;<span class="built_in">SetSize</span>(left_brother_page-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">      parent_page-&gt;<span class="built_in">SetKeyAt</span>(pos, page-&gt;<span class="built_in">GetArray</span>()[<span class="number">0</span>].first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Task-3-Index-Iterator"><a href="#Task-3-Index-Iterator" class="headerlink" title="Task #3 Index Iterator"></a>Task #3 Index Iterator</h2><p>Index Iterator 代码实现：</p>
<blockquote>
<p>Index Iterator的实现只需要支持单线程</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">INDEXITERATOR_TYPE::IsEnd</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">bool</span> </span>&#123; <span class="keyword">return</span> read_guard_ == std::<span class="literal">nullopt</span>; &#125;</span><br><span class="line"></span><br><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">auto</span> INDEXITERATOR_TYPE::<span class="keyword">operator</span>*() -&gt; <span class="type">const</span> MappingType &amp; &#123;</span><br><span class="line">  <span class="keyword">auto</span> page = read_guard_-&gt;<span class="built_in">As</span>&lt;B_PLUS_TREE_LEAF_PAGE_TYPE&gt;();</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(page-&gt;<span class="built_in">GetSize</span>() &gt; index_, <span class="string">&quot;index_ must be valid&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> page-&gt;<span class="built_in">GetArray</span>()[index_];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">auto</span> INDEXITERATOR_TYPE::<span class="keyword">operator</span>++() -&gt; INDEXITERATOR_TYPE &amp; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsEnd</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> leaf_page = read_guard_-&gt;<span class="built_in">As</span>&lt;B_PLUS_TREE_LEAF_PAGE_TYPE&gt;();</span><br><span class="line">  <span class="keyword">if</span> (index_ + <span class="number">1</span> &lt; leaf_page-&gt;<span class="built_in">GetSize</span>()) &#123;</span><br><span class="line">    index_++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (leaf_page-&gt;<span class="built_in">GetNextPageId</span>() != INVALID_PAGE_ID) &#123;</span><br><span class="line">    read_guard_ = bpm_-&gt;<span class="built_in">FetchPageRead</span>(leaf_page-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">    index_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  read_guard_ = std::<span class="literal">nullopt</span>;</span><br><span class="line">  index_ = INVALID_PAGE_ID;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>==(<span class="type">const</span> IndexIterator &amp;itr) <span class="type">const</span> -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEnd</span>() &amp;&amp; itr.<span class="built_in">IsEnd</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEnd</span>() || itr.<span class="built_in">IsEnd</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> read_guard_-&gt;<span class="built_in">PageId</span>() == itr.read_guard_-&gt;<span class="built_in">PageId</span>() &amp;&amp; index_ == itr.index_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>!=(<span class="type">const</span> IndexIterator &amp;itr) <span class="type">const</span> -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == itr); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BplusTree实现Begin和End函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::Begin</span><span class="params">()</span> -&gt; INDEXITERATOR_TYPE </span>&#123;</span><br><span class="line">  Context ctx;</span><br><span class="line">  <span class="keyword">auto</span> header_page_guard = bpm_-&gt;<span class="built_in">FetchPageRead</span>(header_page_id_);</span><br><span class="line">  <span class="keyword">auto</span> header_page = header_page_guard.<span class="built_in">As</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">  ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(ctx.root_page_id_));</span><br><span class="line">  header_page_guard.<span class="built_in">Drop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">  <span class="keyword">while</span> (!page-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> internal = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;InternalPage&gt;();</span><br><span class="line">    <span class="type">page_id_t</span> id = internal-&gt;<span class="built_in">ValueAt</span>(<span class="number">0</span>);</span><br><span class="line">    ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(id));</span><br><span class="line">    ctx.read_set_.<span class="built_in">pop_front</span>();</span><br><span class="line">    page = ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;BPlusTreePage&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>(bpm_, std::<span class="built_in">move</span>(ctx.read_set_.<span class="built_in">back</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::Begin</span><span class="params">(<span class="type">const</span> KeyType &amp;key)</span> -&gt; INDEXITERATOR_TYPE </span>&#123;</span><br><span class="line">  Context ctx;</span><br><span class="line">  <span class="keyword">auto</span> header_page_guard = bpm_-&gt;<span class="built_in">FetchPageRead</span>(header_page_id_);</span><br><span class="line">  <span class="keyword">auto</span> header_page = header_page_guard.<span class="built_in">As</span>&lt;BPlusTreeHeaderPage&gt;();</span><br><span class="line">  <span class="keyword">if</span> (header_page-&gt;root_page_id_ == INVALID_PAGE_ID) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.root_page_id_ = header_page-&gt;root_page_id_;</span><br><span class="line">  ctx.read_set_.<span class="built_in">push_back</span>(bpm_-&gt;<span class="built_in">FetchPageRead</span>(ctx.root_page_id_));</span><br><span class="line">  header_page_guard.<span class="built_in">Drop</span>();</span><br><span class="line">  <span class="built_in">FindLeafPage</span>(key, Operation::Search, ctx);</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!ctx.read_set_.<span class="built_in">back</span>().<span class="built_in">As</span>&lt;LeafPage&gt;()-&gt;<span class="built_in">KeyIndex</span>(key, comparator_, pos)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;key not exist&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>(bpm_, std::<span class="built_in">move</span>(ctx.read_set_.<span class="built_in">back</span>()), pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BPLUSTREE_TYPE::End</span><span class="params">()</span> -&gt; INDEXITERATOR_TYPE </span>&#123; <span class="keyword">return</span> <span class="built_in">INDEXITERATOR_TYPE</span>(); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Task-4-Concurrency-Control"><a href="#Task-4-Concurrency-Control" class="headerlink" title="Task #4 Concurrency Control"></a>Task #4 Concurrency Control</h2><p>Latch Crabbing&#x2F;Coupling<br><br>Latch Crabbing 的基本思想如下：<br></p>
<ol>
<li>获取 parent 的 latch<br></li>
<li>获取 child 的 latch<br></li>
<li>如果安全，则可以释放 parent 的 latch</li>
</ol>
<p>这里的“安全”指的是，当发生更新操作时，该节点不会发生 split 或 merge 的操作，即：</p>
<ul>
<li>在插入元素时，节点未满</li>
<li>在删除元素时，节点超过半满</li>
</ul>
<p>Search<br>从 root 往下，不断地：</p>
<ul>
<li>获取 child 的 read latch</li>
<li>释放 parent 的 read latch</li>
</ul>
<p><img src="/../images/cmu15445-project2/8.png" alt="img"><br><img src="/../images/cmu15445-project2/9.png" alt="img"><br><img src="/../images/cmu15445-project2/10.png" alt="img"><br><img src="/../images/cmu15445-project2/11.png" alt="img"><br><img src="/../images/cmu15445-project2/12.png" alt="img"></p>
<p>Insert&#x2F;Delete<br><br>从 root 往下，按照需要获取 write latch，一旦获取了 child 的 write latch，检查它是否安全，如果安全，则释放之前获取的所有 write latch。<br>安全判断函数逻辑见函数IsSafePage<br></p>
<p><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/bpt-printer/">Bustub Tree printer</a><br></p>
<p>线上测试<br><br><img src="/../images/cmu15445-project2/7.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2024/02/26/cmu15445-project1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/26/cmu15445-project1/" class="post-title-link" itemprop="url">cmu15445-project1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-02-26 03:58:49 / Modified: 21:28:57" itemprop="dateCreated datePublished" datetime="2024-02-26T03:58:49-08:00">2024-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15445-2023/" itemprop="url" rel="index"><span itemprop="name">cmu15445-2023</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="project1的任务就是实现一个Buffer-Pool-Manager"><a href="#project1的任务就是实现一个Buffer-Pool-Manager" class="headerlink" title="project1的任务就是实现一个Buffer Pool Manager"></a>project1的任务就是实现一个Buffer Pool Manager<br></h2><p>DBMS启动时会从OS申请一片内存区域，即Buffer Pool，并将这块区域划分成大小相同的pages，为了与disk pages区别，通常称为frames，当DBMS请求一个disk page时，它首先需要被复制到Buffer Pool的一个frame中。当Buffer Pool空间不足时，需要采取某种replacement policy，淘汰已有的page。<br><img src="/../images/cmu15445-project1/1.png" alt="img"></p>
<p>question 1:<br>为什么不使用OS自带的磁盘管理模块，OS为开发者提供了mmap这样的调用，使开发者能够依赖OS自动管理数据在内外存之间的移动？</p>
<blockquote>
<p>DBMS比OS拥有更多、更充分的知识来决定数据移动的移动和数量，具体包括</p>
<ol>
<li>将dirty pages按正确的顺序写到磁盘</li>
<li>根据具体情况预获取数据</li>
<li>定制化缓存置换策略</li>
</ol>
</blockquote>
<p>同时DBMS会维护一个page table，负责记录每个page在内存中的位置，以及是否被写过(Dirty Flag),是否被引用或引用计数(Pin&#x2F;Reference Counter)等元信息，如下图所示:</p>
<p><img src="/../images/cmu15445-project1/2.png" alt="img"></p>
<p>当page table中的某page被引用时，会记录引用数(pin&#x2F;reference),表示该page正在被使用，空间不够时不应该被移除；当被请求的page不再page table中时，DBMS会申请一个latch(lock的别名)，表示该entry被占用，然后从disk中读取相关page到buffer pool，释放latch</p>
<p><img src="/../images/cmu15445-project1/3.png" alt="img"></p>
<h2 id="Buffer-Replacement-Policies"><a href="#Buffer-Replacement-Policies" class="headerlink" title="Buffer Replacement Policies"></a>Buffer Replacement Policies</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>维护每个page上一次被访问的时间戳，每次移除时间戳最早的page</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>Clock是LRU的近似策略，它不需要每个page上次被访问的时间戳，而是为每个page保存一个reference</p>
<ul>
<li>每当page被访问时，reference bit设置为1</li>
<li>每当需要移动page时，从上次访问的位置开始，按顺序轮询，每个page的reference bit，若该bit为1，则重置为0；若该bit为0，则移除该page</li>
</ul>
<h3 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h3><p>保存每个page的最后K次访问时间戳，利用这些时间戳来估计它们下次被访问的时间，通常K取1就能获得很好的效果。</p>
<h2 id="Task-1-LRU-K-Replacement-Policy"><a href="#Task-1-LRU-K-Replacement-Policy" class="headerlink" title="Task#1 LRU-K Replacement Policy"></a>Task#1 LRU-K Replacement Policy</h2><p>实现LRUKReplacer<br>实现策略:</p>
<blockquote>
<p>LRU-K算法驱逐replacer的所有frame中backward k-distance最大的frame<br><br>backward k-distance计算方式:当前时间戳与之前k次访问的时间戳之间的时间差。<br><br>历史访问次数少于k的帧被赋予+inf作为其backward k-distance,当多个frame具有+inf backward k-distance时，replacer将驱逐具有最早总体时间戳的frame<br></p>
</blockquote>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：<br></h3><p>一个LRUKNode对应一个frame</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUKNode</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/** History of last seen K timestamps of this page. Least recent timestamp stored in front. */</span></span><br><span class="line">  std::list&lt;<span class="type">size_t</span>&gt; history_;<span class="comment">//记录一批时间戳</span></span><br><span class="line">  <span class="type">frame_id_t</span> fid_;<span class="comment">//</span></span><br><span class="line">  <span class="type">bool</span> is_evictable_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUKReplacer</span> &#123;</span><br><span class="line">  std::unordered_map&lt;<span class="type">frame_id_t</span>, LRUKNode&gt; node_store_;<span class="comment">//frame LRUKNode couple</span></span><br><span class="line">  <span class="type">size_t</span> current_timestamp_&#123;<span class="number">0</span>&#125;;<span class="comment">//当前时间戳</span></span><br><span class="line">  <span class="comment">//replacer_size_ &gt;= curr_size</span></span><br><span class="line">  <span class="type">size_t</span> curr_size_&#123;<span class="number">0</span>&#125;;<span class="comment">//curr_size为当前is_evictable被标记为true的frame数量</span></span><br><span class="line">  <span class="type">size_t</span> replacer_size_;<span class="comment">//replacer_size == num_frames</span></span><br><span class="line">  <span class="type">size_t</span> k_;</span><br><span class="line">  std::mutex latch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Evict函数</p>
<blockquote>
<p>驱逐一个frame，驱逐成功返回true，否则返回false</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LRUKReplacer::Evict</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  *frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : node_store_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.second.is_evictable_) &#123;<span class="comment">//通过Judge函数选择backward k-distance中最大的frame</span></span><br><span class="line">      <span class="keyword">if</span> (*frame_id == <span class="number">-1</span> || <span class="built_in">Judge</span>(p.second, node_store_[*frame_id])) &#123;</span><br><span class="line">        *frame_id = p.second.fid_;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (*frame_id != <span class="number">-1</span>) &#123;</span><br><span class="line">    node_store_.<span class="built_in">erase</span>(*frame_id);</span><br><span class="line">    --curr_size_;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Judge函数实现如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lhs的backward k-distance大于rhs的backward k-distance 返回true 否则返回false</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">Judge</span><span class="params">(<span class="type">const</span> LRUKNode &amp;lhs, <span class="type">const</span> LRUKNode &amp;rhs)</span> <span class="type">const</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rhs.history_.<span class="built_in">size</span>() == k_ &amp;&amp; lhs.history_.<span class="built_in">size</span>() &lt; k_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rhs.history_.<span class="built_in">size</span>() &lt; k_ &amp;&amp; lhs.history_.<span class="built_in">size</span>() == k_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较最早的时间戳,若lhs的时间戳更小，则返回true 否则返回false</span></span><br><span class="line">    <span class="keyword">return</span> lhs.history_.<span class="built_in">back</span>() &lt; rhs.history_.<span class="built_in">back</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>RecordAccess函数</p>
<blockquote>
<ol>
<li>如果访问的frame_id大于等于replacer_size抛出异常</li>
<li>否则，对该frame对应的LRUKNode添加时间戳，并且保证history_列表长度不超过k_</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::RecordAccess</span><span class="params">(<span class="type">frame_id_t</span> frame_id, [[maybe_unused]] AccessType access_type)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (frame_id &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(replacer_size_)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;frame_id is larger than or equal to replacer_size_&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node_store_.<span class="built_in">count</span>(frame_id) == <span class="number">0</span>) &#123;</span><br><span class="line">    node_store_[frame_id] = <span class="built_in">LRUKNode</span>();</span><br><span class="line">    node_store_[frame_id].fid_ = frame_id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> &amp;node = node_store_[frame_id];</span><br><span class="line">  node.history_.<span class="built_in">push_front</span>(current_timestamp_++);</span><br><span class="line">  <span class="keyword">while</span> (node.history_.<span class="built_in">size</span>() &gt; k_) &#123;</span><br><span class="line">    node.history_.<span class="built_in">pop_back</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SetEvictable函数</p>
<blockquote>
<p>将某个frame的is_evictable标记为set_evictable,如果该frame未被占用，抛出异常<br>false-&gt;true   curr_size_++<br>true-&gt;false   curr_size_–</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::SetEvictable</span><span class="params">(<span class="type">frame_id_t</span> frame_id, <span class="type">bool</span> set_evictable)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (node_store_.<span class="built_in">count</span>(frame_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;frame_id should be used&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!node_store_[frame_id].is_evictable_ &amp;&amp; set_evictable) &#123;  <span class="comment">// false -&gt; true</span></span><br><span class="line">    curr_size_++;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node_store_[frame_id].is_evictable_ &amp;&amp; !set_evictable) &#123;  <span class="comment">// true -&gt; false</span></span><br><span class="line">    curr_size_--;</span><br><span class="line">  &#125;</span><br><span class="line">  node_store_[frame_id].is_evictable_ = set_evictable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Remove函数</p>
<blockquote>
<p>如果删除的frame不存在直接返回<br>如果删除的frame的is_evictable_未被设置为true，抛出异常<br>删除frame，–curr_size_</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::Remove</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (node_store_.<span class="built_in">count</span>(frame_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!node_store_[frame_id].is_evictable_) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;Remove a non-evictable frame&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  node_store_.<span class="built_in">erase</span>(frame_id);</span><br><span class="line">  --curr_size_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>task1本地测试：<br><img src="/../images/cmu15445-project1/5.png" alt="img"></p>
<h2 id="Task-2-Buffer-Pool-Manager"><a href="#Task-2-Buffer-Pool-Manager" class="headerlink" title="Task#2 -Buffer Pool Manager"></a>Task#2 -Buffer Pool Manager</h2><p>完成LRU-K替换策略之后，接下来需要实现Buffer Pool的基本功能。对于DBMS来说，Buffer Pool可以隐藏内存和磁盘交互的细节，包括脏页面写回磁盘的过程。</p>
<p>Page</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">  <span class="type">char</span> *data_;<span class="comment">//4096字节</span></span><br><span class="line">  <span class="type">page_id_t</span> page_id;<span class="comment">//physical page id</span></span><br><span class="line">  <span class="type">int</span> pin_count_;<span class="comment">//该Page对象的引用计数</span></span><br><span class="line">  <span class="type">bool</span> is_dirty_;<span class="comment">//脏位</span></span><br><span class="line">  ReaderWriterLatch rwlatch_;<span class="comment">//读写锁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BufferPoolManager</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BufferPoolManager</span> &#123;</span><br><span class="line">    <span class="comment">/** Number of pages in the buffer pool. */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> pool_size_;</span><br><span class="line">  <span class="comment">/** The next page id to be allocated  */</span></span><br><span class="line">  std::atomic&lt;<span class="type">page_id_t</span>&gt; next_page_id_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Array of buffer pool pages. */</span></span><br><span class="line">  Page *pages_;</span><br><span class="line">  <span class="comment">/** Pointer to the disk manager. */</span></span><br><span class="line">  DiskManager *disk_manager_ __attribute__((__unused__));</span><br><span class="line">  <span class="comment">/** Pointer to the log manager. Please ignore this for P1. */</span></span><br><span class="line">  LogManager *log_manager_ __attribute__((__unused__));</span><br><span class="line">  <span class="comment">/** Page table for keeping track of buffer pool pages. */</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_;</span><br><span class="line">  <span class="comment">/** Replacer to find unpinned pages for replacement. */</span></span><br><span class="line">  std::unique_ptr&lt;LRUKReplacer&gt; replacer_;</span><br><span class="line">  <span class="comment">/** List of free frames that don&#x27;t have any pages on them. */</span></span><br><span class="line">  std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;</span><br><span class="line">  <span class="comment">/** This latch protects shared data structures. We recommend updating this comment to describe what it protects. */</span></span><br><span class="line">  std::mutex latch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BufferPoolManager初始化时，分配pool_size_个Page对象，LRUKReplacer的num_frame也设置为pool_size_</p>
<h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：<br></h3><p>NewPage函数实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::NewPage</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> -&gt; Page * </span>&#123;</span><br><span class="line">  <span class="type">frame_id_t</span> free_frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="comment">//获取一个空闲的frame</span></span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;<span class="comment">//存在空的frame</span></span><br><span class="line">    free_frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//不存在空的frame</span></span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Evict</span>(&amp;free_frame_id)) &#123;<span class="comment">//通过LRUKReplacer得到一个空闲的frame</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pages_[free_frame_id].<span class="built_in">IsDirty</span>()) &#123;<span class="comment">//如果被驱逐的frame对应的page为脏页，需要进行写回操作</span></span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[free_frame_id].page_id_, pages_[free_frame_id].data_);</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_.<span class="built_in">erase</span>(pages_[free_frame_id].page_id_);<span class="comment">//将page_table_中该frame对应的page_id_删除</span></span><br><span class="line">    pages_[free_frame_id].<span class="built_in">ResetMemory</span>();<span class="comment">//重置该改frame对应的内存</span></span><br><span class="line">  &#125;</span><br><span class="line">  *page_id = <span class="built_in">AllocatePage</span>();</span><br><span class="line">  pages_[free_frame_id].page_id_ = *page_id;</span><br><span class="line">  pages_[free_frame_id].pin_count_ = <span class="number">1</span>;</span><br><span class="line">  pages_[free_frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  page_table_[*page_id] = free_frame_id;</span><br><span class="line"></span><br><span class="line">  replacer_-&gt;<span class="built_in">RecordAccess</span>(free_frame_id);</span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(free_frame_id, <span class="literal">false</span>);  <span class="comment">// no use</span></span><br><span class="line">  <span class="keyword">return</span> pages_ + free_frame_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FetchPage函数实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPage</span><span class="params">(<span class="type">page_id_t</span> page_id, [[maybe_unused]] AccessType access_type)</span> -&gt; Page * </span>&#123;</span><br><span class="line">  <span class="built_in">BUSTUB_ASSERT</span>(page_id != INVALID_PAGE_ID, <span class="string">&quot;page_id is equal to INVALID_PAGE_ID&quot;</span>);</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) != <span class="number">0</span>) &#123;<span class="comment">//如果page_table_中存在该page_id</span></span><br><span class="line">    pages_[page_table_[page_id]].pin_count_++;<span class="comment">//该page的引用计数增加</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">RecordAccess</span>(page_table_[page_id]);<span class="comment">//增加该page对应的frame的访问时间戳</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(page_table_[page_id], <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> pages_ + page_table_[page_id];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> free_frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//获取一个空闲的frame</span></span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    free_frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!replacer_-&gt;<span class="built_in">Evict</span>(&amp;free_frame_id)) &#123;<span class="comment">//通过LRUKReplacer得到一个空闲的frame</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pages_[free_frame_id].<span class="built_in">IsDirty</span>()) &#123;<span class="comment">//如果被驱逐的frame对应的page为脏页，需要进行写回操作</span></span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(pages_[free_frame_id].page_id_, pages_[free_frame_id].data_);</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_.<span class="built_in">erase</span>(pages_[free_frame_id].page_id_);<span class="comment">//将page_table_中该frame对应的page_id_删除</span></span><br><span class="line">    pages_[free_frame_id].<span class="built_in">ResetMemory</span>();<span class="comment">//重置该改frame对应的内存</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pages_[free_frame_id].page_id_ = page_id;</span><br><span class="line">  pages_[free_frame_id].pin_count_ = <span class="number">1</span>;</span><br><span class="line">  pages_[free_frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  page_table_[page_id] = free_frame_id;</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, pages_[free_frame_id].data_);<span class="comment">//读取该page_id对应的物理页</span></span><br><span class="line"></span><br><span class="line">  replacer_-&gt;<span class="built_in">RecordAccess</span>(free_frame_id);<span class="comment">//增加该frame的访问时间戳</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(free_frame_id, <span class="literal">false</span>);  <span class="comment">// no use</span></span><br><span class="line">  <span class="keyword">return</span> pages_ + free_frame_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UnpinPage函数实现：<br><br>需要注意的是入参is_dirty不能破坏已经置为脏的状态，这里用 | 运算符来实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::UnpinPage</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty, [[maybe_unused]] AccessType access_type)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = page_table_[page_id];</span><br><span class="line">  <span class="keyword">if</span> (pages_[frame_id].pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (--pages_[frame_id].pin_count_ == <span class="number">0</span>) &#123;<span class="comment">//引用计数减为0时，将该frame设置为evictable</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pages_[frame_id].is_dirty_ |= is_dirty;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FlushPage函数实现:<br><br>强制将page_id对应的Page的内容写回磁盘，并将该Page对应脏位置为false</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FlushPage</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = page_table_[page_id];</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">WritePage</span>(page_id, pages_[frame_id].data_);</span><br><span class="line">  pages_[frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FlushAllPages函数实现:<br>写回所有在内存中的Page</p>
<p>DeletePage函数实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::DeletePage</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = page_table_[page_id];</span><br><span class="line">  <span class="keyword">if</span> (pages_[frame_id].pin_count_ != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//只有当该page_id对应的Page的引用计数为0时可以进行删除</span></span><br><span class="line">  page_table_.<span class="built_in">erase</span>(page_id);<span class="comment">//page_table_删除该page_id</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">true</span>);<span class="comment">//replacer驱逐该frame</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">Remove</span>(frame_id);</span><br><span class="line">  free_list_.<span class="built_in">push_back</span>(frame_id);<span class="comment">//将该frame加入free_list</span></span><br><span class="line">  <span class="comment">//该Page初始化</span></span><br><span class="line">  pages_[frame_id].is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  pages_[frame_id].page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  pages_[frame_id].<span class="built_in">ResetMemory</span>();</span><br><span class="line">  <span class="built_in">DeallocatePage</span>(page_id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>task2本地测试:<br><img src="/../images/cmu15445-project1/6.png" alt="img"></p>
<h2 id="Task-3-Read-Write-Page-Guards"><a href="#Task-3-Read-Write-Page-Guards" class="headerlink" title="Task#3 Read&#x2F;Write Page Guards"></a>Task#3 Read&#x2F;Write Page Guards</h2><p>FetchPage和NewPage函数返回指向pages的指针，并且pages已经被pinned，并且当一个page不再需要时，要调用UnpinPage。另一方面，如果忘记调用UnPinPage，该Page将永远不会被evict。于是PageGuard就派上用场了</p>
<p>BasicPageGuard<br>思路：BasicPageGuard析构时调用Page的UnpinPage函数，并且BasicPageGuard中保存变量is_dirty_,调用AsMut或GetDataMut函数时将is_dirty_设置为true</p>
<p>WritePageGuard和ReadPageGuard<br>思路：与BasicPageGuard思路相似，析构函数调用UnpinPage多了一步释放Page的写锁和读锁</p>
<p>FetchPageBasic、FetchPageRead、FetchPageWrite和NewPageGuarded的实现代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageBasic</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; BasicPageGuard </span>&#123; <span class="keyword">return</span> &#123;<span class="keyword">this</span>, <span class="built_in">FetchPage</span>(page_id)&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageRead</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; ReadPageGuard </span>&#123;</span><br><span class="line">  Page *page = <span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (page != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    page-&gt;<span class="built_in">RLatch</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, page&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageWrite</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; WritePageGuard </span>&#123;</span><br><span class="line">  Page *page = <span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (page != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, page&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::NewPageGuarded</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> -&gt; BasicPageGuard </span>&#123; <span class="keyword">return</span> &#123;<span class="keyword">this</span>, <span class="built_in">NewPage</span>(page_id)&#125;; &#125;</span><br></pre></td></tr></table></figure>
<p>task3本地测试：<br><img src="/../images/cmu15445-project1/7.png" alt="img"></p>
<p>测试通过截图：<br><img src="/../images/cmu15445-project1/4.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2024/02/22/cmu15445-project0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/22/cmu15445-project0/" class="post-title-link" itemprop="url">cmu15445-project0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-22 02:15:27" itemprop="dateCreated datePublished" datetime="2024-02-22T02:15:27-08:00">2024-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-26 03:53:04" itemprop="dateModified" datetime="2024-02-26T03:53:04-08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmu15445-2023/" itemprop="url" rel="index"><span itemprop="name">cmu15445-2023</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TASK-1-Copy-On-Write-Trie"><a href="#TASK-1-Copy-On-Write-Trie" class="headerlink" title="TASK 1 Copy-On-Write Trie"></a>TASK 1 Copy-On-Write Trie</h2><p>COW Trie在每次插入和删除时不会改变原有节点，而是对该节点的副本进行修改后，依次为其父节点创建修改后的副本，最后返回一个新的根节点。<br>此外，删除操作中，如果回溯路径上的某节点无值，且不存在子节点，还需要删除该节点</p>
<hr>
<p>插入(“ad”, 2),创建了一个新的Node2<br><img src="/../images/cmu15445-project0/2.png" alt="img"></p>
<hr>
<p>插入(“b”, 3)<br><img src="/../images/cmu15445-project0/1.png" alt="img"></p>
<hr>
<p>插入(“a”, “abc”) 删除(“ab”, 1)<br><br>注意删除操作后需要清除所有不需要的节点</p>
<p><img src="/../images/cmu15445-project0/3.png" alt="img"></p>
<p>Get函数实现</p>
<blockquote>
<p>从root节点遍历Tire树，<br>如果key不存在返回nullptr，<br>如果key存在，但是对应的Node无value或者value的类型不匹配，返回nullptr<br>其它情况，返回value</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the value associated with the given key.</span></span><br><span class="line"><span class="comment">// 1. If the key is not in the trie, return nullptr.</span></span><br><span class="line"><span class="comment">// 2. If the key is in the trie but the type is mismatched, return nullptr.</span></span><br><span class="line"><span class="comment">// 3. Otherwise, return the value.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Get</span><span class="params">(std::string_view key)</span> <span class="type">const</span> -&gt; <span class="type">const</span> T * </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; <span class="title">ptr</span><span class="params">(root_)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> ch : key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr-&gt;children_.<span class="built_in">count</span>(ch) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = ptr-&gt;children_.<span class="built_in">at</span>(ch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!ptr-&gt;is_value_node_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> p = std::dynamic_pointer_cast&lt;<span class="type">const</span> TrieNodeWithValue&lt;T&gt;&gt;(ptr);</span><br><span class="line">  <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p-&gt;value_.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Trie::Put</span><span class="params">(std::string_view key, T value)</span> <span class="type">const</span> -&gt; Trie </span>&#123;</span><br><span class="line">  <span class="comment">// Note that `T` might be a non-copyable type. Always use `std::move` when creating `shared_ptr` on that value.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// You should walk through the trie and create new nodes if necessary. If the node corresponding to the key already</span></span><br><span class="line">  <span class="comment">// exists, you should create a new `TrieNodeWithValue`.</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt; <span class="title">new_root</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">  std::map&lt;<span class="type">char</span>, std::shared_ptr&lt;<span class="type">const</span> TrieNode&gt;&gt; children;</span><br><span class="line">  <span class="keyword">if</span> (key.<span class="built_in">length</span>() == <span class="number">0</span>) &#123;<span class="comment">//key长度为0，表示在root节点put value</span></span><br><span class="line">    <span class="keyword">if</span> (root_) &#123;</span><br><span class="line">      children = root_-&gt;children_;</span><br><span class="line">    &#125;</span><br><span class="line">    new_root = std::make_shared&lt;<span class="type">const</span> TrieNodeWithValue&lt;T&gt;&gt;(children, std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value)));<span class="comment">//创建一个新的root节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Trie</span>(new_root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;TrieNode&gt;&gt; stack;</span><br><span class="line">  <span class="keyword">if</span> (root_) &#123;</span><br><span class="line">    stack.<span class="built_in">push_back</span>(root_-&gt;<span class="built_in">Clone</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    stack.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;TrieNode&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">ptr</span><span class="params">(root_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int64_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(key.<span class="built_in">length</span>() - <span class="number">1</span>); ++i) &#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;TrieNode&gt; <span class="title">tmp_ptr</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (ptr &amp;&amp; ptr-&gt;children_.<span class="built_in">count</span>(key[i]) == <span class="number">1</span>) &#123;</span><br><span class="line">      ptr = ptr-&gt;children_.<span class="built_in">at</span>(key[i]);</span><br><span class="line">      tmp_ptr = ptr-&gt;<span class="built_in">Clone</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp_ptr = std::<span class="built_in">make_unique</span>&lt;TrieNode&gt;();</span><br><span class="line">      ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(tmp_ptr));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> value_ptr = std::<span class="built_in">make_shared</span>&lt;T&gt;(std::<span class="built_in">move</span>(value));</span><br><span class="line">  <span class="keyword">if</span> (ptr &amp;&amp; ptr-&gt;children_.<span class="built_in">count</span>(key.<span class="built_in">back</span>())) &#123;</span><br><span class="line">    ptr = ptr-&gt;children_.<span class="built_in">at</span>(key.<span class="built_in">back</span>());</span><br><span class="line">    children = ptr-&gt;children_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> value_node = std::make_unique&lt;TrieNodeWithValue&lt;T&gt;&gt;(children, std::<span class="built_in">move</span>(value_ptr));</span><br><span class="line">  stack.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(value_node));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int64_t</span> i = key.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp_ptr = std::<span class="built_in">move</span>(stack.<span class="built_in">back</span>());</span><br><span class="line">    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">    stack.<span class="built_in">back</span>()-&gt;children_[key[i]] = std::<span class="built_in">move</span>(tmp_ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  new_root = std::<span class="built_in">move</span>(stack.<span class="built_in">back</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Trie</span>(new_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="TASK-2-Concurrent-Key-Value-Store"><a href="#TASK-2-Concurrent-Key-Value-Store" class="headerlink" title="TASK 2 Concurrent Key-Value Store"></a>TASK 2 Concurrent Key-Value Store</h2><blockquote>
<p>concurrent Key-Value store需要支持 <strong>多个读者和一个写者</strong> 工作的情况<br>也就是当一个写者在创建一个新的root的时候，读者可以在old root进行读操作<br>Tire_store.cpp文件<br></p>
</blockquote>
<p>读操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TrieStore::Get</span><span class="params">(std::string_view key)</span> -&gt; std::optional&lt;ValueGuard&lt;T&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Pseudo-code:</span></span><br><span class="line">  <span class="comment">// (1) Take the root lock, get the root, and release the root lock. Don&#x27;t lookup the value in the</span></span><br><span class="line">  <span class="comment">//     trie while holding the root lock.</span></span><br><span class="line">  <span class="comment">// (2) Lookup the value in the trie.</span></span><br><span class="line">  <span class="comment">// (3) If the value is found, return a ValueGuard object that holds a reference to the value and the</span></span><br><span class="line">  <span class="comment">//     root. Otherwise, return std::nullopt.</span></span><br><span class="line">  Trie root;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root = root_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> T *val = root.<span class="built_in">Get</span>&lt;T&gt;(key);</span><br><span class="line">  <span class="keyword">if</span> (!val) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ValueGuard</span>&lt;T&gt;(root, *val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Put</span><span class="params">(std::string_view key, T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span></span><br><span class="line">  <span class="comment">// The logic should be somehow similar to `TrieStore::Get`.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(write_lock_)</span></span>;</span><br><span class="line">  Trie root;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root = root_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Trie new_root = root.<span class="built_in">Put</span>&lt;T&gt;(key, std::<span class="built_in">move</span>(value));</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root_ = new_root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieStore::Remove</span><span class="params">(std::string_view key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// You will need to ensure there is only one writer at a time. Think of how you can achieve this.</span></span><br><span class="line">  <span class="comment">// The logic should be somehow similar to `TrieStore::Get`.</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(write_lock_)</span></span>;</span><br><span class="line">  Trie root;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root = root_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Trie new_root = root.<span class="built_in">Remove</span>(key);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(root_lock_)</span></span>;</span><br><span class="line">    root_ = new_root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="TASK-3-Debugging"><a href="#TASK-3-Debugging" class="headerlink" title="TASK 3 Debugging"></a>TASK 3 Debugging</h2><p>skip…….</p>
<h2 id="TASK-4-SQL-String-Functions"><a href="#TASK-4-SQL-String-Functions" class="headerlink" title="TASK 4 SQL String Functions"></a>TASK 4 SQL String Functions</h2><p>实现Upper方法和Lower方法<br>src&#x2F;include&#x2F;execution&#x2F;string_expression.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Compute</span><span class="params">(<span class="type">const</span> std::string &amp;val)</span> <span class="type">const</span> -&gt; std::string </span>&#123;</span><br><span class="line">    <span class="comment">// TODO(student): implement upper / lower.</span></span><br><span class="line">    std::string res;</span><br><span class="line">    res.<span class="built_in">resize</span>(val.<span class="built_in">length</span>());</span><br><span class="line">    <span class="keyword">switch</span> (expr_type_) &#123;</span><br><span class="line">      <span class="keyword">case</span> StringExpressionType::Lower:</span><br><span class="line">        std::<span class="built_in">transform</span>(val.<span class="built_in">begin</span>(), val.<span class="built_in">end</span>(), res.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> StringExpressionType::Upper:</span><br><span class="line">        std::<span class="built_in">transform</span>(val.<span class="built_in">begin</span>(), val.<span class="built_in">end</span>(), res.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:<br><br><img src="/../images/cmu15445-project0/4.png" alt="img"></p>
<p>测试通过截图：<br><br><img src="/../images/cmu15445-project0/5.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2023/12/28/DILI-A-Distribution-Driven-Learned-Index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/28/DILI-A-Distribution-Driven-Learned-Index/" class="post-title-link" itemprop="url">DILI-A-Distribution-Driven-Learned-Index</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-28 07:07:45" itemprop="dateCreated datePublished" datetime="2023-12-28T07:07:45-08:00">2023-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-25 23:45:34" itemprop="dateModified" datetime="2024-02-25T23:45:34-08:00">2024-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learned-Index/" itemprop="url" rel="index"><span itemprop="name">Learned Index</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>需要有一批数据用于批量加载构建初始数据，不支持从0开始构建（一个key一个key插入），支持读写操作。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一棵树中查找一个key，包含两部分；找到包含key的leaf node，leaf node的local search<br>查找性能取决于leaf node的深度和线性回归模型的accuracy</p>
<h2 id="方法和结果"><a href="#方法和结果" class="headerlink" title="方法和结果"></a>方法和结果</h2><p>提出一种two-phase bulk loading算法，先构建一棵BU（bottom-up）-Tree，它的node布局由greedy merging 算法（考虑了leaf node的深度和线性回归模型的accuracy）决定，接着根据BU-Tree的node布局构建DILI.<br>BU-Tree中internal node的range并不是被它的child平分<br>DILI与LIPP相比，每个leaf node的keys分布更接近线性，发生冲突的概率更低<br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/1.png" alt="img"></p>
<p>Search without Optimization<br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/2.png" alt="img"></p>
<p>Building BU-Tree<br>难点：确定nh的大小和nh - 1个breakpoints<br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/3.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/4.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/5.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/6.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/7.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/8.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/9.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/10.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/11.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/12.png" alt="img"><br><img src="/../images/DILI-A-Distribution-Driven-Learned-Index/13.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2023/12/07/cmake-generator-error-under-windows-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/07/cmake-generator-error-under-windows-system/" class="post-title-link" itemprop="url">cmake-generator-error-under-windows-system</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-07 00:22:51" itemprop="dateCreated datePublished" datetime="2023-12-07T00:22:51-08:00">2023-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-25 23:45:34" itemprop="dateModified" datetime="2024-02-25T23:45:34-08:00">2024-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cmake/" itemprop="url" rel="index"><span itemprop="name">cmake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.安装windows版本cmake（配置环境变量）<br>2.安装windows版本mingw（配置环境变量）<br>3.创建工程目录<br>执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -G &quot;MinGW Makefiles&quot; -D &quot;CMAKE_MAKE_PROGRAM:PATH=your path to make.exe&quot;</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dcrmg/article/details/103918543">https://blog.csdn.net/dcrmg/article/details/103918543</a><br><a target="_blank" rel="noopener" href="https://codeantenna.com/a/ELzh11ElWs">https://codeantenna.com/a/ELzh11ElWs</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2023/12/05/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/05/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/" class="post-title-link" itemprop="url">SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-05 22:02:09" itemprop="dateCreated datePublished" datetime="2023-12-05T22:02:09-08:00">2023-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-25 23:45:34" itemprop="dateModified" datetime="2024-02-25T23:45:34-08:00">2024-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learned-Index/" itemprop="url" rel="index"><span itemprop="name">Learned Index</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>SALI: A Scalable Adaptive Learned Index Framework based on<br>Probability Models<br>一个基于概率模型的可进化学习索引框架</p>
<h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>LI：只读<br>可写：<br>1.基于缓冲区的策略（插入时放入缓冲区，到达一个阈值后进行合并操作）<br>XIndex、FINEdex<br>2.基于模型的策略（就地插入）<br>ALEX（在插入冲突中，映射的slot已经被占用，通过移动来尝试重新组织节点）、<br>LIPP（利用链接方案，为相应的时隙创建一个新节点，将最后一英里问题转化为子树遍历问题）</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/1.png" alt="img"><br>上述的索引结构都不能以高并发性进行扩展</p>
<p>并发数较少的时候，与基于模型的策略（ALEX+、LIPP+）相比，基于缓冲区策略（XIndex、FINEdex）的索引表现出较差的基本性能和较差的扩展性；并且随着并发数的提高，“最后一英里问题”搜索会迅速饱和内存带宽，从而成为系统的瓶颈（ALEX+必须为此操作获取粗粒度写锁，线程数量增加时，越来越多的线程被阻塞）</p>
<p>LIPP+没有最后一英里问题，但是它需要在每个节点中维护统计信息，如访问计数和冲突计数（以触发节点再训练，防止性能下降）。这些节点计数器在线程之间造成高争用。</p>
<h2 id="难点与分析过程"><a href="#难点与分析过程" class="headerlink" title="难点与分析过程"></a>难点与分析过程</h2><p>我们需要设计一个满足如下要求的可扩展学习索引<br>1.Efficient Concurrency高效并发：<br>为了实现高效的插入性能，索引必须跟踪统计信息，这些信息反映了由于新的插入而导致的索引结构随时间的退化（这些信息对于触发节点再训练至关重要），但是节点计数器在线程之间会造成高争用，需要一种轻量级方法<br>2.Adaptive ability适应能力<br>与均匀工作负载相比，学习索引在倾斜插入工作负载下表现出次优性能。因此，学习索引需要有自适应能力以保证其在并发场景的鲁棒性。此外，学习的索引缺乏用于查找操作的优化策略。在偏斜的工作负载下，学习索引尚未充分利用显著降低索引空间成本的机会。</p>
<p>3.Low overheads of basic performance基本性能的低开销<br>(1)Efficient lookup<br>实现高查找性能，通常取决于最大限度地减少查找的预测错误<br>(2)Efficient insert<br>采用基于模型的策略，而不是基于缓冲区的策略，通过在每个节点中保留间隙，可以显著提高学习索引的插入性能</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>提出SALI<br>1.利用LIPP+结构（使用细粒度锁）<br>2.除了模型重训练以外定义一组节点进化策略，以允许学习到的索引自适应于不同的工作负载倾斜（建议对具有不同读写热度的节点应用不同的进化策略）<br>3.用轻量级概率模型取代了现有学习索引中的每个节点的统计信息，以消除统计信息维护的可扩展性瓶颈</p>
<p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/2.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/3.png" alt="img"></p>
<p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/4.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/5.png" alt="img"></p>
<p>进化策略：<br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/6.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/7.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/8.png" alt="img"></p>
<p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/9.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/10.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/11.png" alt="img"></p>
<p>概率模型：<br>为了确保最佳性能，学习索引必须监控退化统计信息，以便在必要时启动调整；另外，进化策略需要额外的统计信息。<br>基本概念：模拟信息积累时利用概率</p>
<p>例子：<br>1.当模拟指定时间段内插入key的累积数量时，我们设计一个基于插入率和插入时间的概率模型<br>2.几何分布可以用来模拟信息的累计（插入冲突等）</p>
<p>触发insert evolution的条件</p>
<p>Condition1：评估一个节点及其子树中新key插入的频率<br>该节点容纳足够数量的新插入的key<br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/12.png" alt="img"></p>
<p>n.current_num:是指在当前插入操作结束时节点中包含的key的数量<br>n.build_num:是指上一次执行完进化策略后节点中的key的数量<br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/13.png" alt="img"></p>
<p>Condition2：节点内冲突的升级（判断节点是否恶化）<br>Node必须由足够的新插入的key<br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/14.png" alt="img"><br><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/15.png" alt="img"></p>
<p><strong>先计算Pconflict是否被触发，如果触发，再判断Pacc是否被触发，如果两个条件都被触发，执行进化策略</strong></p>
<p>触发lookup evolution的条件<br>Phl<br>还需要考虑以下两个条件<br>Condition1:<br>再很长的一段时间内，节点上的查找操作没有触发进化策略</p>
<p>Condition2:<br>节点累计数据的速率并不慢</p>
<p>For condition1：如果一个节点的最后一次进化操作是由hot lookup触发的，这意味着自那以后没有插入操作触发该节点进化，即该节点没有严重恶化，并且新插入key的数量可能很少，可以将Phl调整到一个更小的值</p>
<p><img src="/../images/SALI-A-Scalable-Adaptive-Learned-Index-Framework-based-on-Probability-Models/16.png" alt="img"></p>
<p>For condition2：引入Pacc，如果自上次进化操作以来插入了大量新的key，则表明可能需要进行新一轮的进化操作</p>
<p>每个线程维护一个skip_counter，每次查找操作，skip_counter加1，10次查找操作后，执行一次伯努利实验来判断Phl是否被触发。如果Phl被触发，判断Pacc是否也被触发，如果触发，执行进化策略。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2023/12/05/NFL-Robust-Learned-Index-via-Distribution-Transformation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/05/NFL-Robust-Learned-Index-via-Distribution-Transformation/" class="post-title-link" itemprop="url">NFL-Robust-Learned-Index-via-Distribution-Transformation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-05 21:37:11" itemprop="dateCreated datePublished" datetime="2023-12-05T21:37:11-08:00">2023-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-25 23:45:34" itemprop="dateModified" datetime="2024-02-25T23:45:34-08:00">2024-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learned-Index/" itemprop="url" rel="index"><span itemprop="name">Learned Index</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>只读负载</li>
<li>读写负载，但是数据分布变化不大（即CDF随着key的插入删除变化较小）</li>
</ul>
<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>之前的学习索引通过设计更好的启发式方法来划分key空间，使得每一份被分割的sub key空间可以更好地被线性模型拟合。<br>缺点：</p>
<ul>
<li>为了达到这个目的，学习索引必须构建更深的层次结构，从而产生更多的遍历时间和预测数量<br>（类似于用一个分段线性函数去拟合数据分布CDF）。</li>
</ul>
<h2 id="难点和分析过程："><a href="#难点和分析过程：" class="headerlink" title="难点和分析过程："></a>难点和分析过程：</h2><p>本文提出了学习索引NFL（包括两个结构Normalizing Flow 和 Learned Index ）</p>
<p><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/1.jpg" alt="img"><br>思想： 先用分布转换模型将复杂key分布转换为近似均匀的分布，然后利用转换的key构建学习索引</p>
<p><strong>难点</strong></p>
<p>（1）Efficacy of Normalizing flow:</p>
<ul>
<li>由于key的数字数据特征有限，分布转换模型表现不佳</li>
<li>均匀分布很难作为训练目标（我们设计了一个具有丰富特征空间的分布转换模型和一个易于操作的训练目标）</li>
</ul>
<p>（2）Efficiency of normalizing flow</p>
<ul>
<li>分布转化必须是高效的在线步骤，这样就限制了NF的复杂性。但是直接减少参数数量标准化流程可能会降低转换质量（这样会导致学习索引需要更深的层次结构和更多的模型来近似CDF），（我们设计了一套效率优化方案，并且保证NF的功效）</li>
</ul>
<p>（3）Lack of proper indexes for transformed keys：</p>
<ul>
<li>numerica NF的转换使线性模型拟合地更好，学习索引应该以新的视角重新思考。（我们提出了After-Flow Learned Index（AFLI），充分利用转换后的key）</li>
</ul>
<p><strong>方法</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/1.jpg" alt="img"><br>以下两个是评价模型转换质量的指标<br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/2.jpg" alt="img"></p>
<p>Tail conflict degree：</p>
<p>Numerical Normalizing Flow:<br>Feature Space Expansion:现有的NF大多用在cv和nlp领域，用于处理高纬的图片和文本，这些数据都有丰富的特征。然而keys都是数值数据，含有的特征较少。<br>使用Algorithm 3.1分布转换算法（对keys的数值特征进行扩展）<br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/3.jpg" alt="img"></p>
<p>特征扩展的时间复杂度为O（n x d）</p>
<p><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/4.png" alt="img"></p>
<p>Structure of AFLI：<br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/5.jpg" alt="img"></p>
<p><strong>Model node:</strong><br>Empty Slot：unused slot<br>Data Slot：key payload<br>Bucket Pointer: 指向一个bucket<br>Node Pointer：指向一个model node或者dense node<br><strong>Bucket:</strong><br>a short data array.它的size由tail conflict degree决定，但将保持在预设阈值范围内。我们提供两种桶，线性桶（默认）和有序桶</p>
<p><strong>Dense node：</strong><br>Also a data array，比bucket大一点，但是比Model node小很多，是一个ordered and gapped array, gap的最大值由tail conflict degree</p>
<p><strong>Analysis:</strong><br>当索引无法建立模型节点时，因为节点中的所有键都太近（即拟合线性模型的斜率为0），索引会分配一个dense array</p>
<p><strong>Queries:</strong><br>（1）从root node开始查找，如果是model node，先用linear model预测position，判断它的类型，如果是empty slot，表示不存在；如果是data slot，比较是否是相同的key；如果是bucket pointer，在bucket中查找；如果是node pointer，递归操作<br>（2）如果node是dense node，使用二分查找查找这个结果。</p>
<p><strong>Insertions:</strong><br>（1）如果key-payload pair被插入model node，先用linear model预测position</p>
<ul>
<li>如果是empty slot，直接存储key-payload</li>
<li>如果是data slot，表明发生冲突，创建一个bucket来存储这两个key</li>
<li>如果是bucket pointer或者node pointer，插入key-payload到bucket或者child node中<br>（2）插入到bucket中时，将key-payload会直接被加到sorted data的末尾；如果bucket是一个ordered mode，将会执行一次插入排序。<br>（3）插入到dense node中时，先在array上执行二分查找，如果那个position是一个empty slot，我们会直接插入key-payload pair；，否则会移动到最近的empty slot再插入。</li>
</ul>
<p>如果bucket或者dense node没有empty slots，我们尽量通过一个modeling operation将它转换为model node<br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/6.jpg" alt="img"></p>
<p><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/7.jpg" alt="img"><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/8.jpg" alt="img"></p>
<p>我们首先一个使用线性回归创建线性模型（Line 1）<br>如果slope 为0（所有key被映射到一个相同的position），我们为创建一个dense node（Line 2 - 4）<br>否则如果我们成功创建一个linear model，就计算model node所有位置的conflict degree（Line 6）<br>然后我们遍历所有预测的位置，决定每个pos的entry type。如果conflict degree为1，我们直接在data slot存储该key；如果conflict degree大于1但是比bucket的tail confict degree小，存储在一个bucket中（Line 14 - 17）；<br>否则，如果某个position的confict degree比bucket的tail conflict degree大，找到下一个conflict degree也大于tail conflict degree的position或者到末尾，并将经过的position的key都收集起来，并分配一个新的节点来处理它们（第18 - 21行）<br>BulkLoad：首先计算tail conflict degree. The returned result is the root node.<br>Update: lookup + in-place update<br>Delete</p>
<h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><p><strong>数据集：</strong><br>选取了7个不同的数据集进行评估<br>（Key的类型为double     payload的类型是int64）</p>
<p>对每种类型的数据集构建了四种类型的工作负载</p>
<p>每种工作负载包括 批量加载和运行阶段<br>我们使用批量加载操作来加载数据集的50%的key；在运行阶段，根据不同的操作比率生成请求</p>
<ul>
<li>只读</li>
<li>读80% 写20%</li>
<li>写 20% 读80%</li>
<li>只写</li>
</ul>
<p>将NFL与LIPP、ALEX、PGM-index、B-Tree、an efficient B-Tree对比</p>
<p><strong>平均吞吐量</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/9.jpg" alt="img"></p>
<ul>
<li>只读：NFL与LIPP、ALEX、PGM、B-Tree相比，平均吞吐量分别提高了2.34倍、2.46倍、3.82倍、7.45倍；对于具有大冲突程度的工作负载（即LLT和FB），可以分别实现比LIPP、ALEX高2.41x和3.70x的吞吐量。</li>
<li>重读：与LIPP、ALEX、PGM、B-Tree相比，NFL在吞吐量上分别提高72.22%、101.05%、611.48%、389.45%</li>
<li>重写：与LIPP、ALEX、PGM、B-Tree相比，NFL在吞吐量上分别提高29.10%、39.28%、50.88%、162.92%</li>
<li>只写：与LIPP、ALEX、B-Tree相比，NFL在吞吐量上分别提高22.65%、28.30%和131.58%</li>
</ul>
<p><strong>延迟</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/10.jpg" alt="img"></p>
<ul>
<li>只读：与LIPP、ALEX、PGM index、B-Tree相比，NFL可以将延迟分别降低58.68%、32.89%、62.73%和80.77%</li>
<li>读写：与LIPP、ALEX、PGM index和B-Tree相比，NFL可以将延迟分别降低26.64%、45.05%、59.49%、65.31%</li>
<li>只写：与LIPP、ALEX、B-Tree相比，NFL可以将延迟减少2.26%、27.92%、50.48%</li>
</ul>
<p><strong>批量加载时间</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/11.jpg" alt="img"></p>
<p>与LIPP、ALEX、B-Tree相比，NFL需要2.25倍、0.86倍、2.81倍的大容量加载时间，其中77%的时间是用来转换key的</p>
<p><strong>索引大小：</strong><br><img src="/../images/NFL-Robust-Learned-Index-via-Distribution-Transformation/12.jpg" alt="img"><br>NFL的指数大小分别是ALEX和PGM的2.26倍和3.1倍；然而，NFL的大小仅为LIPP大小的0.51</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2023/10/10/Updatable-Learned-Index-with-Precise-Positions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/10/Updatable-Learned-Index-with-Precise-Positions/" class="post-title-link" itemprop="url">Updatable-Learned-Index-with-Precise-Positions</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-10 04:13:07" itemprop="dateCreated datePublished" datetime="2023-10-10T04:13:07-07:00">2023-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-25 23:45:34" itemprop="dateModified" datetime="2024-02-25T23:45:34-08:00">2024-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learned-Index/" itemprop="url" rel="index"><span itemprop="name">Learned Index</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>读写负载</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Learned Index：只能在只读数据集上查找，无法处理索引结构中必不可少的更新操作<br>ALEX和PGM：它们对更新的支持是以查找操作的额外搜索为代价的；并且这些索引的更新操作也会导致大量元素的移动</p>
<p>需要一种索引可以解决“最后一英里问题”</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>每个Node包含一个model、一个entries array、一个bit数组，<br>每个bit表示array中一个entry的类型，<br>类型有<br>NULL（空entry），<br>DATA(entry包含一个键值对，如果键值对太大，保存一个指向payload的指针)，<br>NODE（该entry指向下一层中的一个子节点，将一个新元素插入DATA entry时，创建一个子节点保存这两个entry，该entry指向这个新的节点）</p>
<p>三种类型的entry的大小都为16byte，其中DATA类型的entry由8byte的key和8byte的payload组成<br>对于第i个entry，bit数组的第2<em>i位表示该entry是不是NULL,第2</em>i + 1位表示entry的type</p>
<p>LIPP不区分leaf node和internal node<br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/1.jpg" alt="img"><br>各种操作的算法：<br>FMCD算法：</p>
<blockquote>
<p>给定一组key和数组长度L，计算最小的冲突度T及相应的linear model</p>
</blockquote>
<p><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/2.jpg" alt="img"><br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/3.jpg" alt="img"><br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/4.jpg" alt="img"><br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/5.jpg" alt="img"><br><img src="/../images/Updatable-Learned-Index-with-Precise-Positions/6.jpg" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2023/10/10/Bounding-the-Last-Mile-Efficient-Learned-String-Indexing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/10/Bounding-the-Last-Mile-Efficient-Learned-String-Indexing/" class="post-title-link" itemprop="url">Bounding-the-Last-Mile-Efficient-Learned-String-Indexing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-10 03:47:58" itemprop="dateCreated datePublished" datetime="2023-10-10T03:47:58-07:00">2023-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-25 23:45:34" itemprop="dateModified" datetime="2024-02-25T23:45:34-08:00">2024-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learned-Index/" itemprop="url" rel="index"><span itemprop="name">Learned Index</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>ReadOnly<br>对字符串的学习索引最重要的问题是 last-mile-search,并且这种搜索在字符串场景中特别昂贵。</p>
<p>两个原因</p>
<blockquote>
<ol>
<li>由于难以建模真实世界的数据（许多真实世界的数据集具有很长的共同前缀以及每个字节相对较低的鉴别内容，CDF似乎是循序渐近的，这样传统的学习模型很难准确捕获和预测），这些场景的平均模型误差往往很高</li>
<li>最后一英里的搜索是很慢的，每次比较是昂贵的，字符串的大尺寸减少了适合在缓存中的键的数量</li>
</ol>
</blockquote>
<p>这项研究的基础： Bounded Error（这样就可以使用二分查找代替指数搜索）</p>
<h2 id="SPLING-STRINGS"><a href="#SPLING-STRINGS" class="headerlink" title="SPLING STRINGS"></a>SPLING STRINGS</h2><p>问题描述：对于字符串而言，需要满足两种操作</p>
<ol>
<li>确定性查找，找到完全匹配的字符</li>
<li>模糊匹配，找到第一个满足匹配条件的元素（下届）</li>
</ol>
<h3 id="RADIX-STRING-SPLINE"><a href="#RADIX-STRING-SPLINE" class="headerlink" title="RADIX STRING SPLINE"></a>RADIX STRING SPLINE</h3><p>RSS是一棵树，每个节点包含三个部分：<br><img src="/../imgaes/../images/Bounding-the-Last-Mile-Efficient-Learned-String-Indexing/2.png" alt="img"></p>
<ul>
<li>bounds: 可操作的数据下标范围</li>
<li>重定向map(指针):包含并指向了一些key，这些key因为不满足当前节点的error bound，因而被分配到了其他节点</li>
<li>一个使用K个byte作为前缀，错误范围为E的RadixSpline模型</li>
</ul>
<h4 id="如何构建？"><a href="#如何构建？" class="headerlink" title="如何构建？"></a>如何构建？</h4><ol>
<li>首先，对数据集中所有字符串构建一个RadixSpline(使用前k个字节)。然后，遍历所有唯一的k字节前缀，并检查估计的位置是否在前缀的第一次出现和最后一次出现时都在规定的误差范围内。</li>
<li>对于每个测试失败的前缀，我们将其添加到重定向表中，并在有问题前缀的所有字符串中构建一个新的RSS，从字节k开始而不是0</li>
<li>这个过程递归地继续进行，直到每个key都得到满足为止。</li>
</ol>
<h4 id="如何查询"><a href="#如何查询" class="headerlink" title="如何查询"></a>如何查询</h4><p><img src="/../images/Bounding-the-Last-Mile-Efficient-Learned-String-Indexing/1.png" alt="img"><br>首先提取字符串的前k个字节，然后对重定向器进行二分查找，如果找到重定向新的RSS节点，就重新开始对下一个k字节进行操作；如果没有找到，那么就在当前节点使用适当的字符串前缀查找并返回结果。</p>
<h2 id="HASH-CORRECTOR"><a href="#HASH-CORRECTOR" class="headerlink" title="HASH CORRECTOR"></a>HASH CORRECTOR</h2><p>待更新</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://jingtao8a.github.io/2023/10/05/The-PGM-index-a-fully-dynamic-compressed-learned-index-with-provable-worst-case-bounds/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iverson.jpg">
      <meta itemprop="name" content="jingtao8a">
      <meta itemprop="description" content="this is life, full of ups and down">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jingtao8a's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/05/The-PGM-index-a-fully-dynamic-compressed-learned-index-with-provable-worst-case-bounds/" class="post-title-link" itemprop="url">The-PGM-index-a-fully-dynamic-compressed-learned-index-with-provable-worst-case-bounds</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-05 02:06:39" itemprop="dateCreated datePublished" datetime="2023-10-05T02:06:39-07:00">2023-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-25 23:45:34" itemprop="dateModified" datetime="2024-02-25T23:45:34-08:00">2024-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learned-Index/" itemprop="url" rel="index"><span itemprop="name">Learned Index</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>PGM &#x3D;&#x3D; PieceWise Geometric Model 分段几何模型<br>关键词：dynamic(表示PGM-index除了支持查询还支持插入和删除)、compressed(表示还对模型进行了压缩，达到更好的空间效率)</p>
<p>本文的注意力集中在解决所谓的全动态可索引字典问题。这个问题要求存储多重集S，以便有效支持以下查询和更新操作</p>
<ol>
<li>member (x) &#x3D; true if x ∈ S, false otherwise;</li>
<li>lookup(x) returns the satellite data of x ∈ S (if any), nil otherwise;</li>
<li>predecessor (x) &#x3D; max{y ∈ S | y &lt; x};</li>
<li>range(x, y) &#x3D; S ∩ [x, y];</li>
<li>insert(x) adds x to S, i.e. S ← S ∪ {x};</li>
<li>delete(x) removes x from S, i.e. S ← S \ {x}.</li>
</ol>
<ul>
<li>member(x)，判断关键字x是否属于多重集S</li>
<li>lookup(x)，给定一个key，若该key已被插入，则返回其value</li>
<li>predecessor(x)，翻译软件叫“前任”，返回所有小于x的数据中最大的那个，其实可以简单理解为排好序的数组中，x的前一个数据</li>
<li>range(x, y)，范围查询，给出[x, y]关键字x和y之间的所有对应的value</li>
<li>insert和delete很好理解，插入和删除对应的（K, V）</li>
</ul>
<p>本文将 member,lookup,predecessor称为点查询，range称为范围查询<br>对于点查询和范围查询只要实现rank(x)<br>member(x) &lt;–&gt; A[rank(x)] &#x3D;&#x3D; x<br>predecessor(x) &lt;–&gt;A[rank(x) - 1]<br>range(x, y) &lt;–&gt; 从rank(x)对应的A数组的位置开始向后查找直到key大于y为止</p>
<p>现存的解决上述问题的经典索引数据结构：（1）哈希索引（2）B树（3）位图索引（4）字典树trie索引<br>哈希索引不支持predecesor和range，位图索引维护成本过高，字典树空间消耗过大，主流数据库还是使用B树及其变种作为存储引擎</p>
<p>本文提出的PGM-Index不像RMI和FITing-Tree那样混合了传统的索引和学习型索引。(RMI的最后一个stage中的模型若error超过阈值，则将模型替换为B+树，FITing-Tree在确定segment时也是查找B+树)</p>
<h2 id="PGM-Index"><a href="#PGM-Index" class="headerlink" title="PGM-Index"></a>PGM-Index</h2><p>两个关键点：</p>
<blockquote>
<p>1.PLA-Model(Piecewise Linear Approximation model, 分段线性近似模型)</p>
</blockquote>
<p>这里使用了多个线性模型(segment, FITing-Tree中的分段线性模型)组成了一个PLA-Model(PGM-Index中的一层)，一个segment包含了三部分(start key, slope, intercept)</p>
<blockquote>
<p>2.recursive index structure (递归索引结构)</p>
</blockquote>
<p>为了适应key的分布，PGM-Index使用了多层PLA-Model，我们先使用所有的key来构建最底层的PLA-Model，然后提取Segment中的key形成新的集合，然后对该集合再次构建PLA-Model，如此递归直到最高层的PLA-Model只有一个segment</p>
<p>下图包含了PGM-Index的构建伪代码，查找伪代码和查找示意图<br><img src="/../images/The-PGM-index-a-fully-dynamic-compressed-learned-index-with-provable-worst-case-bounds/1.png" alt="img"></p>
<h3 id="Optimal-PLA-model"><a href="#Optimal-PLA-model" class="headerlink" title="Optimal PLA-model"></a>Optimal PLA-model</h3><p>找到最优的PLA-model的方法是动态规划，但它所需要的O(n^3)是禁止的。FITing-Tree的作者通过收缩锥的方式来在线性时间内解决这个问题但无法保证是最优的PLA-model</p>
<p>然而我们发现这个问题在时间序列的有损压缩和相似性搜索中得到了广泛的研究，并且它允许采用O(n)最优时间和空间的流媒体算法。这类方法的关键思想是将分段线性近似问题简化为构造一组点的凸包在我们的情况下，这是集合{(ki，rank(ki))}为i &#x3D; 0，…，n−1。只要凸包可以被封闭在一个高度不超过2ε的（可能是旋转的）矩形中，索引i就会递增，集合就会被扩展。一旦包围凸壳的矩形高于2ε，我们就停止构造，通过取将矩形分成两个等尺寸的半的线来确定pla模型的一部分。然后，清空当前的处理元素集，算法从其余的输入点重新启动。这种贪婪方法可以被证明在pla模型的大小上是最优的，并且具有线性的时间和空间复杂度。</p>
<h2 id="DYNAMIC-PGM-INDEX"><a href="#DYNAMIC-PGM-INDEX" class="headerlink" title="DYNAMIC PGM-INDEX"></a>DYNAMIC PGM-INDEX</h2><p>插入和删除操作</p>
<p>现有学习型索引插入操作的实现方案是，将元素按序插入到相应段的缓存中，当缓存满了，将缓存与主索引合并，合并需要重新训练。这个方案在key非常多时，效率较低。本文提出两个插入策略：（1）面向时序数据（2）面向一般数据</p>
<ul>
<li>如果是时间序列的数据，插入的数据肯定是在数组A的最后面，那么如果最后一个段能够存放这个数据，且满足ε的条件，就直接放在最后一个段；否则新建一个段，然后向上层一层一层更新Segment。在这种策略下，每层更新最多只涉及到一个Segment的添加，因此需要的I&#x2F;O少。</li>
<li>如果是一般的数据，即插入的位置可以是任意的。这里则采用LSM-Tree更新数据的思想。</li>
</ul>
<p><img src="/../images/The-PGM-index-a-fully-dynamic-compressed-learned-index-with-provable-worst-case-bounds/2.png" alt="img"></p>
<h2 id="COMPRESSED-PGM-INDEX"><a href="#COMPRESSED-PGM-INDEX" class="headerlink" title="COMPRESSED PGM-INDEX"></a>COMPRESSED PGM-INDEX</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="jingtao8a"
      src="/images/iverson.jpg">
  <p class="site-author-name" itemprop="name">jingtao8a</p>
  <div class="site-description" itemprop="description">this is life, full of ups and down</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jingtao8a</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
